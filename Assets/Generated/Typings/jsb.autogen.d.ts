declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1, Enum } from "System";
    /** Script interface for ParticleSystem. Unity's powerful and versatile particle system implementation.
     */
    class ParticleSystem extends Component {
        constructor()
        SetParticles(particles: Array<any>, size: number, offset: number): void
        SetParticles(particles: Array<any>, size: number): void
        SetParticles(particles: Array<any>): void
        GetParticles(particles: Array<any>, size: number, offset: number): number
        GetParticles(particles: Array<any>, size: number): number
        GetParticles(particles: Array<any>): number
        SetCustomParticleData(customData: any, streamIndex: any): void
        GetCustomParticleData(customData: any, streamIndex: any): number
        GetPlaybackState(): any
        SetPlaybackState(playbackState: any): void
        GetTrails(trailData: jsb.Ref<any>): number
        GetTrails(): any
        SetTrails(trailData: any): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean, restart: boolean, fixedTimeStep: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean, restart: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number, withChildren: boolean): void
        /** Fast-forwards the Particle System by simulating particles over the given period of time, then pauses it.
         * @param t Time period in seconds to advance the ParticleSystem simulation by. If restart is true, the ParticleSystem will be reset to 0 time, and then advanced by this value. If restart is false, the ParticleSystem simulation will be advanced in time from its current state by this value.
         * @param withChildren Fast-forward all child Particle Systems as well.
         * @param restart Restart and start from the beginning.
         * @param fixedTimeStep Only update the system at fixed intervals, based on the value in "Fixed Time" in the Time options.
         */
        Simulate(t: number): void
        /** Starts the Particle System.
         * @param withChildren Play all child Particle Systems as well.
         */
        Play(withChildren: boolean): void
        Play(): void
        /** Pauses the system so no new particles are emitted and the existing particles are not updated.
         * @param withChildren Pause all child Particle Systems as well.
         */
        Pause(withChildren: boolean): void
        Pause(): void
        /** Stops playing the Particle System using the supplied stop behaviour.
         * @param withChildren Stop all child Particle Systems as well.
         * @param stopBehavior Stop emitting or stop emitting and clear the system.
         */
        Stop(withChildren: boolean, stopBehavior: any): void
        /** Stops playing the Particle System using the supplied stop behaviour.
         * @param withChildren Stop all child Particle Systems as well.
         * @param stopBehavior Stop emitting or stop emitting and clear the system.
         */
        Stop(withChildren: boolean): void
        Stop(): void
        /** Remove all particles in the Particle System.
         * @param withChildren Clear all child Particle Systems as well.
         */
        Clear(withChildren: boolean): void
        Clear(): void
        /** Does the Particle System contain any live particles, or will it produce more?
         * @param withChildren Check all child Particle Systems as well.
         * @returns True if the Particle System contains live particles or is still creating new particles. False if the Particle System has stopped emitting particles and all particles are dead. 
         */
        IsAlive(withChildren: boolean): boolean
        IsAlive(): boolean
        Emit(emitParams: any, count: number): void
        /** Emit count particles immediately.
         * @param count Number of particles to emit.
         */
        Emit(count: number): void
        TriggerSubEmitter(subEmitterIndex: number, particle: jsb.Ref<any>): void
        TriggerSubEmitter(subEmitterIndex: number, particles: any): void
        /** Triggers the specified sub emitter on all particles of the Particle System.
         * @param subEmitterIndex Index of the sub emitter to trigger.
         */
        TriggerSubEmitter(subEmitterIndex: number): void
        AllocateAxisOfRotationAttribute(): void
        AllocateMeshIndexAttribute(): void
        /** Ensures that the ParticleSystemJobs.ParticleSystemJobData.customData1|customData1 and ParticleSystemJobs.ParticleSystemJobData.customData1|customData2 particle attribute arrays are allocated.
         * @param stream The custom data stream to allocate.
         */
        AllocateCustomDataAttribute(stream: any): void
        /** Safe array size for use with ParticleSystem.GetCollisionEvents.
         */
        GetSafeCollisionEventSize(): number
        GetCollisionEvents(go: GameObject, collisionEvents: any): number
        /** Safe array size for use with ParticleSystem.GetTriggerParticles.
         * @param ps Particle system.
         * @param type Type of trigger to return size for.
         * @returns Number of particles with this trigger event type. 
         */
        GetSafeTriggerParticlesSize(type: any): number
        GetTriggerParticles(type: any, particles: any, colliderData: jsb.Out<any>): number
        GetTriggerParticles(type: any, particles: any): number
        SetTriggerParticles(type: any, particles: any, offset: number, count: number): void
        SetTriggerParticles(type: any, particles: any): void
        static ResetPreMappedBufferMemory(): void
        /** Limits the amount of graphics memory Unity reserves for efficient rendering of Particle Systems.
         * @param vertexBuffersCount The maximum number of cached vertex buffers.
         * @param indexBuffersCount The maximum number of cached index buffers.
         */
        static SetMaximumPreMappedBufferCounts(vertexBuffersCount: number, indexBuffersCount: number): void
        /** Determines whether the Particle System is playing.
         */
        readonly isPlaying: boolean
        /** Determines whether the Particle System is emitting particles. A Particle System may stop emitting when its emission module has finished, it has been paused or if the system has been stopped using ParticleSystem.Stop|Stop with the ParticleSystemStopBehavior.StopEmitting|StopEmitting flag. Resume emitting by calling ParticleSystem.Play|Play.
         */
        readonly isEmitting: boolean
        /** Determines whether the Particle System is in the stopped state.
         */
        readonly isStopped: boolean
        /** Determines whether the Particle System is paused.
         */
        readonly isPaused: boolean
        /** The current number of particles (Read Only). The number doesn't include particles of child Particle Systems
         */
        readonly particleCount: number
        /** Playback position in seconds.
         */
        time: number
        /** Override the random seed used for the Particle System emission.
         */
        randomSeed: number
        /** Controls whether the Particle System uses an automatically-generated random number to seed the random number generator.
         */
        useAutoRandomSeed: boolean
        /** Does this system support Procedural Simulation?
         */
        readonly proceduralSimulationSupported: boolean
        /** Access the main Particle System settings.
         */
        readonly main: ParticleSystem.MainModule
        /** Script interface for the EmissionModule of a Particle System.
         */
        readonly emission: any
        /** Script interface for the ShapeModule of a Particle System. 
         */
        readonly shape: any
        /** Script interface for the VelocityOverLifetimeModule of a Particle System.
         */
        readonly velocityOverLifetime: any
        /** Script interface for the LimitVelocityOverLifetimeModule of a Particle System. .
         */
        readonly limitVelocityOverLifetime: any
        /** Script interface for the InheritVelocityModule of a Particle System.
         */
        readonly inheritVelocity: any
        /** Script interface for the Particle System Lifetime By Emitter Speed module.
         */
        readonly lifetimeByEmitterSpeed: any
        /** Script interface for the ForceOverLifetimeModule of a Particle System.
         */
        readonly forceOverLifetime: any
        /** Script interface for the ColorOverLifetimeModule of a Particle System.
         */
        readonly colorOverLifetime: any
        /** Script interface for the ColorByLifetimeModule of a Particle System.
         */
        readonly colorBySpeed: any
        /** Script interface for the SizeOverLifetimeModule of a Particle System. 
         */
        readonly sizeOverLifetime: any
        /** Script interface for the SizeBySpeedModule of a Particle System.
         */
        readonly sizeBySpeed: any
        /** Script interface for the RotationOverLifetimeModule of a Particle System.
         */
        readonly rotationOverLifetime: any
        /** Script interface for the RotationBySpeedModule of a Particle System.
         */
        readonly rotationBySpeed: any
        /** Script interface for the ExternalForcesModule of a Particle System.
         */
        readonly externalForces: any
        /** Script interface for the NoiseModule of a Particle System.
         */
        readonly noise: any
        /** Script interface for the CollisionModule of a Particle System.
         */
        readonly collision: any
        /** Script interface for the TriggerModule of a Particle System.
         */
        readonly trigger: any
        /** Script interface for the SubEmittersModule of a Particle System.
         */
        readonly subEmitters: any
        /** Script interface for the TextureSheetAnimationModule of a Particle System.
         */
        readonly textureSheetAnimation: any
        /** Script interface for the LightsModule of a Particle System.
         */
        readonly lights: any
        /** Script interface for the TrailsModule of a Particle System.
         */
        readonly trails: any
        /** Script interface for the CustomDataModule of a Particle System.
         */
        readonly customData: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1 } from "System";
    /** Use this class to render particles on to the screen.
     */
    class ParticleSystemRenderer extends Renderer {
        constructor()
        /** Gets the array of Meshes to use when selecting particle meshes.
         * @param meshes An array this function populates with the list of Meshes the ParticleSystemRenderer uses for particle Mesh selection. If the array is smaller than the number of Meshes, this function cannot populate it with every Mesh. If the array is larger than the number of Meshes, this function ignores indices greater than the number of Meshes. Use ParticleSystemRenderer.meshCount to get the number of Meshes the ParticleSystemRenderer has.
         * @returns The number of Meshes this function wrote to the destination array. 
         */
        GetMeshes(meshes: Array<any>): number
        /** Sets the Meshes that the ParticleSystemRenderer uses to display particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh.
         * @param meshes The array of Meshes to use.
         * @param size The number of elements from the Mesh array to apply.
         */
        SetMeshes(meshes: Array<any>, size: number): void
        /** Sets the Meshes that the ParticleSystemRenderer uses to display particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh.
         * @param meshes The array of Meshes to use.
         * @param size The number of elements from the Mesh array to apply.
         */
        SetMeshes(meshes: Array<any>): void
        /** Gets the array of Mesh weightings to use when randomly selecting particle meshes.
         * @param weightings An array this function populates with the list of Mesh weightings the ParticleSystemRenderer uses for particle Mesh selection. If the array is smaller than the number of weights, this function cannot populate it with every weight. If the array is larger than the number of weights, this function ignores indices greater than the number of weights. Use ParticleSystemRenderer.meshCount to get the number of Meshes, and thus weights, the ParticleSystemRenderer has.
         * @returns The number of weights this function wrote to the destination array. 
         */
        GetMeshWeightings(weightings: Array<number>): number
        /** Sets the weights that the ParticleSystemRenderer uses to assign Meshes to particles.
         * @param weightings The array of weights to use.
         * @param size The number of elements from the weighting array to apply.
         */
        SetMeshWeightings(weightings: Array<number>, size: number): void
        /** Sets the weights that the ParticleSystemRenderer uses to assign Meshes to particles.
         * @param weightings The array of weights to use.
         * @param size The number of elements from the weighting array to apply.
         */
        SetMeshWeightings(weightings: Array<number>): void
        /** Creates a snapshot of ParticleSystemRenderer and stores it in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particles.
         * @param camera The Camera used to determine which way camera-space particles face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeMesh(mesh: any, camera: Camera, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystemRenderer and stores it in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particles.
         * @param camera The Camera used to determine which way camera-space particles face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeMesh(mesh: any, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystem Trails and stores them in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particle trails.
         * @param camera The Camera used to determine which way camera-space trails face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeTrailsMesh(mesh: any, camera: Camera, useTransform: boolean): void
        /** Creates a snapshot of ParticleSystem Trails and stores them in mesh.
         * @param mesh A static Mesh to receive the snapshot of the particle trails.
         * @param camera The Camera used to determine which way camera-space trails face.
         * @param useTransform Specifies whether to include the rotation and scale of the Transform in the baked Mesh.
         */
        BakeTrailsMesh(mesh: any, useTransform: boolean): void
        SetActiveVertexStreams(streams: any): void
        GetActiveVertexStreams(streams: any): void
        /** Control the direction that particles face.
         */
        alignment: any
        /** Specifies how the system draws particles.
         */
        renderMode: any
        /** Specifies how the system randomly assigns meshes to particles.
         */
        meshDistribution: any
        /** Specifies how to sort particles within a system.
         */
        sortMode: any
        /** How much are the particles stretched in their direction of motion, defined as the length of the particle compared to its width.
         */
        lengthScale: number
        /** Specifies how much particles stretch depending on their velocity.
         */
        velocityScale: number
        /** How much do the particles stretch depending on the Camera's speed.
         */
        cameraVelocityScale: number
        /** Specifies how much a billboard particle orients its normals towards the Camera.
         */
        normalDirection: number
        /** Apply a shadow bias to prevent self-shadowing artifacts. The specified value is the proportion of the particle size.
         */
        shadowBias: number
        /** Biases Particle System sorting amongst other transparencies.
         */
        sortingFudge: number
        /** Clamp the minimum particle size.
         */
        minParticleSize: number
        /** Clamp the maximum particle size.
         */
        maxParticleSize: number
        /** Modify the pivot point used for rotating particles.
         */
        pivot: Vector3
        /** Flip a percentage of the particles, along each axis.
         */
        flip: Vector3
        /** Specifies how the Particle System Renderer interacts with SpriteMask.
         */
        maskInteraction: any
        /** Set the Material that the TrailModule uses to attach trails to particles.
         */
        trailMaterial: Material
        /** Enables GPU Instancing on platforms that support it.
         */
        enableGPUInstancing: boolean
        /** Allow billboard particles to roll around their z-axis.
         */
        allowRoll: boolean
        /** Enables freeform stretching behavior.
         */
        freeformStretching: boolean
        /** Rotate the particles based on the direction they are stretched in. This is added on top of other particle rotation.
         */
        rotateWithStretchDirection: boolean
        /** The Mesh that the particle uses instead of a billboarded Texture.
         */
        mesh: any
        /** The number of Meshes the system uses for particle rendering.
         */
        readonly meshCount: number
        /** The number of currently active custom vertex streams.
         */
        readonly activeVertexStreamsCount: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    namespace ParticleSystem {
        class MainModule extends ValueType {
            constructor()
            emitterVelocity: Vector3
            duration: number
            loop: boolean
            prewarm: boolean
            startDelay: any
            startDelayMultiplier: number
            startLifetime: any
            startLifetimeMultiplier: number
            startSpeed: any
            startSpeedMultiplier: number
            startSize3D: boolean
            startSize: any
            startSizeMultiplier: number
            startSizeX: any
            startSizeXMultiplier: number
            startSizeY: any
            startSizeYMultiplier: number
            startSizeZ: any
            startSizeZMultiplier: number
            startRotation3D: boolean
            startRotation: any
            startRotationMultiplier: number
            startRotationX: any
            startRotationXMultiplier: number
            startRotationY: any
            startRotationYMultiplier: number
            startRotationZ: any
            startRotationZMultiplier: number
            flipRotation: number
            startColor: any
            gravityModifier: any
            gravityModifierMultiplier: number
            simulationSpace: ParticleSystemSimulationSpace
            customSimulationSpace: Transform
            simulationSpeed: number
            useUnscaledTime: boolean
            scalingMode: any
            playOnAwake: boolean
            maxParticles: number
            emitterVelocityMode: any
            stopAction: any
            ringBufferMode: any
            ringBufferLoopRange: Vector2
            cullingMode: any
        }
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** The space to simulate particles in.
     */
    enum ParticleSystemSimulationSpace {
        /** Simulate particles in local space.
         */
        Local = 0,
        /** Simulate particles in world space.
         */
        World = 1,
        /** Simulate particles relative to a custom transform component, defined by ParticleSystem.MainModule.customSimulationSpace.
         */
        Custom = 2,
    }
}
declare module "System.Net" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class IPHostEntry extends Object {
        constructor()
        HostName: string
        Aliases: Array<string>
        AddressList: Array<any>
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class DateTime extends ValueType {
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: any, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number, calendar: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, kind: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, calendar: any)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond: number)
        constructor(year: number, month: number, day: number, hour: number, minute: number, second: number)
        constructor(year: number, month: number, day: number, calendar: any)
        constructor(year: number, month: number, day: number)
        constructor(ticks: number, kind: any)
        constructor(ticks: number)
        Add(value: any): DateTime
        AddDays(value: number): DateTime
        AddHours(value: number): DateTime
        AddMilliseconds(value: number): DateTime
        AddMinutes(value: number): DateTime
        AddMonths(months: number): DateTime
        AddSeconds(value: number): DateTime
        AddTicks(value: number): DateTime
        AddYears(value: number): DateTime
        CompareTo(value: Object): number
        CompareTo(value: DateTime): number
        Equals(value: Object): boolean
        Equals(value: DateTime): boolean
        IsDaylightSavingTime(): boolean
        ToBinary(): number
        GetHashCode(): number
        Subtract(value: DateTime): any
        Subtract(value: any): DateTime
        ToOADate(): number
        ToFileTime(): number
        ToFileTimeUtc(): number
        ToLocalTime(): DateTime
        ToLongDateString(): string
        ToLongTimeString(): string
        ToShortDateString(): string
        ToShortTimeString(): string
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        ToUniversalTime(): DateTime
        GetDateTimeFormats(format: string, provider: any): Array<string>
        GetDateTimeFormats(provider: any): Array<string>
        GetDateTimeFormats(format: string): Array<string>
        GetDateTimeFormats(): Array<string>
        GetTypeCode(): any
        static Compare(t1: DateTime, t2: DateTime): number
        static DaysInMonth(year: number, month: number): number
        static Equals(t1: DateTime, t2: DateTime): boolean
        static FromBinary(dateData: number): DateTime
        static FromFileTime(fileTime: number): DateTime
        static FromFileTimeUtc(fileTime: number): DateTime
        static FromOADate(d: number): DateTime
        static SpecifyKind(value: DateTime, kind: any): DateTime
        static IsLeapYear(year: number): boolean
        static Parse(s: string, provider: any, styles: any): DateTime
        static Parse(s: string, provider: any): DateTime
        static Parse(s: string): DateTime
        static ParseExact(s: string, format: string, provider: any, style: any): DateTime
        static ParseExact(s: string, formats: Array<string>, provider: any, style: any): DateTime
        static ParseExact(s: string, format: string, provider: any): DateTime
        static TryParse(s: string, provider: any, styles: any, result: jsb.Out<DateTime>): boolean
        static TryParse(s: string, result: jsb.Out<DateTime>): boolean
        static TryParseExact(s: string, format: string, provider: any, style: any, result: jsb.Out<DateTime>): boolean
        static TryParseExact(s: string, formats: Array<string>, provider: any, style: any, result: jsb.Out<DateTime>): boolean
        static op_Addition(d: DateTime, t: any): DateTime
        static op_Subtraction(d: DateTime, t: any): DateTime
        static op_Subtraction(d1: DateTime, d2: DateTime): any
        static op_Equality(d1: DateTime, d2: DateTime): boolean
        static op_Inequality(d1: DateTime, d2: DateTime): boolean
        static op_LessThan(t1: DateTime, t2: DateTime): boolean
        static op_LessThanOrEqual(t1: DateTime, t2: DateTime): boolean
        static op_GreaterThan(t1: DateTime, t2: DateTime): boolean
        static op_GreaterThanOrEqual(t1: DateTime, t2: DateTime): boolean
        readonly Date: DateTime
        readonly Day: number
        readonly DayOfWeek: any
        readonly DayOfYear: number
        readonly Hour: number
        readonly Kind: any
        readonly Millisecond: number
        readonly Minute: number
        readonly Month: number
        static readonly Now: DateTime
        readonly Second: number
        readonly Ticks: number
        readonly TimeOfDay: any
        static readonly Today: DateTime
        readonly Year: number
        static readonly UtcNow: DateTime
        static readonly MinValue: DateTime
        static readonly MaxValue: DateTime
        static readonly UnixEpoch: DateTime
    }
}
declare module "System.IO" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    class FileInfo extends Object {
        constructor(fileName: string)
        OpenText(): any
        CreateText(): any
        AppendText(): any
        CopyTo(destFileName: string, overwrite: boolean): FileInfo
        CopyTo(destFileName: string): FileInfo
        Create(): any
        Delete(): void
        Open(mode: any, access: any, share: any): any
        Open(mode: any, access: any): any
        Open(mode: any): any
        OpenRead(): any
        OpenWrite(): any
        MoveTo(destFileName: string): void
        Replace(destinationFileName: string, destinationBackupFileName: string, ignoreMetadataErrors: boolean): FileInfo
        Replace(destinationFileName: string, destinationBackupFileName: string): FileInfo
        Decrypt(): void
        Encrypt(): void
        readonly Length: number
        readonly DirectoryName: string
        readonly Directory: any
        IsReadOnly: boolean
        readonly Name: string
    }
}
declare module "System.IO" {
    import * as jsb from "jsb";
    import { Object, Enum, DateTime, Array, ValueType } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    abstract class File extends Object {
        static OpenText(path: string): any
        static CreateText(path: string): any
        static AppendText(path: string): any
        static Copy(sourceFileName: string, destFileName: string, overwrite: boolean): void
        static Copy(sourceFileName: string, destFileName: string): void
        static Create(path: string, bufferSize: number, options: any): any
        static Create(path: string, bufferSize: number): any
        static Create(path: string): any
        static Delete(path: string): void
        static Exists(path: string): boolean
        static Open(path: string, mode: any, access: any): any
        static Open(path: string, mode: any): any
        static SetCreationTime(path: string, creationTime: DateTime): void
        static SetCreationTimeUtc(path: string, creationTimeUtc: DateTime): void
        static GetCreationTime(path: string): DateTime
        static GetCreationTimeUtc(path: string): DateTime
        static SetLastAccessTime(path: string, lastAccessTime: DateTime): void
        static SetLastAccessTimeUtc(path: string, lastAccessTimeUtc: DateTime): void
        static GetLastAccessTime(path: string): DateTime
        static GetLastAccessTimeUtc(path: string): DateTime
        static SetLastWriteTime(path: string, lastWriteTime: DateTime): void
        static SetLastWriteTimeUtc(path: string, lastWriteTimeUtc: DateTime): void
        static GetLastWriteTime(path: string): DateTime
        static GetLastWriteTimeUtc(path: string): DateTime
        static GetAttributes(path: string): any
        static SetAttributes(path: string, fileAttributes: any): void
        static OpenRead(path: string): any
        static OpenWrite(path: string): any
        static ReadAllText(path: string, encoding: any): string
        static ReadAllText(path: string): string
        static WriteAllText(path: string, contents: string, encoding: any): void
        static WriteAllText(path: string, contents: string): void
        static ReadAllBytes(path: string): Array<jsb.byte>
        static WriteAllBytes(path: string, bytes: Array<jsb.byte>): void
        static ReadAllLines(path: string, encoding: any): Array<string>
        static ReadAllLines(path: string): Array<string>
        static ReadLines(path: string, encoding: any): IEnumerable<string>
        static ReadLines(path: string): IEnumerable<string>
        static WriteAllLines(path: string, contents: Array<string>, encoding: any): void
        static WriteAllLines(path: string, contents: IEnumerable<string>, encoding: any): void
        static WriteAllLines(path: string, contents: Array<string>): void
        static WriteAllLines(path: string, contents: IEnumerable<string>): void
        static AppendAllText(path: string, contents: string, encoding: any): void
        static AppendAllText(path: string, contents: string): void
        static AppendAllLines(path: string, contents: IEnumerable<string>, encoding: any): void
        static AppendAllLines(path: string, contents: IEnumerable<string>): void
        static Replace(sourceFileName: string, destinationFileName: string, destinationBackupFileName: string): void
        static Move(sourceFileName: string, destFileName: string): void
        static Encrypt(path: string): void
        static Decrypt(path: string): void
        static ReadAllTextAsync(path: string, encoding: any, cancellationToken: any): any
        static ReadAllTextAsync(path: string, cancellationToken: any): any
        static WriteAllTextAsync(path: string, contents: string, cancellationToken: any): any
        static ReadAllBytesAsync(path: string, cancellationToken: any): any
        static WriteAllBytesAsync(path: string, bytes: Array<jsb.byte>, cancellationToken: any): any
        static ReadAllLinesAsync(path: string, encoding: any, cancellationToken: any): any
        static ReadAllLinesAsync(path: string, cancellationToken: any): any
        static WriteAllLinesAsync(path: string, contents: IEnumerable<string>, cancellationToken: any): any
        static AppendAllTextAsync(path: string, contents: string, cancellationToken: any): any
        static AppendAllLinesAsync(path: string, contents: IEnumerable<string>, cancellationToken: any): any
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TWrapper_Int32 extends Object {
        constructor(obj: number)
        GetValue(): number
        SetValue(obj: number): void
        static GetIntWrapper(): TWrapper<number>
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TWrapper<T> extends Object {
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector3 } from "UnityEngine";
    class TWrapper_Vector3 extends Object {
        constructor(obj: Vector3)
        GetValue(): Vector3
        SetValue(obj: Vector3): void
        static GetIntWrapper(): TWrapper<number>
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { TWrapper } from "global";
    namespace TSCodeGenTest {
        class InnerClass_Int32 extends Object {
            constructor()
            static GetIntWrapper(): TWrapper<number>
        }
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace TSCodeGenTest {
        class InnerClass<T> extends Object {
        }
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TSCodeGenTest2_Int32 extends Object {
        constructor()
        GetValue(): number
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TSCodeGenTest2<T> extends Object {
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TSCodeGenTest2_Dummy extends Object {
        constructor()
        GetValue(): Dummy
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class TSCodeGenTest2_DummyInner extends Object {
        constructor()
        GetValue(): Dummy.DummyInner
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class Dummy extends Object {
        constructor()
    }
}
declare module "AnotherNamespace1" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace Dummy {
        class DummyInner extends Object {
            constructor()
        }
    }
}
declare module "AnotherNamespace2" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { TSCodeGenTest as TSCodeGenTest1, TSCodeGenTest2, Dummy } from "AnotherNamespace1";
    class TSCodeGenTest extends Object {
        constructor()
        static GetInnerClass(): TSCodeGenTest1.InnerClass<number>
        static GetTSCodeGenTest2(): TSCodeGenTest2<number>
        static GetTSCodeGenTest2Dummy(): TSCodeGenTest2<Dummy>
        static GetTSCodeGenTest2DummyInner(): TSCodeGenTest2<Dummy.DummyInner>
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class DisposableObject extends Object {
        constructor()
        Dispose(): void
        static CreateDisposableObject(): DisposableObject
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Specifies Layers to use in a Physics.Raycast.
     */
    class LayerMask extends ValueType {
        constructor()
        static op_Implicit(mask: LayerMask): number
        static op_Implicit(intVal: number): LayerMask
        /** Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the.
         */
        static LayerToName(layer: number): string
        /** Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the.
         */
        static NameToLayer(layerName: string): number
        /** Given a set of layer names as defined by either a Builtin or a User Layer in the, returns the equivalent layer mask for all of them.
         * @param layerNames List of layer names to convert to a layer mask.
         * @returns The layer mask created from the layerNames. 
         */
        static GetMask(...layerNames: string[]): number
        /** Converts a layer mask value to an integer value.
         */
        value: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of RGBA colors.
     */
    class Color extends ValueType {
        constructor(r: number, g: number, b: number, a: number)
        constructor(r: number, g: number, b: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Returns a formatted string of this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string of this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Color): boolean
        Compare(b: Color): boolean
        CompareRGB(b: Color): boolean
        MinAlpha(c2: Color): Color
        static op_Addition(a: Color, b: Color): Color
        static op_Subtraction(a: Color, b: Color): Color
        static op_Multiply(a: Color, b: Color): Color
        static op_Multiply(a: Color, b: number): Color
        static op_Multiply(b: number, a: Color): Color
        static op_Division(a: Color, b: number): Color
        static op_Equality(lhs: Color, rhs: Color): boolean
        static op_Inequality(lhs: Color, rhs: Color): boolean
        /** Linearly interpolates between colors a and b by t.
         * @param a Color a.
         * @param b Color b.
         * @param t Float for combining a and b.
         */
        static Lerp(a: Color, b: Color, t: number): Color
        /** Linearly interpolates between colors a and b by t.
         */
        static LerpUnclamped(a: Color, b: Color, t: number): Color
        static op_Implicit(c: Color): Vector4
        static op_Implicit(v: Vector4): Color
        /** Calculates the hue, saturation and value of an RGB input color.
         * @param rgbColor An input color.
         * @param H Output variable for hue.
         * @param S Output variable for saturation.
         * @param V Output variable for value.
         */
        static RGBToHSV(rgbColor: Color, H: jsb.Out<number>, S: jsb.Out<number>, V: jsb.Out<number>): void
        /** Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input. 
         */
        static HSVToRGB(H: number, S: number, V: number, hdr: boolean): Color
        /** Creates an RGB colour from HSV input.
         * @param H Hue [0..1].
         * @param S Saturation [0..1].
         * @param V Brightness value [0..1].
         * @param hdr Output HDR colours. If true, the returned colour will not be clamped to [0..1].
         * @returns An opaque colour with HSV matching the input. 
         */
        static HSVToRGB(H: number, S: number, V: number): Color
        // js_op_overloading: static +(a: Color, b: Color): Color
        // js_op_overloading: static -(a: Color, b: Color): Color
        // js_op_overloading: static *(a: Color, b: Color): Color
        // js_op_overloading: static *(a: Color, b: number): Color
        // js_op_overloading: static *(b: number, a: Color): Color
        // js_op_overloading: static /(a: Color, b: number): Color
        // js_op_overloading: static ==(lhs: Color, rhs: Color): boolean
        /** Solid red. RGBA is (1, 0, 0, 1).
         */
        static readonly red: Color
        /** Solid green. RGBA is (0, 1, 0, 1).
         */
        static readonly green: Color
        /** Solid blue. RGBA is (0, 0, 1, 1).
         */
        static readonly blue: Color
        /** Solid white. RGBA is (1, 1, 1, 1).
         */
        static readonly white: Color
        /** Solid black. RGBA is (0, 0, 0, 1).
         */
        static readonly black: Color
        /** Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!
         */
        static readonly yellow: Color
        /** Cyan. RGBA is (0, 1, 1, 1).
         */
        static readonly cyan: Color
        /** Magenta. RGBA is (1, 0, 1, 1).
         */
        static readonly magenta: Color
        /** Gray. RGBA is (0.5, 0.5, 0.5, 1).
         */
        static readonly gray: Color
        /** English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1).
         */
        static readonly grey: Color
        /** Completely transparent. RGBA is (0, 0, 0, 0).
         */
        static readonly clear: Color
        /** The grayscale value of the color. (Read Only)
         */
        readonly grayscale: number
        /** A linear value of an sRGB color.
         */
        readonly linear: Color
        /** A version of the color that has had the gamma curve applied.
         */
        readonly gamma: Color
        /** Returns the maximum color component value: Max(r,g,b).
         */
        readonly maxColorComponent: number
        /** Red component of the color.
         */
        r: number
        /** Green component of the color.
         */
        g: number
        /** Blue component of the color.
         */
        b: number
        /** Alpha component of the color (0 is transparent, 1 is opaque).
         */
        a: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Representation of RGBA colors in 32 bit format.
     */
    class Color32 extends ValueType {
        constructor(r: jsb.byte, g: jsb.byte, b: jsb.byte, a: jsb.byte)
        $GetValue(index: number): jsb.byte
        $SetValue(index: number, value: jsb.byte): void
        /** Returns a formatted string for this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this color.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        Compare(b: Color32): boolean
        CompareRGB(b: Color32): boolean
        Multiply(c2: Color32): Color32
        Tint(c2: Color32): Color32
        Tint(tint: number): Color32
        static op_Implicit(c: Color): Color32
        static op_Implicit(c: Color32): Color
        /** Linearly interpolates between colors a and b by t.
         */
        static Lerp(a: Color32, b: Color32, t: number): Color32
        /** Linearly interpolates between colors a and b by t.
         */
        static LerpUnclamped(a: Color32, b: Color32, t: number): Color32
        /** Red component of the color.
         */
        r: jsb.byte
        /** Green component of the color.
         */
        g: jsb.byte
        /** Blue component of the color.
         */
        b: jsb.byte
        /** Alpha component of the color.
         */
        a: jsb.byte
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 2D vectors and points.
     */
    class Vector2 extends ValueType {
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x and y components of an existing Vector2.
         */
        Set(newX: number, newY: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector2): void
        Normalize(): void
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector2): boolean
        SqrMagnitude(): number
        /** Linearly interpolates between vectors a and b by t.
         */
        static Lerp(a: Vector2, b: Vector2, t: number): Vector2
        /** Linearly interpolates between vectors a and b by t.
         */
        static LerpUnclamped(a: Vector2, b: Vector2, t: number): Vector2
        /** Moves a point current towards target.
         */
        static MoveTowards(current: Vector2, target: Vector2, maxDistanceDelta: number): Vector2
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector2, b: Vector2): Vector2
        /** Reflects a vector off the vector defined by a normal.
         */
        static Reflect(inDirection: Vector2, inNormal: Vector2): Vector2
        /** Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up.
         * @param inDirection The input direction.
         * @returns The perpendicular direction. 
         */
        static Perpendicular(inDirection: Vector2): Vector2
        /** Dot Product of two vectors.
         */
        static Dot(lhs: Vector2, rhs: Vector2): number
        /** Gets the unsigned angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @returns The unsigned angle in degrees between the two vectors. 
         */
        static Angle(from: Vector2, to: Vector2): number
        /** Gets the signed angle in degrees between from and to.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @returns The signed angle in degrees between the two vectors. 
         */
        static SignedAngle(from: Vector2, to: Vector2): number
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector2, b: Vector2): number
        /** Returns a copy of vector with its magnitude clamped to maxLength.
         */
        static ClampMagnitude(vector: Vector2, maxLength: number): Vector2
        static SqrMagnitude(a: Vector2): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector2, rhs: Vector2): Vector2
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector2, rhs: Vector2): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number, maxSpeed: number, deltaTime: number): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number, maxSpeed: number): Vector2
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector2, target: Vector2, currentVelocity: jsb.Ref<Vector2>, smoothTime: number): Vector2
        static op_Addition(a: Vector2, b: Vector2): Vector2
        static op_Subtraction(a: Vector2, b: Vector2): Vector2
        static op_Multiply(a: Vector2, b: Vector2): Vector2
        static op_Multiply(a: Vector2, d: number): Vector2
        static op_Multiply(d: number, a: Vector2): Vector2
        static op_Division(a: Vector2, b: Vector2): Vector2
        static op_Division(a: Vector2, d: number): Vector2
        static op_UnaryNegation(a: Vector2): Vector2
        static op_Equality(lhs: Vector2, rhs: Vector2): boolean
        static op_Inequality(lhs: Vector2, rhs: Vector2): boolean
        static op_Implicit(v: Vector3): Vector2
        static op_Implicit(v: Vector2): Vector3
        // js_op_overloading: static +(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static -(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static *(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static /(a: Vector2, b: Vector2): Vector2
        // js_op_overloading: static neg(a: Vector2): Vector2
        // js_op_overloading: static *(a: Vector2, d: number): Vector2
        // js_op_overloading: static *(d: number, a: Vector2): Vector2
        // js_op_overloading: static /(a: Vector2, d: number): Vector2
        // js_op_overloading: static ==(lhs: Vector2, rhs: Vector2): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector2
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector2(0, 0).
         */
        static readonly zero: Vector2
        /** Shorthand for writing Vector2(1, 1).
         */
        static readonly one: Vector2
        /** Shorthand for writing Vector2(0, 1).
         */
        static readonly up: Vector2
        /** Shorthand for writing Vector2(0, -1).
         */
        static readonly down: Vector2
        /** Shorthand for writing Vector2(-1, 0).
         */
        static readonly left: Vector2
        /** Shorthand for writing Vector2(1, 0).
         */
        static readonly right: Vector2
        /** Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector2
        /** Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector2
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        static readonly kEpsilon: number
        static readonly kEpsilonNormalSqrt: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 2D vectors and points using integers.
     */
    class Vector2Int extends ValueType {
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x and y components of an existing Vector2Int.
         */
        Set(x: number, y: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector2Int): void
        /** Clamps the Vector2Int to the bounds given by min and max.
         */
        Clamp(min: Vector2Int, max: Vector2Int): void
        /** Returns true if the objects are equal.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector2Int): boolean
        GetHashCode(): number
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector2Int, b: Vector2Int): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector2Int, rhs: Vector2Int): Vector2Int
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector2Int, rhs: Vector2Int): Vector2Int
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector2Int, b: Vector2Int): Vector2Int
        static op_Implicit(v: Vector2Int): Vector2
        static op_Explicit(v: Vector2Int): Vector3Int
        /** Converts a Vector2 to a Vector2Int by doing a Floor to each value.
         */
        static FloorToInt(v: Vector2): Vector2Int
        /** Converts a  Vector2 to a Vector2Int by doing a Ceiling to each value.
         */
        static CeilToInt(v: Vector2): Vector2Int
        /** Converts a  Vector2 to a Vector2Int by doing a Round to each value.
         */
        static RoundToInt(v: Vector2): Vector2Int
        static op_UnaryNegation(v: Vector2Int): Vector2Int
        static op_Addition(a: Vector2Int, b: Vector2Int): Vector2Int
        static op_Subtraction(a: Vector2Int, b: Vector2Int): Vector2Int
        static op_Multiply(a: Vector2Int, b: Vector2Int): Vector2Int
        static op_Multiply(a: number, b: Vector2Int): Vector2Int
        static op_Multiply(a: Vector2Int, b: number): Vector2Int
        static op_Division(a: Vector2Int, b: number): Vector2Int
        static op_Equality(lhs: Vector2Int, rhs: Vector2Int): boolean
        static op_Inequality(lhs: Vector2Int, rhs: Vector2Int): boolean
        // js_op_overloading: static neg(v: Vector2Int): Vector2Int
        // js_op_overloading: static +(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static -(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: Vector2Int, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: number, b: Vector2Int): Vector2Int
        // js_op_overloading: static *(a: Vector2Int, b: number): Vector2Int
        // js_op_overloading: static /(a: Vector2Int, b: number): Vector2Int
        // js_op_overloading: static ==(lhs: Vector2Int, rhs: Vector2Int): boolean
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector2Int(0, 0).
         */
        static readonly zero: Vector2Int
        /** Shorthand for writing Vector2Int(1, 1).
         */
        static readonly one: Vector2Int
        /** Shorthand for writing Vector2Int(0, 1).
         */
        static readonly up: Vector2Int
        /** Shorthand for writing Vector2Int(0, -1).
         */
        static readonly down: Vector2Int
        /** Shorthand for writing Vector2Int(-1, 0).
         */
        static readonly left: Vector2Int
        /** Shorthand for writing Vector2Int(1, 0).
         */
        static readonly right: Vector2Int
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 3D vectors and points.
     */
    class Vector3 extends ValueType {
        constructor(x: number, y: number, z: number)
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y and z components of an existing Vector3.
         */
        Set(newX: number, newY: number, newZ: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector3): void
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector3): boolean
        Normalize(): void
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        Compare(v2: Vector3, accuracy: number): boolean
        /** Linearly interpolates between two points.
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Value used to interpolate between a and b.
         * @returns Interpolated value, equals to a + (b - a) * t. 
         */
        static Lerp(a: Vector3, b: Vector3, t: number): Vector3
        /** Linearly interpolates between two vectors.
         */
        static LerpUnclamped(a: Vector3, b: Vector3, t: number): Vector3
        /** Calculate a position between the points specified by current and target, moving no farther than the distance specified by maxDistanceDelta.
         * @param current The position to move from.
         * @param target The position to move towards.
         * @param maxDistanceDelta Distance to move current per call.
         * @returns The new position. 
         */
        static MoveTowards(current: Vector3, target: Vector3, maxDistanceDelta: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number, maxSpeed: number, deltaTime: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number, maxSpeed: number): Vector3
        /** Gradually changes a vector towards a desired goal over time.
         * @param current The current position.
         * @param target The position we are trying to reach.
         * @param currentVelocity The current velocity, this value is modified by the function every time you call it.
         * @param smoothTime Approximately the time it will take to reach the target. A smaller value will reach the target faster.
         * @param maxSpeed Optionally allows you to clamp the maximum speed.
         * @param deltaTime The time since the last call to this function. By default Time.deltaTime.
         */
        static SmoothDamp(current: Vector3, target: Vector3, currentVelocity: jsb.Ref<Vector3>, smoothTime: number): Vector3
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector3, b: Vector3): Vector3
        /** Cross Product of two vectors.
         */
        static Cross(lhs: Vector3, rhs: Vector3): Vector3
        /** Reflects a vector off the plane defined by a normal.
         */
        static Reflect(inDirection: Vector3, inNormal: Vector3): Vector3
        /** Makes this vector have a magnitude of 1.
         */
        static Normalize(value: Vector3): Vector3
        /** Dot Product of two vectors.
         */
        static Dot(lhs: Vector3, rhs: Vector3): number
        /** Projects a vector onto another vector.
         */
        static Project(vector: Vector3, onNormal: Vector3): Vector3
        /** Projects a vector onto a plane defined by a normal orthogonal to the plane.
         * @param planeNormal The direction from the vector towards the plane.
         * @param vector The location of the vector above the plane.
         * @returns The location of the vector on the plane. 
         */
        static ProjectOnPlane(vector: Vector3, planeNormal: Vector3): Vector3
        /** Calculates the angle between vectors from and.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @returns The angle in degrees between the two vectors. 
         */
        static Angle(from: Vector3, to: Vector3): number
        /** Calculates the signed angle between vectors from and to in relation to axis.
         * @param from The vector from which the angular difference is measured.
         * @param to The vector to which the angular difference is measured.
         * @param axis A vector around which the other vectors are rotated.
         * @returns Returns the signed angle between from and to in degrees. 
         */
        static SignedAngle(from: Vector3, to: Vector3, axis: Vector3): number
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector3, b: Vector3): number
        /** Returns a copy of vector with its magnitude clamped to maxLength.
         */
        static ClampMagnitude(vector: Vector3, maxLength: number): Vector3
        static Magnitude(vector: Vector3): number
        static SqrMagnitude(vector: Vector3): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector3, rhs: Vector3): Vector3
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector3, rhs: Vector3): Vector3
        static op_Addition(a: Vector3, b: Vector3): Vector3
        static op_Subtraction(a: Vector3, b: Vector3): Vector3
        static op_UnaryNegation(a: Vector3): Vector3
        static op_Multiply(a: Vector3, d: number): Vector3
        static op_Multiply(d: number, a: Vector3): Vector3
        static op_Division(a: Vector3, d: number): Vector3
        static op_Equality(lhs: Vector3, rhs: Vector3): boolean
        static op_Inequality(lhs: Vector3, rhs: Vector3): boolean
        /** Spherically interpolates between two vectors.
         */
        static Slerp(a: Vector3, b: Vector3, t: number): Vector3
        /** Spherically interpolates between two vectors.
         */
        static SlerpUnclamped(a: Vector3, b: Vector3, t: number): Vector3
        /** Makes vectors normalized and orthogonal to each other.
         */
        static OrthoNormalize(normal: jsb.Ref<Vector3>, tangent: jsb.Ref<Vector3>, binormal: jsb.Ref<Vector3>): void
        /** Makes vectors normalized and orthogonal to each other.
         */
        static OrthoNormalize(normal: jsb.Ref<Vector3>, tangent: jsb.Ref<Vector3>): void
        /** Rotates a vector current towards target.
         * @param current The vector being managed.
         * @param target The vector.
         * @param maxRadiansDelta The maximum angle in radians allowed for this rotation.
         * @param maxMagnitudeDelta The maximum allowed change in vector magnitude for this rotation.
         * @returns The location that RotateTowards generates. 
         */
        static RotateTowards(current: Vector3, target: Vector3, maxRadiansDelta: number, maxMagnitudeDelta: number): Vector3
        // js_op_overloading: static +(a: Vector3, b: Vector3): Vector3
        // js_op_overloading: static -(a: Vector3, b: Vector3): Vector3
        // js_op_overloading: static neg(a: Vector3): Vector3
        // js_op_overloading: static *(a: Vector3, d: number): Vector3
        // js_op_overloading: static *(d: number, a: Vector3): Vector3
        // js_op_overloading: static /(a: Vector3, d: number): Vector3
        // js_op_overloading: static ==(lhs: Vector3, rhs: Vector3): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector3
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector3(0, 0, 0).
         */
        static readonly zero: Vector3
        /** Shorthand for writing Vector3(1, 1, 1).
         */
        static readonly one: Vector3
        /** Shorthand for writing Vector3(0, 0, 1).
         */
        static readonly forward: Vector3
        /** Shorthand for writing Vector3(0, 0, -1).
         */
        static readonly back: Vector3
        /** Shorthand for writing Vector3(0, 1, 0).
         */
        static readonly up: Vector3
        /** Shorthand for writing Vector3(0, -1, 0).
         */
        static readonly down: Vector3
        /** Shorthand for writing Vector3(-1, 0, 0).
         */
        static readonly left: Vector3
        /** Shorthand for writing Vector3(1, 0, 0).
         */
        static readonly right: Vector3
        /** Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector3
        /** Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector3
        static readonly kEpsilon: number
        static readonly kEpsilonNormalSqrt: number
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of 3D vectors and points using integers.
     */
    class Vector3Int extends ValueType {
        constructor(x: number, y: number, z: number)
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y and z components of an existing Vector3Int.
         */
        Set(x: number, y: number, z: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector3Int): void
        /** Clamps the Vector3Int to the bounds given by min and max.
         */
        Clamp(min: Vector3Int, max: Vector3Int): void
        /** Returns true if the objects are equal.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector3Int): boolean
        GetHashCode(): number
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector3Int, b: Vector3Int): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector3Int, rhs: Vector3Int): Vector3Int
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector3Int, rhs: Vector3Int): Vector3Int
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector3Int, b: Vector3Int): Vector3Int
        static op_Implicit(v: Vector3Int): Vector3
        static op_Explicit(v: Vector3Int): Vector2Int
        /** Converts a  Vector3 to a Vector3Int by doing a Floor to each value.
         */
        static FloorToInt(v: Vector3): Vector3Int
        /** Converts a  Vector3 to a Vector3Int by doing a Ceiling to each value.
         */
        static CeilToInt(v: Vector3): Vector3Int
        /** Converts a  Vector3 to a Vector3Int by doing a Round to each value.
         */
        static RoundToInt(v: Vector3): Vector3Int
        static op_Addition(a: Vector3Int, b: Vector3Int): Vector3Int
        static op_Subtraction(a: Vector3Int, b: Vector3Int): Vector3Int
        static op_Multiply(a: Vector3Int, b: Vector3Int): Vector3Int
        static op_Multiply(a: Vector3Int, b: number): Vector3Int
        static op_Multiply(a: number, b: Vector3Int): Vector3Int
        static op_UnaryNegation(a: Vector3Int): Vector3Int
        static op_Division(a: Vector3Int, b: number): Vector3Int
        static op_Equality(lhs: Vector3Int, rhs: Vector3Int): boolean
        static op_Inequality(lhs: Vector3Int, rhs: Vector3Int): boolean
        // js_op_overloading: static +(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static -(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static *(a: Vector3Int, b: Vector3Int): Vector3Int
        // js_op_overloading: static neg(a: Vector3Int): Vector3Int
        // js_op_overloading: static *(a: Vector3Int, b: number): Vector3Int
        // js_op_overloading: static *(a: number, b: Vector3Int): Vector3Int
        // js_op_overloading: static /(a: Vector3Int, b: number): Vector3Int
        // js_op_overloading: static ==(lhs: Vector3Int, rhs: Vector3Int): boolean
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector3Int(0, 0, 0).
         */
        static readonly zero: Vector3Int
        /** Shorthand for writing Vector3Int(1, 1, 1).
         */
        static readonly one: Vector3Int
        /** Shorthand for writing Vector3Int(0, 1, 0).
         */
        static readonly up: Vector3Int
        /** Shorthand for writing Vector3Int(0, -1, 0).
         */
        static readonly down: Vector3Int
        /** Shorthand for writing Vector3Int(-1, 0, 0).
         */
        static readonly left: Vector3Int
        /** Shorthand for writing Vector3Int(1, 0, 0).
         */
        static readonly right: Vector3Int
        /** Shorthand for writing Vector3Int(0, 0, 1).
         */
        static readonly forward: Vector3Int
        /** Shorthand for writing Vector3Int(0, 0, -1).
         */
        static readonly back: Vector3Int
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Representation of four-dimensional vectors.
     */
    class Vector4 extends ValueType {
        constructor(x: number, y: number, z: number, w: number)
        constructor(x: number, y: number, z: number)
        constructor(x: number, y: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y, z and w components of an existing Vector4.
         */
        Set(newX: number, newY: number, newZ: number, newW: number): void
        /** Multiplies every component of this vector by the same component of scale.
         */
        Scale(scale: Vector4): void
        GetHashCode(): number
        /** Returns true if the given vector is exactly equal to this vector.
         */
        Equals(other: Object1): boolean
        Equals(other: Vector4): boolean
        Normalize(): void
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this vector.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        SqrMagnitude(): number
        /** Linearly interpolates between two vectors.
         */
        static Lerp(a: Vector4, b: Vector4, t: number): Vector4
        /** Linearly interpolates between two vectors.
         */
        static LerpUnclamped(a: Vector4, b: Vector4, t: number): Vector4
        /** Moves a point current towards target.
         */
        static MoveTowards(current: Vector4, target: Vector4, maxDistanceDelta: number): Vector4
        /** Multiplies two vectors component-wise.
         */
        static Scale(a: Vector4, b: Vector4): Vector4
        static Normalize(a: Vector4): Vector4
        /** Dot Product of two vectors.
         */
        static Dot(a: Vector4, b: Vector4): number
        /** Projects a vector onto another vector.
         */
        static Project(a: Vector4, b: Vector4): Vector4
        /** Returns the distance between a and b.
         */
        static Distance(a: Vector4, b: Vector4): number
        static Magnitude(a: Vector4): number
        /** Returns a vector that is made from the smallest components of two vectors.
         */
        static Min(lhs: Vector4, rhs: Vector4): Vector4
        /** Returns a vector that is made from the largest components of two vectors.
         */
        static Max(lhs: Vector4, rhs: Vector4): Vector4
        static op_Addition(a: Vector4, b: Vector4): Vector4
        static op_Subtraction(a: Vector4, b: Vector4): Vector4
        static op_UnaryNegation(a: Vector4): Vector4
        static op_Multiply(a: Vector4, d: number): Vector4
        static op_Multiply(d: number, a: Vector4): Vector4
        static op_Division(a: Vector4, d: number): Vector4
        static op_Equality(lhs: Vector4, rhs: Vector4): boolean
        static op_Inequality(lhs: Vector4, rhs: Vector4): boolean
        static op_Implicit(v: Vector3): Vector4
        static op_Implicit(v: Vector4): Vector3
        static op_Implicit(v: Vector2): Vector4
        static SqrMagnitude(a: Vector4): number
        // js_op_overloading: static +(a: Vector4, b: Vector4): Vector4
        // js_op_overloading: static -(a: Vector4, b: Vector4): Vector4
        // js_op_overloading: static neg(a: Vector4): Vector4
        // js_op_overloading: static *(a: Vector4, d: number): Vector4
        // js_op_overloading: static *(d: number, a: Vector4): Vector4
        // js_op_overloading: static /(a: Vector4, d: number): Vector4
        // js_op_overloading: static ==(lhs: Vector4, rhs: Vector4): boolean
        /** Returns this vector with a magnitude of 1 (Read Only).
         */
        readonly normalized: Vector4
        /** Returns the length of this vector (Read Only).
         */
        readonly magnitude: number
        /** Returns the squared length of this vector (Read Only).
         */
        readonly sqrMagnitude: number
        /** Shorthand for writing Vector4(0,0,0,0).
         */
        static readonly zero: Vector4
        /** Shorthand for writing Vector4(1,1,1,1).
         */
        static readonly one: Vector4
        /** Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity).
         */
        static readonly positiveInfinity: Vector4
        /** Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity).
         */
        static readonly negativeInfinity: Vector4
        static readonly kEpsilon: number
        /** X component of the vector.
         */
        x: number
        /** Y component of the vector.
         */
        y: number
        /** Z component of the vector.
         */
        z: number
        /** W component of the vector.
         */
        w: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** A 2D Rectangle defined by X and Y position, width and height.
     */
    class Rect extends ValueType {
        constructor(x: number, y: number, width: number, height: number)
        constructor(position: Vector2, size: Vector2)
        constructor(source: Rect)
        /** Set components of an existing Rect.
         */
        Set(x: number, y: number, width: number, height: number): void
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector3, allowInverse: boolean): boolean
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector2): boolean
        /** Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param point Point to test.
         * @param allowInverse Does the test allow the Rect's width and height to be negative?
         * @returns True if the point lies within the specified rectangle. 
         */
        Contains(point: Vector3): boolean
        /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        Overlaps(other: Rect, allowInverse: boolean): boolean
        /** Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work.
         * @param other Other rectangle to test overlapping with.
         * @param allowInverse Does the test allow the widths and heights of the Rects to be negative?
         */
        Overlaps(other: Rect): boolean
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Rect): boolean
        /** Returns a formatted string for this Rect.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this Rect.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        /** Creates a rectangle from min/max coordinate values.
         * @param xmin The minimum X coordinate.
         * @param ymin The minimum Y coordinate.
         * @param xmax The maximum X coordinate.
         * @param ymax The maximum Y coordinate.
         * @returns A rectangle matching the specified coordinates. 
         */
        static MinMaxRect(xmin: number, ymin: number, xmax: number, ymax: number): Rect
        /** Returns a point inside a rectangle, given normalized coordinates.
         * @param rectangle Rectangle to get a point inside.
         * @param normalizedRectCoordinates Normalized coordinates to get a point for.
         */
        static NormalizedToPoint(rectangle: Rect, normalizedRectCoordinates: Vector2): Vector2
        /** Returns the normalized coordinates cooresponding the the point.
         * @param rectangle Rectangle to get normalized coordinates inside.
         * @param point A point inside the rectangle to get normalized coordinates for.
         */
        static PointToNormalized(rectangle: Rect, point: Vector2): Vector2
        static op_Inequality(lhs: Rect, rhs: Rect): boolean
        static op_Equality(lhs: Rect, rhs: Rect): boolean
        // js_op_overloading: static ==(lhs: Rect, rhs: Rect): boolean
        /** Shorthand for writing new Rect(0,0,0,0).
         */
        static readonly zero: Rect
        /** The X coordinate of the rectangle.
         */
        x: number
        /** The Y coordinate of the rectangle.
         */
        y: number
        /** The X and Y position of the rectangle.
         */
        position: Vector2
        /** The position of the center of the rectangle.
         */
        center: Vector2
        /** The position of the minimum corner of the rectangle.
         */
        min: Vector2
        /** The position of the maximum corner of the rectangle.
         */
        max: Vector2
        /** The width of the rectangle, measured from the X position.
         */
        width: number
        /** The height of the rectangle, measured from the Y position.
         */
        height: number
        /** The width and height of the rectangle.
         */
        size: Vector2
        /** The minimum X coordinate of the rectangle.
         */
        xMin: number
        /** The minimum Y coordinate of the rectangle.
         */
        yMin: number
        /** The maximum X coordinate of the rectangle.
         */
        xMax: number
        /** The maximum Y coordinate of the rectangle.
         */
        yMax: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Quaternions are used to represent rotations.
     */
    class Quaternion extends ValueType {
        constructor(x: number, y: number, z: number, w: number)
        $GetValue(index: number): number
        $SetValue(index: number, value: number): void
        /** Set x, y, z and w components of an existing Quaternion.
         */
        Set(newX: number, newY: number, newZ: number, newW: number): void
        /** Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        SetLookRotation(view: Vector3, up: Vector3): void
        /** Creates a rotation with the specified forward and upwards directions.
         * @param view The direction to look in.
         * @param up The vector that defines in which direction up is.
         */
        SetLookRotation(view: Vector3): void
        /** Converts a rotation to angle-axis representation (angles in degrees).
         */
        ToAngleAxis(angle: jsb.Out<number>, axis: jsb.Out<Vector3>): void
        /** Creates a rotation which rotates from fromDirection to toDirection.
         */
        SetFromToRotation(fromDirection: Vector3, toDirection: Vector3): void
        Normalize(): void
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Quaternion): boolean
        /** Returns a formatted string for this quaternion.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this quaternion.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        Compare(q2: Quaternion, accuracy: number): boolean
        static op_Multiply(lhs: Quaternion, rhs: Quaternion): Quaternion
        static op_Multiply(rotation: Quaternion, point: Vector3): Vector3
        static op_Equality(lhs: Quaternion, rhs: Quaternion): boolean
        static op_Inequality(lhs: Quaternion, rhs: Quaternion): boolean
        /** The dot product between two rotations.
         */
        static Dot(a: Quaternion, b: Quaternion): number
        /** Returns the angle in degrees between two rotations a and b.
         */
        static Angle(a: Quaternion, b: Quaternion): number
        /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis; applied in that order.
         */
        static Euler(x: number, y: number, z: number): Quaternion
        /** Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.
         */
        static Euler(euler: Vector3): Quaternion
        /** Rotates a rotation from towards to.
         */
        static RotateTowards(from: Quaternion, to: Quaternion, maxDegreesDelta: number): Quaternion
        /** Converts this quaternion to one with the same orientation but with a magnitude of 1.
         */
        static Normalize(q: Quaternion): Quaternion
        /** Creates a rotation which rotates from fromDirection to toDirection.
         */
        static FromToRotation(fromDirection: Vector3, toDirection: Vector3): Quaternion
        /** Returns the Inverse of rotation.
         */
        static Inverse(rotation: Quaternion): Quaternion
        /** Spherically interpolates between quaternions a and b by ratio t. The parameter t is clamped to the range [0, 1].
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Interpolation ratio.
         * @returns A quaternion spherically interpolated between quaternions a and b. 
         */
        static Slerp(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Spherically interpolates between a and b by t. The parameter t is not clamped.
         */
        static SlerpUnclamped(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1].
         * @param a Start value, returned when t = 0.
         * @param b End value, returned when t = 1.
         * @param t Interpolation ratio.
         * @returns A quaternion interpolated between quaternions a and b. 
         */
        static Lerp(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped.
         */
        static LerpUnclamped(a: Quaternion, b: Quaternion, t: number): Quaternion
        /** Creates a rotation which rotates angle degrees around axis.
         */
        static AngleAxis(angle: number, axis: Vector3): Quaternion
        /** Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        static LookRotation(forward: Vector3, upwards: Vector3): Quaternion
        /** Creates a rotation with the specified forward and upwards directions.
         * @param forward The direction to look in.
         * @param upwards The vector that defines in which direction up is.
         */
        static LookRotation(forward: Vector3): Quaternion
        // js_op_overloading: static *(lhs: Quaternion, rhs: Quaternion): Quaternion
        // js_op_overloading: static *(rotation: Quaternion, point: Vector3): Vector3
        // js_op_overloading: static ==(lhs: Quaternion, rhs: Quaternion): boolean
        /** The identity rotation (Read Only).
         */
        static readonly identity: Quaternion
        /** Returns or sets the euler angle representation of the rotation.
         */
        eulerAngles: Vector3
        /** Returns this quaternion with a magnitude of 1 (Read Only).
         */
        readonly normalized: Quaternion
        /** X component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        x: number
        /** Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        y: number
        /** Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out.
         */
        z: number
        /** W component of the Quaternion. Do not directly modify quaternions.
         */
        w: number
        static readonly kEpsilon: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** A standard 4x4 transformation matrix.
     */
    class Matrix4x4 extends ValueType {
        constructor(column0: Vector4, column1: Vector4, column2: Vector4, column3: Vector4)
        $GetValue(row: number, column: number): number
        $GetValue(index: number): number
        $SetValue(row: number, column: number, value: number): void
        $SetValue(index: number, value: number): void
        ValidTRS(): boolean
        /** Sets this matrix to a translation, rotation and scaling matrix.
         */
        SetTRS(pos: Vector3, q: Quaternion, s: Vector3): void
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Matrix4x4): boolean
        /** Get a column of the matrix.
         */
        GetColumn(index: number): Vector4
        /** Returns a row of the matrix.
         */
        GetRow(index: number): Vector4
        GetPosition(): Vector3
        /** Sets a column of the matrix.
         */
        SetColumn(index: number, column: Vector4): void
        /** Sets a row of the matrix.
         */
        SetRow(index: number, row: Vector4): void
        /** Transforms a position by this matrix (generic).
         */
        MultiplyPoint(point: Vector3): Vector3
        /** Transforms a position by this matrix (fast).
         */
        MultiplyPoint3x4(point: Vector3): Vector3
        /** Transforms a direction by this matrix.
         */
        MultiplyVector(vector: Vector3): Vector3
        /** Returns a plane that is transformed in space.
         */
        TransformPlane(plane: any): any
        /** Returns a formatted string for this matrix.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this matrix.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        static Determinant(m: Matrix4x4): number
        /** Creates a translation, rotation and scaling matrix.
         */
        static TRS(pos: Vector3, q: Quaternion, s: Vector3): Matrix4x4
        /** Computes the inverse of a 3D affine matrix.
         * @param input Input matrix to invert.
         * @param result The result of the inversion. Equal to the input matrix if the function fails.
         * @returns Returns true and a valid result if the function succeeds, false and a copy of the input matrix if the function fails. 
         */
        static Inverse3DAffine(input: Matrix4x4, result: jsb.Ref<Matrix4x4>): boolean
        static Inverse(m: Matrix4x4): Matrix4x4
        static Transpose(m: Matrix4x4): Matrix4x4
        /** Create an orthogonal projection matrix.
         * @param left Left-side x-coordinate.
         * @param right Right-side x-coordinate.
         * @param bottom Bottom y-coordinate.
         * @param top Top y-coordinate.
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix. 
         */
        static Ortho(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4
        /** Create a perspective projection matrix.
         * @param fov Vertical field-of-view in degrees.
         * @param aspect Aspect ratio (width divided by height).
         * @param zNear Near depth clipping plane value.
         * @param zFar Far depth clipping plane value.
         * @returns The projection matrix. 
         */
        static Perspective(fov: number, aspect: number, zNear: number, zFar: number): Matrix4x4
        /** Create a "look at" matrix.
         * @param from The source point.
         * @param to The target point.
         * @param up The vector describing the up direction (typically Vector3.up).
         * @returns The resulting transformation matrix. 
         */
        static LookAt(from: Vector3, to: Vector3, up: Vector3): Matrix4x4
        /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
         */
        static Frustum(left: number, right: number, bottom: number, top: number, zNear: number, zFar: number): Matrix4x4
        /** This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in.
         * @param left The X coordinate of the left side of the near projection plane in view space.
         * @param right The X coordinate of the right side of the near projection plane in view space.
         * @param bottom The Y coordinate of the bottom side of the near projection plane in view space.
         * @param top The Y coordinate of the top side of the near projection plane in view space.
         * @param zNear Z distance to the near plane from the origin in view space.
         * @param zFar Z distance to the far plane from the origin in view space.
         * @param frustumPlanes Frustum planes struct that contains the view space coordinates of that define a viewing frustum.
         * @returns A projection matrix with a viewing frustum defined by the plane coordinates passed in. 
         */
        static Frustum(fp: any): Matrix4x4
        static op_Multiply(lhs: Matrix4x4, rhs: Matrix4x4): Matrix4x4
        static op_Multiply(lhs: Matrix4x4, vector: Vector4): Vector4
        static op_Equality(lhs: Matrix4x4, rhs: Matrix4x4): boolean
        static op_Inequality(lhs: Matrix4x4, rhs: Matrix4x4): boolean
        /** Creates a scaling matrix.
         */
        static Scale(vector: Vector3): Matrix4x4
        /** Creates a translation matrix.
         */
        static Translate(vector: Vector3): Matrix4x4
        /** Creates a rotation matrix.
         */
        static Rotate(q: Quaternion): Matrix4x4
        // js_op_overloading: static *(lhs: Matrix4x4, rhs: Matrix4x4): Matrix4x4
        // js_op_overloading: static *(lhs: Matrix4x4, vector: Vector4): Vector4
        // js_op_overloading: static ==(lhs: Matrix4x4, rhs: Matrix4x4): boolean
        /** Attempts to get a rotation quaternion from this matrix.
         */
        readonly rotation: Quaternion
        /** Attempts to get a scale value from the matrix. (Read Only)
         */
        readonly lossyScale: Vector3
        /** Checks whether this is an identity matrix. (Read Only)
         */
        readonly isIdentity: boolean
        /** The determinant of the matrix. (Read Only)
         */
        readonly determinant: number
        /** This property takes a projection matrix and returns the six plane coordinates that define a projection frustum.
         */
        readonly decomposeProjection: any
        /** The inverse of this matrix. (Read Only)
         */
        readonly inverse: Matrix4x4
        /** Returns the transpose of this matrix (Read Only).
         */
        readonly transpose: Matrix4x4
        /** Returns a matrix with all elements set to zero (Read Only).
         */
        static readonly zero: Matrix4x4
        /** Returns the identity matrix (Read Only).
         */
        static readonly identity: Matrix4x4
        m00: number
        m10: number
        m20: number
        m30: number
        m01: number
        m11: number
        m21: number
        m31: number
        m02: number
        m12: number
        m22: number
        m32: number
        m03: number
        m13: number
        m23: number
        m33: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** The various primitives that can be created using the GameObject.CreatePrimitive function.
     */
    enum PrimitiveType {
        /** A sphere primitive.
         */
        Sphere = 0,
        /** A capsule primitive.
         */
        Capsule = 1,
        /** A cylinder primitive.
         */
        Cylinder = 2,
        /** A cube primitive.
         */
        Cube = 3,
        /** A plane primitive.
         */
        Plane = 4,
        /** A quad primitive.
         */
        Quad = 5,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array } from "System";
    /** Base class for all objects Unity can reference.
     */
    class Object extends Object1 {
        constructor()
        GetInstanceID(): number
        GetHashCode(): number
        Equals(other: Object1): boolean
        toString(): string
        static op_Implicit(exists: Object): boolean
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, position: Vector3, rotation: Quaternion, parent: Transform): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, position: Vector3, rotation: Quaternion): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, parent: Transform, instantiateInWorldSpace: boolean): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object, parent: Transform): Object
        /** Clones the object original and returns the clone.
         * @param original An existing object that you want to make a copy of.
         * @param position Position for the new object.
         * @param rotation Orientation of the new object.
         * @param parent Parent that will be assigned to the new object.
         * @param instantiateInWorldSpace When you assign a parent Object, pass true to position the new object directly in world space. Pass false to set the Object’s position relative to its new parent.
         * @returns The instantiated clone. 
         */
        static Instantiate(original: Object): Object
        /** Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        static Destroy(obj: Object, t: number): void
        /** Removes a GameObject, component or asset.
         * @param obj The object to destroy.
         * @param t The optional amount of time to delay before destroying the object.
         */
        static Destroy(obj: Object): void
        /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        static DestroyImmediate(obj: Object, allowDestroyingAssets: boolean): void
        /** Destroys the object obj immediately. You are strongly recommended to use Destroy instead.
         * @param obj Object to be destroyed.
         * @param allowDestroyingAssets Set to true to allow assets to be destroyed.
         */
        static DestroyImmediate(obj: Object): void
        /** Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified. 
         */
        static FindObjectsOfType(type: any, includeInactive: boolean): Array<Object>
        /** Gets a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param includeInactive If true, components attached to inactive GameObjects are also included.
         * @returns The array of objects found matching the type specified. 
         */
        static FindObjectsOfType(type: any): Array<Object>
        /** Retrieves a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
         * @returns The array of objects found matching the type specified. 
         */
        static FindObjectsByType(type: any, findObjectsInactive: any, sortMode: any): Array<Object>
        /** Retrieves a list of all loaded objects of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @param sortMode Whether and how to sort the returned array. Not sorting the array makes this function run significantly faster.
         * @returns The array of objects found matching the type specified. 
         */
        static FindObjectsByType(type: any, sortMode: any): Array<Object>
        /** Do not destroy the target Object when loading a new Scene.
         * @param target An Object not destroyed on Scene change.
         */
        static DontDestroyOnLoad(target: Object): void
        /** Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type. 
         */
        static FindObjectOfType(type: any, includeInactive: boolean): Object
        /** Returns the first active loaded object of Type type.
         * @param type The type of object to find.
         * @returns Object The first active loaded object that matches the specified type. It returns null if no Object matches the type. 
         */
        static FindObjectOfType(type: any): Object
        /** Retrieves the first active loaded object of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
         */
        static FindFirstObjectByType(type: any, findObjectsInactive: any): Object
        /** Retrieves the first active loaded object of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @returns Returns the first active loaded object that matches the specified type. If no object matches the specified type, returns null. 
         */
        static FindFirstObjectByType(type: any): Object
        /** Retrieves any active loaded object of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
         */
        static FindAnyObjectByType(type: any, findObjectsInactive: any): Object
        /** Retrieves any active loaded object of Type type.
         * @param type The type of object to find.
         * @param findObjectsInactive Whether to include components attached to inactive GameObjects. If you don't specify this parameter, this function doesn't include inactive objects in the results.
         * @returns Returns an arbitrary active loaded object that matches the specified type. If no object matches the specified type, returns null. 
         */
        static FindAnyObjectByType(type: any): Object
        static op_Equality(x: Object, y: Object): boolean
        static op_Inequality(x: Object, y: Object): boolean
        /** The name of the object.
         */
        name: string
        /** Should the object be hidden, saved with the Scene or modifiable by the user?
         */
        hideFlags: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Key codes returned by Event.keyCode. These map directly to a physical key on the keyboard.
     */
    enum KeyCode {
        /** Not assigned (never returned as the result of a keystroke).
         */
        None = 0,
        /** The backspace key.
         */
        Backspace = 8,
        /** The tab key.
         */
        Tab = 9,
        /** The Clear key.
         */
        Clear = 12,
        /** Return key.
         */
        Return = 13,
        /** Pause on PC machines.
         */
        Pause = 19,
        /** Escape key.
         */
        Escape = 27,
        /** Space key.
         */
        Space = 32,
        /** Exclamation mark key '!'.
         */
        Exclaim = 33,
        /** Double quote key '"'.
         */
        DoubleQuote = 34,
        /** Hash key '#'.
         */
        Hash = 35,
        /** Dollar sign key '$'.
         */
        Dollar = 36,
        /** Percent '%' key.
         */
        Percent = 37,
        /** Ampersand key '&'.
         */
        Ampersand = 38,
        /** Quote key '.
         */
        Quote = 39,
        /** Left Parenthesis key '('.
         */
        LeftParen = 40,
        /** Right Parenthesis key ')'.
         */
        RightParen = 41,
        /** Asterisk key '*'.
         */
        Asterisk = 42,
        /** Plus key '+'.
         */
        Plus = 43,
        /** Comma ',' key.
         */
        Comma = 44,
        /** Minus '-' key.
         */
        Minus = 45,
        /** Period '.' key.
         */
        Period = 46,
        /** Slash '/' key.
         */
        Slash = 47,
        /** The '0' key on the top of the alphanumeric keyboard.
         */
        Alpha0 = 48,
        /** The '1' key on the top of the alphanumeric keyboard.
         */
        Alpha1 = 49,
        /** The '2' key on the top of the alphanumeric keyboard.
         */
        Alpha2 = 50,
        /** The '3' key on the top of the alphanumeric keyboard.
         */
        Alpha3 = 51,
        /** The '4' key on the top of the alphanumeric keyboard.
         */
        Alpha4 = 52,
        /** The '5' key on the top of the alphanumeric keyboard.
         */
        Alpha5 = 53,
        /** The '6' key on the top of the alphanumeric keyboard.
         */
        Alpha6 = 54,
        /** The '7' key on the top of the alphanumeric keyboard.
         */
        Alpha7 = 55,
        /** The '8' key on the top of the alphanumeric keyboard.
         */
        Alpha8 = 56,
        /** The '9' key on the top of the alphanumeric keyboard.
         */
        Alpha9 = 57,
        /** Colon ':' key.
         */
        Colon = 58,
        /** Semicolon ';' key.
         */
        Semicolon = 59,
        /** Less than '<' key.
         */
        Less = 60,
        /** Equals '=' key.
         */
        Equals = 61,
        /** Greater than '>' key.
         */
        Greater = 62,
        /** Question mark '?' key.
         */
        Question = 63,
        /** At key '@'.
         */
        At = 64,
        /** Left square bracket key '['.
         */
        LeftBracket = 91,
        /** Backslash key '\'.
         */
        Backslash = 92,
        /** Right square bracket key ']'.
         */
        RightBracket = 93,
        /** Caret key '^'.
         */
        Caret = 94,
        /** Underscore '_' key.
         */
        Underscore = 95,
        /** Back quote key '`'.
         */
        BackQuote = 96,
        /** 'a' key.
         */
        A = 97,
        /** 'b' key.
         */
        B = 98,
        /** 'c' key.
         */
        C = 99,
        /** 'd' key.
         */
        D = 100,
        /** 'e' key.
         */
        E = 101,
        /** 'f' key.
         */
        F = 102,
        /** 'g' key.
         */
        G = 103,
        /** 'h' key.
         */
        H = 104,
        /** 'i' key.
         */
        I = 105,
        /** 'j' key.
         */
        J = 106,
        /** 'k' key.
         */
        K = 107,
        /** 'l' key.
         */
        L = 108,
        /** 'm' key.
         */
        M = 109,
        /** 'n' key.
         */
        N = 110,
        /** 'o' key.
         */
        O = 111,
        /** 'p' key.
         */
        P = 112,
        /** 'q' key.
         */
        Q = 113,
        /** 'r' key.
         */
        R = 114,
        /** 's' key.
         */
        S = 115,
        /** 't' key.
         */
        T = 116,
        /** 'u' key.
         */
        U = 117,
        /** 'v' key.
         */
        V = 118,
        /** 'w' key.
         */
        W = 119,
        /** 'x' key.
         */
        X = 120,
        /** 'y' key.
         */
        Y = 121,
        /** 'z' key.
         */
        Z = 122,
        /** Left curly bracket key '{'.
         */
        LeftCurlyBracket = 123,
        /** Pipe '|' key.
         */
        Pipe = 124,
        /** Right curly bracket key '}'.
         */
        RightCurlyBracket = 125,
        /** Tilde '~' key.
         */
        Tilde = 126,
        /** The forward delete key.
         */
        Delete = 127,
        /** Numeric keypad 0.
         */
        Keypad0 = 256,
        /** Numeric keypad 1.
         */
        Keypad1 = 257,
        /** Numeric keypad 2.
         */
        Keypad2 = 258,
        /** Numeric keypad 3.
         */
        Keypad3 = 259,
        /** Numeric keypad 4.
         */
        Keypad4 = 260,
        /** Numeric keypad 5.
         */
        Keypad5 = 261,
        /** Numeric keypad 6.
         */
        Keypad6 = 262,
        /** Numeric keypad 7.
         */
        Keypad7 = 263,
        /** Numeric keypad 8.
         */
        Keypad8 = 264,
        /** Numeric keypad 9.
         */
        Keypad9 = 265,
        /** Numeric keypad '.'.
         */
        KeypadPeriod = 266,
        /** Numeric keypad '/'.
         */
        KeypadDivide = 267,
        /** Numeric keypad '*'.
         */
        KeypadMultiply = 268,
        /** Numeric keypad '-'.
         */
        KeypadMinus = 269,
        /** Numeric keypad '+'.
         */
        KeypadPlus = 270,
        /** Numeric keypad Enter.
         */
        KeypadEnter = 271,
        /** Numeric keypad '='.
         */
        KeypadEquals = 272,
        /** Up arrow key.
         */
        UpArrow = 273,
        /** Down arrow key.
         */
        DownArrow = 274,
        /** Right arrow key.
         */
        RightArrow = 275,
        /** Left arrow key.
         */
        LeftArrow = 276,
        /** Insert key key.
         */
        Insert = 277,
        /** Home key.
         */
        Home = 278,
        /** End key.
         */
        End = 279,
        /** Page up.
         */
        PageUp = 280,
        /** Page down.
         */
        PageDown = 281,
        /** F1 function key.
         */
        F1 = 282,
        /** F2 function key.
         */
        F2 = 283,
        /** F3 function key.
         */
        F3 = 284,
        /** F4 function key.
         */
        F4 = 285,
        /** F5 function key.
         */
        F5 = 286,
        /** F6 function key.
         */
        F6 = 287,
        /** F7 function key.
         */
        F7 = 288,
        /** F8 function key.
         */
        F8 = 289,
        /** F9 function key.
         */
        F9 = 290,
        /** F10 function key.
         */
        F10 = 291,
        /** F11 function key.
         */
        F11 = 292,
        /** F12 function key.
         */
        F12 = 293,
        /** F13 function key.
         */
        F13 = 294,
        /** F14 function key.
         */
        F14 = 295,
        /** F15 function key.
         */
        F15 = 296,
        /** Numlock key.
         */
        Numlock = 300,
        /** Capslock key.
         */
        CapsLock = 301,
        /** Scroll lock key.
         */
        ScrollLock = 302,
        /** Right shift key.
         */
        RightShift = 303,
        /** Left shift key.
         */
        LeftShift = 304,
        /** Right Control key.
         */
        RightControl = 305,
        /** Left Control key.
         */
        LeftControl = 306,
        /** Right Alt key.
         */
        RightAlt = 307,
        /** Left Alt key.
         */
        LeftAlt = 308,
        /** Maps to right Windows key or right Command key if physical keys are enabled in Input Manager settings, otherwise maps to right Command key only.
         */
        RightMeta = 309,
        /** Maps to right Windows key or right Command key if physical keys are enabled in Input Manager settings, otherwise maps to right Command key only.
         */
        RightCommand = 309,
        /** Maps to right Windows key or right Command key if physical keys are enabled in Input Manager settings, otherwise maps to right Command key only.
         */
        RightApple = 309,
        /** Left Command key.
         */
        LeftMeta = 310,
        /** Left Command key.
         */
        LeftCommand = 310,
        /** Left Command key.
         */
        LeftApple = 310,
        /** Left Windows key.
         */
        LeftWindows = 311,
        /** Right Windows key.
         */
        RightWindows = 312,
        /** Alt Gr key.
         */
        AltGr = 313,
        /** Help key.
         */
        Help = 315,
        /** Print key.
         */
        Print = 316,
        /** Sys Req key.
         */
        SysReq = 317,
        /** Break key.
         */
        Break = 318,
        /** Menu key.
         */
        Menu = 319,
        /** The Left (or primary) mouse button.
         */
        Mouse0 = 323,
        /** Right mouse button (or secondary mouse button).
         */
        Mouse1 = 324,
        /** Middle mouse button (or third button).
         */
        Mouse2 = 325,
        /** Additional (fourth) mouse button.
         */
        Mouse3 = 326,
        /** Additional (fifth) mouse button.
         */
        Mouse4 = 327,
        /** Additional (or sixth) mouse button.
         */
        Mouse5 = 328,
        /** Additional (or seventh) mouse button.
         */
        Mouse6 = 329,
        /** Button 0 on any joystick.
         */
        JoystickButton0 = 330,
        /** Button 1 on any joystick.
         */
        JoystickButton1 = 331,
        /** Button 2 on any joystick.
         */
        JoystickButton2 = 332,
        /** Button 3 on any joystick.
         */
        JoystickButton3 = 333,
        /** Button 4 on any joystick.
         */
        JoystickButton4 = 334,
        /** Button 5 on any joystick.
         */
        JoystickButton5 = 335,
        /** Button 6 on any joystick.
         */
        JoystickButton6 = 336,
        /** Button 7 on any joystick.
         */
        JoystickButton7 = 337,
        /** Button 8 on any joystick.
         */
        JoystickButton8 = 338,
        /** Button 9 on any joystick.
         */
        JoystickButton9 = 339,
        /** Button 10 on any joystick.
         */
        JoystickButton10 = 340,
        /** Button 11 on any joystick.
         */
        JoystickButton11 = 341,
        /** Button 12 on any joystick.
         */
        JoystickButton12 = 342,
        /** Button 13 on any joystick.
         */
        JoystickButton13 = 343,
        /** Button 14 on any joystick.
         */
        JoystickButton14 = 344,
        /** Button 15 on any joystick.
         */
        JoystickButton15 = 345,
        /** Button 16 on any joystick.
         */
        JoystickButton16 = 346,
        /** Button 17 on any joystick.
         */
        JoystickButton17 = 347,
        /** Button 18 on any joystick.
         */
        JoystickButton18 = 348,
        /** Button 19 on any joystick.
         */
        JoystickButton19 = 349,
        /** Button 0 on first joystick.
         */
        Joystick1Button0 = 350,
        /** Button 1 on first joystick.
         */
        Joystick1Button1 = 351,
        /** Button 2 on first joystick.
         */
        Joystick1Button2 = 352,
        /** Button 3 on first joystick.
         */
        Joystick1Button3 = 353,
        /** Button 4 on first joystick.
         */
        Joystick1Button4 = 354,
        /** Button 5 on first joystick.
         */
        Joystick1Button5 = 355,
        /** Button 6 on first joystick.
         */
        Joystick1Button6 = 356,
        /** Button 7 on first joystick.
         */
        Joystick1Button7 = 357,
        /** Button 8 on first joystick.
         */
        Joystick1Button8 = 358,
        /** Button 9 on first joystick.
         */
        Joystick1Button9 = 359,
        /** Button 10 on first joystick.
         */
        Joystick1Button10 = 360,
        /** Button 11 on first joystick.
         */
        Joystick1Button11 = 361,
        /** Button 12 on first joystick.
         */
        Joystick1Button12 = 362,
        /** Button 13 on first joystick.
         */
        Joystick1Button13 = 363,
        /** Button 14 on first joystick.
         */
        Joystick1Button14 = 364,
        /** Button 15 on first joystick.
         */
        Joystick1Button15 = 365,
        /** Button 16 on first joystick.
         */
        Joystick1Button16 = 366,
        /** Button 17 on first joystick.
         */
        Joystick1Button17 = 367,
        /** Button 18 on first joystick.
         */
        Joystick1Button18 = 368,
        /** Button 19 on first joystick.
         */
        Joystick1Button19 = 369,
        /** Button 0 on second joystick.
         */
        Joystick2Button0 = 370,
        /** Button 1 on second joystick.
         */
        Joystick2Button1 = 371,
        /** Button 2 on second joystick.
         */
        Joystick2Button2 = 372,
        /** Button 3 on second joystick.
         */
        Joystick2Button3 = 373,
        /** Button 4 on second joystick.
         */
        Joystick2Button4 = 374,
        /** Button 5 on second joystick.
         */
        Joystick2Button5 = 375,
        /** Button 6 on second joystick.
         */
        Joystick2Button6 = 376,
        /** Button 7 on second joystick.
         */
        Joystick2Button7 = 377,
        /** Button 8 on second joystick.
         */
        Joystick2Button8 = 378,
        /** Button 9 on second joystick.
         */
        Joystick2Button9 = 379,
        /** Button 10 on second joystick.
         */
        Joystick2Button10 = 380,
        /** Button 11 on second joystick.
         */
        Joystick2Button11 = 381,
        /** Button 12 on second joystick.
         */
        Joystick2Button12 = 382,
        /** Button 13 on second joystick.
         */
        Joystick2Button13 = 383,
        /** Button 14 on second joystick.
         */
        Joystick2Button14 = 384,
        /** Button 15 on second joystick.
         */
        Joystick2Button15 = 385,
        /** Button 16 on second joystick.
         */
        Joystick2Button16 = 386,
        /** Button 17 on second joystick.
         */
        Joystick2Button17 = 387,
        /** Button 18 on second joystick.
         */
        Joystick2Button18 = 388,
        /** Button 19 on second joystick.
         */
        Joystick2Button19 = 389,
        /** Button 0 on third joystick.
         */
        Joystick3Button0 = 390,
        /** Button 1 on third joystick.
         */
        Joystick3Button1 = 391,
        /** Button 2 on third joystick.
         */
        Joystick3Button2 = 392,
        /** Button 3 on third joystick.
         */
        Joystick3Button3 = 393,
        /** Button 4 on third joystick.
         */
        Joystick3Button4 = 394,
        /** Button 5 on third joystick.
         */
        Joystick3Button5 = 395,
        /** Button 6 on third joystick.
         */
        Joystick3Button6 = 396,
        /** Button 7 on third joystick.
         */
        Joystick3Button7 = 397,
        /** Button 8 on third joystick.
         */
        Joystick3Button8 = 398,
        /** Button 9 on third joystick.
         */
        Joystick3Button9 = 399,
        /** Button 10 on third joystick.
         */
        Joystick3Button10 = 400,
        /** Button 11 on third joystick.
         */
        Joystick3Button11 = 401,
        /** Button 12 on third joystick.
         */
        Joystick3Button12 = 402,
        /** Button 13 on third joystick.
         */
        Joystick3Button13 = 403,
        /** Button 14 on third joystick.
         */
        Joystick3Button14 = 404,
        /** Button 15 on third joystick.
         */
        Joystick3Button15 = 405,
        /** Button 16 on third joystick.
         */
        Joystick3Button16 = 406,
        /** Button 17 on third joystick.
         */
        Joystick3Button17 = 407,
        /** Button 18 on third joystick.
         */
        Joystick3Button18 = 408,
        /** Button 19 on third joystick.
         */
        Joystick3Button19 = 409,
        /** Button 0 on forth joystick.
         */
        Joystick4Button0 = 410,
        /** Button 1 on forth joystick.
         */
        Joystick4Button1 = 411,
        /** Button 2 on forth joystick.
         */
        Joystick4Button2 = 412,
        /** Button 3 on forth joystick.
         */
        Joystick4Button3 = 413,
        /** Button 4 on forth joystick.
         */
        Joystick4Button4 = 414,
        /** Button 5 on forth joystick.
         */
        Joystick4Button5 = 415,
        /** Button 6 on forth joystick.
         */
        Joystick4Button6 = 416,
        /** Button 7 on forth joystick.
         */
        Joystick4Button7 = 417,
        /** Button 8 on forth joystick.
         */
        Joystick4Button8 = 418,
        /** Button 9 on forth joystick.
         */
        Joystick4Button9 = 419,
        /** Button 10 on forth joystick.
         */
        Joystick4Button10 = 420,
        /** Button 11 on forth joystick.
         */
        Joystick4Button11 = 421,
        /** Button 12 on forth joystick.
         */
        Joystick4Button12 = 422,
        /** Button 13 on forth joystick.
         */
        Joystick4Button13 = 423,
        /** Button 14 on forth joystick.
         */
        Joystick4Button14 = 424,
        /** Button 15 on forth joystick.
         */
        Joystick4Button15 = 425,
        /** Button 16 on forth joystick.
         */
        Joystick4Button16 = 426,
        /** Button 17 on forth joystick.
         */
        Joystick4Button17 = 427,
        /** Button 18 on forth joystick.
         */
        Joystick4Button18 = 428,
        /** Button 19 on forth joystick.
         */
        Joystick4Button19 = 429,
        /** Button 0 on fifth joystick.
         */
        Joystick5Button0 = 430,
        /** Button 1 on fifth joystick.
         */
        Joystick5Button1 = 431,
        /** Button 2 on fifth joystick.
         */
        Joystick5Button2 = 432,
        /** Button 3 on fifth joystick.
         */
        Joystick5Button3 = 433,
        /** Button 4 on fifth joystick.
         */
        Joystick5Button4 = 434,
        /** Button 5 on fifth joystick.
         */
        Joystick5Button5 = 435,
        /** Button 6 on fifth joystick.
         */
        Joystick5Button6 = 436,
        /** Button 7 on fifth joystick.
         */
        Joystick5Button7 = 437,
        /** Button 8 on fifth joystick.
         */
        Joystick5Button8 = 438,
        /** Button 9 on fifth joystick.
         */
        Joystick5Button9 = 439,
        /** Button 10 on fifth joystick.
         */
        Joystick5Button10 = 440,
        /** Button 11 on fifth joystick.
         */
        Joystick5Button11 = 441,
        /** Button 12 on fifth joystick.
         */
        Joystick5Button12 = 442,
        /** Button 13 on fifth joystick.
         */
        Joystick5Button13 = 443,
        /** Button 14 on fifth joystick.
         */
        Joystick5Button14 = 444,
        /** Button 15 on fifth joystick.
         */
        Joystick5Button15 = 445,
        /** Button 16 on fifth joystick.
         */
        Joystick5Button16 = 446,
        /** Button 17 on fifth joystick.
         */
        Joystick5Button17 = 447,
        /** Button 18 on fifth joystick.
         */
        Joystick5Button18 = 448,
        /** Button 19 on fifth joystick.
         */
        Joystick5Button19 = 449,
        /** Button 0 on sixth joystick.
         */
        Joystick6Button0 = 450,
        /** Button 1 on sixth joystick.
         */
        Joystick6Button1 = 451,
        /** Button 2 on sixth joystick.
         */
        Joystick6Button2 = 452,
        /** Button 3 on sixth joystick.
         */
        Joystick6Button3 = 453,
        /** Button 4 on sixth joystick.
         */
        Joystick6Button4 = 454,
        /** Button 5 on sixth joystick.
         */
        Joystick6Button5 = 455,
        /** Button 6 on sixth joystick.
         */
        Joystick6Button6 = 456,
        /** Button 7 on sixth joystick.
         */
        Joystick6Button7 = 457,
        /** Button 8 on sixth joystick.
         */
        Joystick6Button8 = 458,
        /** Button 9 on sixth joystick.
         */
        Joystick6Button9 = 459,
        /** Button 10 on sixth joystick.
         */
        Joystick6Button10 = 460,
        /** Button 11 on sixth joystick.
         */
        Joystick6Button11 = 461,
        /** Button 12 on sixth joystick.
         */
        Joystick6Button12 = 462,
        /** Button 13 on sixth joystick.
         */
        Joystick6Button13 = 463,
        /** Button 14 on sixth joystick.
         */
        Joystick6Button14 = 464,
        /** Button 15 on sixth joystick.
         */
        Joystick6Button15 = 465,
        /** Button 16 on sixth joystick.
         */
        Joystick6Button16 = 466,
        /** Button 17 on sixth joystick.
         */
        Joystick6Button17 = 467,
        /** Button 18 on sixth joystick.
         */
        Joystick6Button18 = 468,
        /** Button 19 on sixth joystick.
         */
        Joystick6Button19 = 469,
        /** Button 0 on seventh joystick.
         */
        Joystick7Button0 = 470,
        /** Button 1 on seventh joystick.
         */
        Joystick7Button1 = 471,
        /** Button 2 on seventh joystick.
         */
        Joystick7Button2 = 472,
        /** Button 3 on seventh joystick.
         */
        Joystick7Button3 = 473,
        /** Button 4 on seventh joystick.
         */
        Joystick7Button4 = 474,
        /** Button 5 on seventh joystick.
         */
        Joystick7Button5 = 475,
        /** Button 6 on seventh joystick.
         */
        Joystick7Button6 = 476,
        /** Button 7 on seventh joystick.
         */
        Joystick7Button7 = 477,
        /** Button 8 on seventh joystick.
         */
        Joystick7Button8 = 478,
        /** Button 9 on seventh joystick.
         */
        Joystick7Button9 = 479,
        /** Button 10 on seventh joystick.
         */
        Joystick7Button10 = 480,
        /** Button 11 on seventh joystick.
         */
        Joystick7Button11 = 481,
        /** Button 12 on seventh joystick.
         */
        Joystick7Button12 = 482,
        /** Button 13 on seventh joystick.
         */
        Joystick7Button13 = 483,
        /** Button 14 on seventh joystick.
         */
        Joystick7Button14 = 484,
        /** Button 15 on seventh joystick.
         */
        Joystick7Button15 = 485,
        /** Button 16 on seventh joystick.
         */
        Joystick7Button16 = 486,
        /** Button 17 on seventh joystick.
         */
        Joystick7Button17 = 487,
        /** Button 18 on seventh joystick.
         */
        Joystick7Button18 = 488,
        /** Button 19 on seventh joystick.
         */
        Joystick7Button19 = 489,
        /** Button 0 on eighth joystick.
         */
        Joystick8Button0 = 490,
        /** Button 1 on eighth joystick.
         */
        Joystick8Button1 = 491,
        /** Button 2 on eighth joystick.
         */
        Joystick8Button2 = 492,
        /** Button 3 on eighth joystick.
         */
        Joystick8Button3 = 493,
        /** Button 4 on eighth joystick.
         */
        Joystick8Button4 = 494,
        /** Button 5 on eighth joystick.
         */
        Joystick8Button5 = 495,
        /** Button 6 on eighth joystick.
         */
        Joystick8Button6 = 496,
        /** Button 7 on eighth joystick.
         */
        Joystick8Button7 = 497,
        /** Button 8 on eighth joystick.
         */
        Joystick8Button8 = 498,
        /** Button 9 on eighth joystick.
         */
        Joystick8Button9 = 499,
        /** Button 10 on eighth joystick.
         */
        Joystick8Button10 = 500,
        /** Button 11 on eighth joystick.
         */
        Joystick8Button11 = 501,
        /** Button 12 on eighth joystick.
         */
        Joystick8Button12 = 502,
        /** Button 13 on eighth joystick.
         */
        Joystick8Button13 = 503,
        /** Button 14 on eighth joystick.
         */
        Joystick8Button14 = 504,
        /** Button 15 on eighth joystick.
         */
        Joystick8Button15 = 505,
        /** Button 16 on eighth joystick.
         */
        Joystick8Button16 = 506,
        /** Button 17 on eighth joystick.
         */
        Joystick8Button17 = 507,
        /** Button 18 on eighth joystick.
         */
        Joystick8Button18 = 508,
        /** Button 19 on eighth joystick.
         */
        Joystick8Button19 = 509,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Base class for Texture handling.
     */
    class Texture extends Object {
        GetNativeTexturePtr(): any
        IncrementUpdateCount(): void
        /** Sets Anisotropic limits.
         */
        static SetGlobalAnisotropicFilteringLimits(forcedMin: number, globalMax: number): void
        static SetStreamingTextureMaterialDebugProperties(): void
        protected constructor()
        static masterTextureLimit: number
        /** How many mipmap levels are in this Texture (Read Only).
         */
        readonly mipmapCount: number
        static anisotropicFiltering: any
        /** Returns the GraphicsFormat format or color format of a Texture object.
         */
        readonly graphicsFormat: any
        /** Width of the Texture in pixels (Read Only).
         */
        width: number
        /** Height of the Texture in pixels (Read Only).
         */
        height: number
        /** Dimensionality (type) of the Texture (Read Only).
         */
        dimension: any
        /** Whether Unity stores an additional copy of this texture's pixel data in CPU-addressable memory.
         */
        readonly isReadable: boolean
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** Filtering mode of the Texture.
         */
        filterMode: any
        /** Defines the anisotropic filtering level of the Texture.
         */
        anisoLevel: number
        /** The mipmap bias of the Texture.
         */
        mipMapBias: number
        readonly texelSize: Vector2
        /** This counter is incremented when the Texture is updated.
         */
        readonly updateCount: number
        /** Returns true if the texture pixel data is in sRGB color space (Read Only).
         */
        readonly isDataSRGB: boolean
        /** The total amount of Texture memory that Unity would use if it loads all Textures at mipmap level 0. 

This is a theoretical value that does not take into account any input from the streaming system or any other input, for example when you set the`Texture2D.requestedMipmapLevel` manually. 

To see a Texture memory value that takes inputs into account, use `desiredTextureMemory`. 

`totalTextureMemory` only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        static readonly totalTextureMemory: number
        /** The total size of the Textures, in bytes, that Unity loads if there were no other constraints. Before Unity loads any Textures, it applies the which reduces the loaded Texture resolution if the Texture sizes exceed its value. The desiredTextureMemory value takes into account the mipmap levels that Unity has requested or that you have set manually.

For example, if Unity does not load a Texture at full resolution because it is far away or its requested mipmap level is greater than 0,  Unity reduces the desiredTextureMemory value to match the total memory needed.

The desiredTextureMemory value can be greater than the Texture.targetTextureMemory value.
                
         */
        static readonly desiredTextureMemory: number
        /** The total amount of Texture memory that Unity allocates to the Textures in the scene after it applies the and finishes loading Textures. `targetTextureMemory`also takes mipmap streaming settings into account. This value only includes instances of Texture2D and CubeMap Textures. This value does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        static readonly targetTextureMemory: number
        /** The amount of memory that all Textures in the scene use.
         */
        static readonly currentTextureMemory: number
        /** The amount of memory Unity allocates for non-streaming Textures in the scene. This only includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        static readonly nonStreamingTextureMemory: number
        /** How many times has a Texture been uploaded due to Texture mipmap streaming.
         */
        static readonly streamingMipmapUploadCount: number
        /** Number of renderers registered with the Texture streaming system.
         */
        static readonly streamingRendererCount: number
        /** Number of streaming Textures.
         */
        static readonly streamingTextureCount: number
        /** The number of non-streaming Textures in the scene. This includes instances of Texture2D and CubeMap Textures. This does not include any other Texture types, or 2D and CubeMap Textures that Unity creates internally.
         */
        static readonly nonStreamingTextureCount: number
        /** Number of streaming Textures with outstanding mipmaps to be loaded.
         */
        static readonly streamingTexturePendingLoadCount: number
        /** Number of streaming Textures with mipmaps currently loading.
         */
        static readonly streamingTextureLoadingCount: number
        /** Force streaming Textures to load all mipmap levels.
         */
        static streamingTextureForceLoadAll: boolean
        /** This property forces the streaming Texture system to discard all unused mipmaps instead of caching them until the Texture is exceeded. This is useful when you profile or write tests to keep a predictable set of Textures in memory.
         */
        static streamingTextureDiscardUnusedMips: boolean
        /** Allow Unity internals to perform Texture creation on any thread (rather than the dedicated render thread).
         */
        static allowThreadedTextureCreation: boolean
        /** Can be used with Texture constructors that take a mip count to indicate that all mips should be generated.  The value of this field is -1.
         */
        static readonly GenerateAllMips: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1 } from "System";
    /** Class that represents textures in C# code.
     */
    class Texture2D extends Texture {
        constructor(width: number, height: number, format: any, mipCount: number, flags: any)
        constructor(width: number, height: number, textureFormat: any, mipCount: number, linear: boolean)
        constructor(width: number, height: number, textureFormat: any, mipChain: boolean, linear: boolean)
        constructor(width: number, height: number, format: any, flags: any)
        constructor(width: number, height: number, format: any, flags: any)
        constructor(width: number, height: number, textureFormat: any, mipChain: boolean)
        constructor(width: number, height: number)
        /** Sets the pixel color at coordinates (x,y).
         * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
         * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
         * @param color The color to set.
         * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixel(x: number, y: number, color: Color, mipLevel: number): void
        /** Sets the pixel color at coordinates (x,y).
         * @param x The x coordinate of the pixel to set. The range is 0 through (texture width - 1).
         * @param y The y coordinate of the pixel to set. The range is 0 through (texture height - 1).
         * @param color The color to set.
         * @param mipLevel The mipmap level to write to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixel(x: number, y: number, color: Color): void
        /** Sets the pixel colors of part of a mipmap level.
         * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
         * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
         * @param blockWidth The width of the block of pixels to set.
         * @param blockHeight The height of the block of pixels to set.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color>, miplevel: number): void
        SetPixels(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color>): void
        /** Sets the pixel colors of an entire mipmap level.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels(colors: Array<Color>, miplevel: number): void
        SetPixels(colors: Array<Color>): void
        /** Gets the pixel color at coordinates (x, y).
         * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
         * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
         * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns The pixel color. 
         */
        GetPixel(x: number, y: number, mipLevel: number): Color
        /** Gets the pixel color at coordinates (x, y).
         * @param x The x coordinate of the pixel to get. The range is 0 through (texture width - 1).
         * @param y The y coordinate of the pixel to get. The range is 0 through (texture height - 1).
         * @param mipLevel The mipmap level to sample. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns The pixel color. 
         */
        GetPixel(x: number, y: number): Color
        /** Gets the filtered pixel color at the normalized coordinates (u, v).
         * @param u The u coordinate of the pixel to get.
         * @param v The v coordinate of the pixel to get.
         * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns The pixel color. 
         */
        GetPixelBilinear(u: number, v: number, mipLevel: number): Color
        /** Gets the filtered pixel color at the normalized coordinates (u, v).
         * @param u The u coordinate of the pixel to get.
         * @param v The v coordinate of the pixel to get.
         * @param mipLevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns The pixel color. 
         */
        GetPixelBilinear(u: number, v: number): Color
        /** Sets the raw data of an entire texture in CPU memory.
         * @param data The array of data to use.
         * @param size The size of the data in bytes.
         */
        LoadRawTextureData(data: any, size: number): void
        /** Sets the raw data of an entire texture in CPU memory.
         * @param data The array of data to use.
         * @param size The size of the data in bytes.
         */
        LoadRawTextureData(data: Array<jsb.byte>): void
        /** Copies changes you've made in a CPU texture to the GPU.
         * @param updateMipmaps When the value is true, Unity recalculates mipmap levels, using mipmap level 0 as the source. The default value is true.
         * @param makeNoLongerReadable When the value is true, Unity deletes the texture in CPU memory after it uploads it to the GPU, and sets Texture.isReadable|isReadable to false. The default value is false.
         */
        Apply(updateMipmaps: boolean, makeNoLongerReadable: boolean): void
        Apply(updateMipmaps: boolean): void
        Apply(): void
        /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
         * @param width New width of the Texture.
         * @param height New height of the Texture.
         * @param format New format of the Texture.
         * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
         * @returns Returns true if the reinitialization was a success. 
         */
        Reinitialize(width: number, height: number, format: any, hasMipMap: boolean): boolean
        /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
         * @param width New width of the Texture.
         * @param height New height of the Texture.
         * @param format New format of the Texture.
         * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
         * @returns Returns true if the reinitialization was a success. 
         */
        Reinitialize(width: number, height: number, format: any, hasMipMap: boolean): boolean
        /** Reinitializes a Texture2D, making it possible for you to replace width, height, textureformat, and graphicsformat data for that texture.
         * @param width New width of the Texture.
         * @param height New height of the Texture.
         * @param format New format of the Texture.
         * @param hasMipMap Indicates if the Texture should reserve memory for a full mip map chain.
         * @returns Returns true if the reinitialization was a success. 
         */
        Reinitialize(width: number, height: number): boolean
        /** Reads pixels from the current render target and writes them to a texture.
         * @param source The region of the render target to read from.
         * @param destX The x position in the texture to write the pixels to.
         * @param destY The y position in the texture to write the pixels to.
         * @param recalculateMipMaps When the value is true, Unity automatically recalculates the mipmap for the texture after it writes the pixel data. Otherwise, Unity doesn't do this automatically.
         */
        ReadPixels(source: Rect, destX: number, destY: number, recalculateMipMaps: boolean): void
        ReadPixels(source: Rect, destX: number, destY: number): void
        /** Sets the pixel colors of part of a mipmap level.
         * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
         * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
         * @param blockWidth The width of the block of pixels to set.
         * @param blockHeight The height of the block of pixels to set.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color32>, miplevel: number): void
        /** Sets the pixel colors of part of a mipmap level.
         * @param x The x coordinate to place the block of pixels at. The range is 0 through (texture width - 1).
         * @param y The y coordinate to place the block of pixels at. The range is 0 through (texture height - 1).
         * @param blockWidth The width of the block of pixels to set.
         * @param blockHeight The height of the block of pixels to set.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array. Must be blockWidth x blockHeight in length.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels32(x: number, y: number, blockWidth: number, blockHeight: number, colors: Array<Color32>): void
        /** Sets the pixel colors of an entire mipmap level.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels32(colors: Array<Color32>, miplevel: number): void
        /** Sets the pixel colors of an entire mipmap level.
         * @param colors The array of pixel colours to use. This is a 2D image flattened to a 1D array.
         * @param miplevel The mipmap level to write colors to. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         */
        SetPixels32(colors: Array<Color32>): void
        /** Gets the pixel color data for part of a mipmap level as Color structs.
         * @param x The starting x position of the section to fetch.
         * @param y The starting y position of the section to fetch.
         * @param blockWidth The width of the section to fetch.
         * @param blockHeight The height of the section to fetch.
         * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels(x: number, y: number, blockWidth: number, blockHeight: number, miplevel: number): Array<Color>
        /** Gets the pixel color data for part of a mipmap level as Color structs.
         * @param x The starting x position of the section to fetch.
         * @param y The starting y position of the section to fetch.
         * @param blockWidth The width of the section to fetch.
         * @param blockHeight The height of the section to fetch.
         * @param miplevel The mipmap level to read from. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels(x: number, y: number, blockWidth: number, blockHeight: number): Array<Color>
        /** Gets the pixel color data for a mipmap level as Color structs.
         * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels(miplevel: number): Array<Color>
        /** Gets the pixel color data for a mipmap level as Color structs.
         * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels(): Array<Color>
        /** Compress texture at runtime to DXT/BCn or ETC formats.
         */
        Compress(highQuality: boolean): void
        ClearRequestedMipmapLevel(): void
        IsRequestedMipmapLevelLoaded(): boolean
        ClearMinimumMipmapLevel(): void
        /** Updates Unity texture to use different native texture object.
         * @param nativeTex Native 2D texture object.
         */
        UpdateExternalTexture(nativeTex: any): void
        GetRawTextureData(): Array<jsb.byte>
        /** Gets the pixel color data for a mipmap level as Color32 structs.
         * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels32(miplevel: number): Array<Color32>
        /** Gets the pixel color data for a mipmap level as Color32 structs.
         * @param miplevel The mipmap level to get. The range is 0 through the texture's Texture.mipmapCount. The default value is 0.
         * @returns An array that contains the pixel colors. 
         */
        GetPixels32(): Array<Color32>
        /** Packs multiple Textures into a texture atlas.
         * @param textures Array of textures to pack into the atlas.
         * @param padding Padding in pixels between the packed textures.
         * @param maximumAtlasSize Maximum size of the resulting texture.
         * @param makeNoLongerReadable Should the texture be marked as no longer readable?
         * @returns An array of rectangles containing the UV coordinates in the atlas for each input texture, or null if packing fails. 
         */
        PackTextures(textures: Array<Texture2D>, padding: number, maximumAtlasSize: number, makeNoLongerReadable: boolean): Array<Rect>
        PackTextures(textures: Array<Texture2D>, padding: number, maximumAtlasSize: number): Array<Rect>
        PackTextures(textures: Array<Texture2D>, padding: number): Array<Rect>
        /** Encodes the specified texture in TGA format.
         * @param tex The texture to encode.
         */
        EncodeToTGA(): Array<jsb.byte>
        /** Encodes this texture into PNG format.
         * @param tex The texture to convert.
         */
        EncodeToPNG(): Array<jsb.byte>
        /** Encodes this texture into JPG format.
         * @param tex Text texture to convert.
         * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
         */
        EncodeToJPG(quality: number): Array<jsb.byte>
        /** Encodes this texture into JPG format.
         * @param tex Text texture to convert.
         * @param quality JPG quality to encode with. The range is 1 through 100. 1 is the lowest quality. The default is 75.
         */
        EncodeToJPG(): Array<jsb.byte>
        EncodeToEXR(flags: any): Array<jsb.byte>
        EncodeToEXR(): Array<jsb.byte>
        /** Loads PNG or JPG image byte array into a texture.
         * @param tex The texture to load the image into.
         * @param data The byte array containing the image data to load.
         * @param markNonReadable Set to false by default, pass true to optionally mark the texture as non-readable.
         * @returns Returns true if the data can be loaded, false otherwise. 
         */
        LoadImage(data: Array<jsb.byte>, markNonReadable: boolean): boolean
        LoadImage(data: Array<jsb.byte>): boolean
        /** Creates a Unity Texture out of an externally created native texture object.
         * @param nativeTex Native 2D texture object.
         * @param width Width of texture in pixels.
         * @param height Height of texture in pixels.
         * @param format Format of underlying texture object.
         * @param mipmap Does the texture have mipmaps?
         * @param linear Is texture using linear color space?
         */
        static CreateExternalTexture(width: number, height: number, format: any, mipChain: boolean, linear: boolean, nativeTex: any): Texture2D
        static GenerateAtlas(sizes: Array<Vector2>, padding: number, atlasSize: number, results: any): boolean
        /** The format of the pixel data in the texture (Read Only).
         */
        readonly format: any
        /** This property causes a texture to ignore the QualitySettings.masterTextureLimit.
         */
        ignoreMipmapLimit: boolean
        /** Gets a small Texture with all white pixels.
         */
        static readonly whiteTexture: Texture2D
        /** Gets a small Texture with all black pixels.
         */
        static readonly blackTexture: Texture2D
        /** Gets a small Texture with all red pixels.
         */
        static readonly redTexture: Texture2D
        /** Gets a small Texture with all gray pixels.
         */
        static readonly grayTexture: Texture2D
        /** Gets a small Texture with all gray pixels.
         */
        static readonly linearGrayTexture: Texture2D
        /** Gets a small Texture with pixels that represent surface normal vectors at a neutral position.
         */
        static readonly normalTexture: Texture2D
        readonly isReadable: boolean
        /** Returns true if the VTOnly checkbox was checked when the texture was imported; otherwise returns false. For additional information, see TextureImporter.vtOnly.
         */
        readonly vtOnly: boolean
        /** Determines whether mipmap streaming is enabled for this Texture.
         */
        readonly streamingMipmaps: boolean
        /** Sets the relative priority for this Texture when reducing memory size to fit within the memory budget.
         */
        readonly streamingMipmapsPriority: number
        /** The mipmap level to load.
         */
        requestedMipmapLevel: number
        /** Restricts the mipmap streaming system to a minimum mip level for this Texture.
         */
        minimumMipmapLevel: number
        /** The mipmap level calculated by the streaming system, which takes into account the streaming Cameras and the location of the objects containing this Texture. This is unaffected by requestedMipmapLevel or minimumMipmapLevel.
         */
        readonly calculatedMipmapLevel: number
        /** The mipmap level that the streaming system would load before memory budgets are applied.
         */
        readonly desiredMipmapLevel: number
        /** The mipmap level that the mipmap streaming system is in the process of loading.
         */
        readonly loadingMipmapLevel: number
        /** The mipmap level that is currently loaded by the streaming system.
         */
        readonly loadedMipmapLevel: number
        /** Indicates whether this texture was imported with TextureImporter.alphaIsTransparency enabled. This setting is available only in the Editor scripts. Note that changing this setting will have no effect; it must be enabled in TextureImporter instead.
         */
        alphaIsTransparency: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, ValueType, Enum, Object as Object1 } from "System";
    /** The material class.
     */
    class Material extends Object {
        constructor(shader: any)
        constructor(source: Material)
        /** This method is deprecated. Use SetFloat or SetInteger instead.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInt(name: string, value: number): void
        /** This method is deprecated. Use SetFloat or SetInteger instead.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInt(nameID: number, value: number): void
        /** Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        SetFloat(name: string, value: number): void
        /** Sets a named float value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Float value to set.
         * @param name Property name, e.g. "_Glossiness".
         */
        SetFloat(nameID: number, value: number): void
        /** Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInteger(name: string, value: number): void
        /** Sets a named integer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param value Integer value to set.
         * @param name Property name, e.g. "_SrcBlend".
         */
        SetInteger(nameID: number, value: number): void
        /** Sets a color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        SetColor(name: string, value: Color): void
        /** Sets a color value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_Color".
         * @param value Color value to set.
         */
        SetColor(nameID: number, value: Color): void
        /** Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        SetVector(name: string, value: Vector4): void
        /** Sets a named vector value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_WaveAndDistance".
         * @param value Vector value to set.
         */
        SetVector(nameID: number, value: Vector4): void
        /** Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        SetMatrix(name: string, value: Matrix4x4): void
        /** Sets a named matrix for the shader.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_CubemapRotation".
         * @param value Matrix value to set.
         */
        SetMatrix(nameID: number, value: Matrix4x4): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        SetTexture(name: string, value: any, element: any): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        SetTexture(nameID: number, value: any, element: any): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        SetTexture(name: string, value: Texture): void
        /** Sets a named texture.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture to set.
         * @param element Optional parameter that specifies the type of data to set from the RenderTexture.
         */
        SetTexture(nameID: number, value: Texture): void
        /** Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        SetBuffer(name: string, value: any): void
        /** Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        SetBuffer(nameID: number, value: any): void
        /** Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        SetBuffer(name: string, value: any): void
        /** Sets a named buffer value.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name.
         * @param value The ComputeBuffer or GraphicsBuffer value to set.
         */
        SetBuffer(nameID: number, value: any): void
        /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(name: string, value: any, offset: number, size: number): void
        /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(nameID: number, value: any, offset: number, size: number): void
        /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(name: string, value: any, offset: number, size: number): void
        /** Sets a ComputeBuffer or GraphicsBuffer as a named constant buffer for the material.
         * @param name The name of the constant buffer to override.
         * @param value The ComputeBuffer to override the constant buffer values with, or null to remove binding.
         * @param offset Offset in bytes from the beginning of the buffer to bind. Must be a multiple of SystemInfo.constantBufferOffsetAlignment, or 0 if that value is 0.
         * @param size The number of bytes to bind.
         * @param nameID The shader property ID of the constant buffer to override.
         */
        SetConstantBuffer(nameID: number, value: any, offset: number, size: number): void
        SetFloatArray(name: string, values: any): void
        SetFloatArray(nameID: number, values: any): void
        /** Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        SetFloatArray(name: string, values: Array<number>): void
        /** Sets a float array property.
         * @param name Property name.
         * @param nameID Property name ID. Use Shader.PropertyToID to get this ID.
         * @param values Array of values to set.
         */
        SetFloatArray(nameID: number, values: Array<number>): void
        SetColorArray(name: string, values: any): void
        SetColorArray(nameID: number, values: any): void
        /** Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        SetColorArray(name: string, values: Array<Color>): void
        /** Sets a color array property.
         * @param name Property name.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param values Array of values to set.
         */
        SetColorArray(nameID: number, values: Array<Color>): void
        SetVectorArray(name: string, values: any): void
        SetVectorArray(nameID: number, values: any): void
        /** Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetVectorArray(name: string, values: Array<Vector4>): void
        /** Sets a vector array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetVectorArray(nameID: number, values: Array<Vector4>): void
        SetMatrixArray(name: string, values: any): void
        SetMatrixArray(nameID: number, values: any): void
        /** Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetMatrixArray(name: string, values: Array<Matrix4x4>): void
        /** Sets a matrix array property.
         * @param name Property name.
         * @param values Array of values to set.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         */
        SetMatrixArray(nameID: number, values: Array<Matrix4x4>): void
        /** This method is deprecated. Use GetFloat or GetInteger instead.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInt(name: string): number
        /** This method is deprecated. Use GetFloat or GetInteger instead.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInt(nameID: number): number
        /** Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetFloat(name: string): number
        /** Get a named float value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetFloat(nameID: number): number
        /** Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInteger(name: string): number
        /** Get a named integer value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetInteger(nameID: number): number
        /** Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColor(name: string): Color
        /** Get a named color value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColor(nameID: number): Color
        /** Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetVector(name: string): Vector4
        /** Get a named vector value.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetVector(nameID: number): Vector4
        /** Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetMatrix(name: string): Matrix4x4
        /** Get a named matrix value from the shader.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetMatrix(nameID: number): Matrix4x4
        /** Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTexture(name: string): Texture
        /** Get a named texture.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTexture(nameID: number): Texture
        GetFloatArray(name: string, values: any): void
        GetFloatArray(nameID: number, values: any): void
        /** Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetFloatArray(name: string): Array<number>
        /** Get a named float array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetFloatArray(nameID: number): Array<number>
        GetColorArray(name: string, values: any): void
        GetColorArray(nameID: number, values: any): void
        /** Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColorArray(name: string): Array<Color>
        /** Get a named color array.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetColorArray(nameID: number): Array<Color>
        GetVectorArray(name: string, values: any): void
        GetVectorArray(nameID: number, values: any): void
        /** Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetVectorArray(name: string): Array<Vector4>
        /** Get a named vector array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetVectorArray(nameID: number): Array<Vector4>
        GetMatrixArray(name: string, values: any): void
        GetMatrixArray(nameID: number, values: any): void
        /** Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetMatrixArray(name: string): Array<Matrix4x4>
        /** Get a named matrix array.
         * @param name The name of the property.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         */
        GetMatrixArray(nameID: number): Array<Matrix4x4>
        /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
         * @param value Texture placement offset.
         */
        SetTextureOffset(name: string, value: Vector2): void
        /** Sets the placement offset of a given texture. The name parameter is defined in the shader. This method creates a new Material instance.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name The name of the texture property as defined in the shader. For example: "_MainTex".
         * @param value Texture placement offset.
         */
        SetTextureOffset(nameID: number, value: Vector2): void
        /** Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        SetTextureScale(name: string, value: Vector2): void
        /** Sets the placement scale of texture propertyName.
         * @param nameID Property name ID, use Shader.PropertyToID to get it.
         * @param name Property name, e.g. "_MainTex".
         * @param value Texture placement scale.
         */
        SetTextureScale(nameID: number, value: Vector2): void
        /** Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureOffset(name: string): Vector2
        /** Gets the placement offset of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureOffset(nameID: number): Vector2
        /** Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureScale(name: string): Vector2
        /** Gets the placement scale of texture propertyName.
         * @param nameID The name ID of the property retrieved by Shader.PropertyToID.
         * @param name The name of the property.
         */
        GetTextureScale(nameID: number): Vector2
        /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasProperty(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasProperty(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasFloat(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Float property with the given name. This also works with the Float Array property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasFloat(nameID: number): boolean
        /** This method is deprecated. Use HasFloat or HasInteger instead.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasInt(name: string): boolean
        /** This method is deprecated. Use HasFloat or HasInteger instead.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasInt(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasInteger(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has an Integer property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasInteger(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasTexture(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Texture property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasTexture(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasMatrix(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Matrix property with the given name. This also works with the Matrix Array property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasMatrix(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
         * @param name The name of the property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasVector(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Vector property with the given name. This also works with the Vector Array property.
         * @param name The name of the property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasVector(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasColor(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a Color property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasColor(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
         * @param name The name of the property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasBuffer(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a ComputeBuffer property with the given name.
         * @param name The name of the property.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasBuffer(nameID: number): boolean
        /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasConstantBuffer(name: string): boolean
        /** Checks if the ShaderLab file assigned to the Material has a ConstantBuffer property with the given name.
         * @param nameID The name ID of the property. Use Shader.PropertyToID to get this ID.
         * @param name The name of the property.
         * @returns Returns true if the ShaderLab file assigned to the Material has this property. 
         */
        HasConstantBuffer(nameID: number): boolean
        /** Enables a local shader keyword for this material.
         * @param keyword The name of the Rendering.LocalKeyword to enable.
         */
        EnableKeyword(keyword: string): void
        /** Enables a local shader keyword for this material.
         * @param keyword The name of the Rendering.LocalKeyword to enable.
         */
        EnableKeyword(keyword: jsb.Ref<any>): void
        /** Disables a local shader keyword for this material.
         * @param keyword The name of the Rendering.LocalKeyword to disable.
         */
        DisableKeyword(keyword: string): void
        /** Disables a local shader keyword for this material.
         * @param keyword The name of the Rendering.LocalKeyword to disable.
         */
        DisableKeyword(keyword: jsb.Ref<any>): void
        /** Checks whether a local shader keyword is enabled for this material.
         * @param keyword The name of the Rendering.LocalKeyword to check.
         * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
         */
        IsKeywordEnabled(keyword: string): boolean
        /** Checks whether a local shader keyword is enabled for this material.
         * @param keyword The name of the Rendering.LocalKeyword to check.
         * @returns Returns true if a Rendering.LocalKeyword with the given name is enabled  for this material. 
         */
        IsKeywordEnabled(keyword: jsb.Ref<any>): boolean
        /** Sets the state of a local shader keyword for this material.
         * @param keyword The Rendering.LocalKeyword to enable or disable.
         * @param value The desired keyword state.
         */
        SetKeyword(keyword: jsb.Ref<any>, value: boolean): void
        /** Enables or disables a Shader pass on a per-Material level.
         * @param passName Shader pass name (case insensitive).
         * @param enabled Flag indicating whether this Shader pass should be enabled.
         */
        SetShaderPassEnabled(passName: string, enabled: boolean): void
        /** Checks whether a given Shader pass is enabled on this Material.
         * @param passName Shader pass name (case insensitive).
         * @returns True if the Shader pass is enabled. 
         */
        GetShaderPassEnabled(passName: string): boolean
        /** Returns the name of the shader pass at index pass.
         */
        GetPassName(pass: number): string
        /** Returns the index of the pass passName.
         */
        FindPass(passName: string): number
        /** Sets an override tag/value on the material.
         * @param tag Name of the tag to set.
         * @param val Name of the value to set. Empty string to clear the override flag.
         */
        SetOverrideTag(tag: string, val: string): void
        /** Get the value of material's shader tag.
         */
        GetTag(tag: string, searchFallbacks: boolean, defaultValue: string): string
        /** Get the value of material's shader tag.
         */
        GetTag(tag: string, searchFallbacks: boolean): string
        /** Interpolate properties between two materials.
         */
        Lerp(start: Material, end: Material, t: number): void
        /** Activate the given pass for rendering.
         * @param pass Shader pass number to setup.
         * @returns If false is returned, no rendering should be done. 
         */
        SetPass(pass: number): boolean
        /** Copy properties from other material into this material.
         */
        CopyPropertiesFromMaterial(mat: Material): void
        /** Copies properties, keyword states and settings from mat to this material, but only if they exist in both materials.
         * @param mat The Material to copy from.
         */
        CopyMatchingPropertiesFromMaterial(mat: Material): void
        ComputeCRC(): number
        GetTexturePropertyNames(outNames: any): void
        GetTexturePropertyNames(): Array<string>
        GetTexturePropertyNameIDs(outNames: any): void
        GetTexturePropertyNameIDs(): Array<number>
        /** The shader used by the material.
         */
        shader: any
        /** The main color of the Material.
         */
        color: Color
        /** The main texture.
         */
        mainTexture: Texture
        /** The offset of the main texture.
         */
        mainTextureOffset: Vector2
        /** The scale of the main texture.
         */
        mainTextureScale: Vector2
        /** Render queue of this material.
         */
        renderQueue: number
        /** An array containing the local shader keywords that are currently enabled for this material.
         */
        enabledKeywords: Array<any>
        /** Defines how the material should interact with lightmaps and lightprobes.
         */
        globalIlluminationFlags: any
        /** Gets and sets whether the Double Sided Global Illumination setting is enabled for this material.
         */
        doubleSidedGI: boolean
        /** Gets and sets whether GPU instancing is enabled for this material.
         */
        enableInstancing: boolean
        /** How many passes are in this material (Read Only).
         */
        readonly passCount: number
        /** An array containing names of the local shader keywords that are currently enabled for this material.
         */
        shaderKeywords: Array<string>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** Provides an interface to get time information from Unity.
     */
    class Time extends Object1 {
        constructor()
        /** The time at the beginning of the current frame in seconds since the start of the application (Read Only).
         */
        static readonly time: number
        /** The double precision time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly timeAsDouble: number
        /** The time in seconds since the last non-additive scene finished loading (Read Only).
         */
        static readonly timeSinceLevelLoad: number
        /** The double precision time in seconds since the last non-additive scene finished loading (Read Only).
         */
        static readonly timeSinceLevelLoadAsDouble: number
        /** The interval in seconds from the last frame to the current one (Read Only).
         */
        static readonly deltaTime: number
        /** The time at which the current MonoBehaviour.FixedUpdate started in seconds since the start of the game (Read Only).
         */
        static readonly fixedTime: number
        /** The double precision time since the last MonoBehaviour.FixedUpdate started (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly fixedTimeAsDouble: number
        /** The timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly unscaledTime: number
        /** The double precision timeScale-independent time for this frame (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly unscaledTimeAsDouble: number
        /** The timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate phase (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly fixedUnscaledTime: number
        /** The double precision timeScale-independent time at the beginning of the last MonoBehaviour.FixedUpdate (Read Only). This is the time in seconds since the start of the game.
         */
        static readonly fixedUnscaledTimeAsDouble: number
        /** The timeScale-independent interval in seconds from the last frame to the current one (Read Only).
         */
        static readonly unscaledDeltaTime: number
        /** The interval in seconds of timeScale-independent ("real") time at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.(Read Only).
         */
        static readonly fixedUnscaledDeltaTime: number
        /** The interval in seconds of in-game time at which physics and other fixed frame rate updates (like MonoBehaviour's MonoBehaviour.FixedUpdate) are performed.
         */
        static fixedDeltaTime: number
        /** The maximum value of Time.deltaTime in any given frame. This is a time in seconds that limits the increase of Time.time between two frames.
         */
        static maximumDeltaTime: number
        /** A smoothed out Time.deltaTime (Read Only).
         */
        static readonly smoothDeltaTime: number
        /** The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates.
         */
        static maximumParticleDeltaTime: number
        /** The scale at which time passes.
         */
        static timeScale: number
        /** The total number of frames since the start of the game (Read Only).
         */
        static readonly frameCount: number
        static readonly renderedFrameCount: number
        /** The real time in seconds since the game started (Read Only).
         */
        static readonly realtimeSinceStartup: number
        /** The real time in seconds since the game started (Read Only). Double precision version of Time.realtimeSinceStartup. 
         */
        static readonly realtimeSinceStartupAsDouble: number
        /** Slows your application’s playback time to allow Unity to save screenshots in between frames.
         */
        static captureDeltaTime: number
        /** The reciprocal of Time.captureDeltaTime.
         */
        static captureFramerate: number
        /** Returns true if called inside a fixed time step callback (like MonoBehaviour's MonoBehaviour.FixedUpdate), otherwise returns false (Read Only).
         */
        static readonly inFixedTimeStep: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, ValueType } from "System";
    /** Easily generate random data for games.
     */
    abstract class Random extends Object1 {
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number, valueMin: number, valueMax: number, alphaMin: number, alphaMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number, valueMin: number, valueMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
         */
        static ColorHSV(hueMin: number, hueMax: number, saturationMin: number, saturationMax: number): Color
        /** Generates a random color from HSV and alpha ranges.
         * @param hueMin Minimum hue [0..1].
         * @param hueMax Maximum hue [0..1].
         * @param saturationMin Minimum saturation [0..1].
         * @param saturationMax Maximum saturation [0..1].
         * @param valueMin Minimum value [0..1].
         * @param valueMax Maximum value [0..1].
         * @param alphaMin Minimum alpha [0..1].
         * @param alphaMax Maximum alpha [0..1].
         * @returns A random color with HSV and alpha values in the (inclusive) input ranges. Values for each component are derived via linear interpolation of value. 
         */
        static ColorHSV(hueMin: number, hueMax: number): Color
        static ColorHSV(): Color
        /** Initializes the random number generator state with a seed.
         * @param seed Seed used to initialize the random number generator.
         */
        static InitState(seed: number): void
        /** Returns a random float within [minInclusive..maxInclusive] (range is inclusive).
         */
        static Range(minInclusive: number, maxInclusive: number): number
        /** Return a random int within [minInclusive..maxExclusive) (Read Only).
         */
        static Range(minInclusive: number, maxExclusive: number): number
        /** Gets or sets the full internal state of the random number generator.
         */
        static state: any
        /** Returns a random float within [0.0..1.0] (range is inclusive) (Read Only).
         */
        static readonly value: number
        /** Returns a random point inside or on a sphere with radius 1.0 (Read Only).
         */
        static readonly insideUnitSphere: Vector3
        /** Returns a random point inside or on a circle with radius 1.0 (Read Only).
         */
        static readonly insideUnitCircle: Vector2
        /** Returns a random point on the surface of a sphere with radius 1.0 (Read Only).
         */
        static readonly onUnitSphere: Vector3
        /** Returns a random rotation (Read Only).
         */
        static readonly rotation: Quaternion
        /** Returns a random rotation with uniform distribution (Read Only).
         */
        static readonly rotationUniform: Quaternion
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1, Array, Enum } from "System";
    /** Base class for all entities in Unity Scenes.
     */
    class GameObject extends Object {
        constructor(name: string)
        constructor(name: string, ...components: any[])
        constructor()
        /** The non-generic version of this method.
         * @param type The type of Component to search for.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponent<T extends Component>(type: { new(): T }): T
        /** The string-based version of this method.
         * @param type The name of the type of Component to search for.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponent(type: string): Component
        /** This is the non-generic version of this method.
         * @param type The type of Component to retrieve.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T
        /** This is the non-generic version of this method.
         * @param type The type of Component to retrieve.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns A component of the matching type, if found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }): T
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInParent(type: any, includeInactive: boolean): Component
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInParent<T extends Component>(type: { new(): T }): T
        GetComponents(type: any, results: any): void
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @returns An array containing all matching components of type type. 
         */
        GetComponents<T extends Component>(type: { new(): T }): T[]
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns An array of all found components matching the specified type. 
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns An array of all found components matching the specified type. 
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }): T[]
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns An array of all found components matching the specified type. 
         */
        GetComponentsInParent<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInParent<T extends Component>(type: { new(): T }): T[]
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise. 
         */
        TryGetComponent(type: any, component: jsb.Out<Component>): boolean
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1, options: any): void
        SendMessageUpwards(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessageUpwards(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string, value: Object1, options: any): void
        SendMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName The name of the method to call.
         * @param value An optional parameter value to pass to the called method.
         * @param options Should an error be raised if the method doesn't exist on the target object?
         */
        SendMessage(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string, parameter: Object1, options: any): void
        BroadcastMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string, parameter: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         */
        BroadcastMessage(methodName: string): void
        /** Adds a component class of type componentType to the game object. C# Users can use a generic version.
         */
        AddComponent<T extends Component>(type: { new(): T }): T
        /** ActivatesDeactivates the GameObject, depending on the given true or false/ value.
         * @param value Activate or deactivate the object, where true activates the GameObject and false deactivates the GameObject.
         */
        SetActive(value: boolean): void
        /** Is this game object tagged with tag ?
         * @param tag The tag to compare.
         */
        CompareTag(tag: string): boolean
        /** Creates a game object with a primitive mesh renderer and appropriate collider.
         * @param type The type of primitive object to create.
         */
        static CreatePrimitive(type: PrimitiveType): GameObject
        /** Returns one active GameObject tagged tag. Returns null if no GameObject was found.
         * @param tag The tag to search for.
         */
        static FindWithTag(tag: string): GameObject
        static FindGameObjectWithTag(tag: string): GameObject
        /** Returns an array of active GameObjects tagged tag. Returns empty array if no GameObject was found.
         * @param tag The name of the tag to search GameObjects for.
         */
        static FindGameObjectsWithTag(tag: string): Array<GameObject>
        /** Finds a GameObject by name and returns it.
         */
        static Find(name: string): GameObject
        /** The Transform attached to this GameObject.
         */
        readonly transform: Transform
        /** The layer the GameObject is in.
         */
        layer: number
        /** The local active state of this GameObject. (Read Only)
         */
        readonly activeSelf: boolean
        /** Defines whether the GameObject is active in the Scene.
         */
        readonly activeInHierarchy: boolean
        /** Gets and sets the GameObject's StaticEditorFlags.
         */
        isStatic: boolean
        /** The tag of this game object.
         */
        tag: string
        /** Scene that the GameObject is part of.
         */
        readonly scene: any
        /** Scene culling mask Unity uses to determine which scene to render the GameObject in.
         */
        readonly sceneCullingMask: number
        readonly gameObject: GameObject
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, ValueType, Object as Object1 } from "System";
    /** A Camera is a device through which the player views the world.
     */
    class Camera extends Behaviour {
        constructor()
        Reset(): void
        ResetTransparencySortSettings(): void
        ResetAspect(): void
        ResetCullingMatrix(): void
        /** Make the camera render with shader replacement.
         */
        SetReplacementShader(shader: any, replacementTag: string): void
        ResetReplacementShader(): void
        GetGateFittedFieldOfView(): number
        GetGateFittedLensShift(): Vector2
        /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        SetTargetBuffers(colorBuffer: any, depthBuffer: any): void
        /** Sets the Camera to render to the chosen buffers of one or more RenderTextures.
         * @param colorBuffer The RenderBuffer(s) to which color information will be rendered.
         * @param depthBuffer The RenderBuffer to which depth information will be rendered.
         */
        SetTargetBuffers(colorBuffer: Array<any>, depthBuffer: any): void
        ResetWorldToCameraMatrix(): void
        ResetProjectionMatrix(): void
        /** Calculates and returns oblique near-plane projection matrix.
         * @param clipPlane Vector4 that describes a clip plane.
         * @returns Oblique near-plane projection matrix. 
         */
        CalculateObliqueMatrix(clipPlane: Vector4): Matrix4x4
        WorldToScreenPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from world space into screen space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        WorldToScreenPoint(position: Vector3): Vector3
        WorldToViewportPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from world space into viewport space.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        WorldToViewportPoint(position: Vector3): Vector3
        ViewportToWorldPoint(position: Vector3, eye: any): Vector3
        /** Transforms position from viewport space into world space.
         * @param position The 3d vector in Viewport space.
         * @returns The 3d vector in World space. 
         */
        ViewportToWorldPoint(position: Vector3): Vector3
        ScreenToWorldPoint(position: Vector3, eye: any): Vector3
        /** Transforms a point from screen space into world space, where world space is defined as the coordinate system at the very top of your game's hierarchy.
         * @param position A screen space position (often mouse x, y), plus a z position for depth (for example, a camera clipping plane).
         * @param eye By default, Camera.MonoOrStereoscopicEye.Mono. Can be set to Camera.MonoOrStereoscopicEye.Left or Camera.MonoOrStereoscopicEye.Right for use in stereoscopic rendering (e.g., for VR).
         * @returns The worldspace point created by converting the screen space point at the provided distance z from the camera plane. 
         */
        ScreenToWorldPoint(position: Vector3): Vector3
        /** Transforms position from screen space into viewport space.
         */
        ScreenToViewportPoint(position: Vector3): Vector3
        /** Transforms position from viewport space into screen space.
         */
        ViewportToScreenPoint(position: Vector3): Vector3
        ViewportPointToRay(pos: Vector3, eye: any): Ray
        /** Returns a ray going from camera through a viewport point.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        ViewportPointToRay(pos: Vector3): Ray
        ScreenPointToRay(pos: Vector3, eye: any): Ray
        /** Returns a ray going from camera through a screen point.
         * @param pos A 3D point, with the x and y coordinates containing a 2D screenspace point in pixels. The lower left pixel of the screen is (0,0). The upper right pixel of the screen is (screen width in pixels - 1, screen height in pixels - 1). Unity ignores the z coordinate.
         * @param eye Optional argument that can be used to specify which eye transform to use. Default is Mono.
         */
        ScreenPointToRay(pos: Vector3): Ray
        CalculateFrustumCorners(viewport: Rect, z: number, eye: any, outCorners: Array<Vector3>): void
        GetStereoNonJitteredProjectionMatrix(eye: any): Matrix4x4
        GetStereoViewMatrix(eye: any): Matrix4x4
        CopyStereoDeviceProjectionMatrixToNonJittered(eye: any): void
        GetStereoProjectionMatrix(eye: any): Matrix4x4
        SetStereoProjectionMatrix(eye: any, matrix: Matrix4x4): void
        ResetStereoProjectionMatrices(): void
        SetStereoViewMatrix(eye: any, matrix: Matrix4x4): void
        ResetStereoViewMatrices(): void
        RenderToCubemap(cubemap: any, faceMask: number, stereoEye: any): boolean
        /** Render into a static cubemap from this camera.
         * @param cubemap The cube map to render to.
         * @param faceMask A bitmask which determines which of the six faces are rendered to.
         * @returns False if rendering fails, else true. 
         */
        RenderToCubemap(cubemap: any, faceMask: number): boolean
        /** Render into a cubemap from this camera.
         * @param faceMask A bitfield indicating which cubemap faces should be rendered into.
         * @param cubemap The texture to render to.
         * @returns False if rendering fails, else true. 
         */
        RenderToCubemap(cubemap: any, faceMask: number): boolean
        RenderToCubemap(cubemap: any): boolean
        RenderToCubemap(cubemap: any): boolean
        Render(): void
        /** Render the camera with shader replacement.
         */
        RenderWithShader(shader: any, replacementTag: string): void
        RenderDontRestore(): void
        SubmitRenderRequests(renderRequests: any): void
        /** Makes this camera's settings match other camera.
         * @param other Copy camera settings to the other camera.
         */
        CopyFrom(other: Camera): void
        /** Remove command buffers from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         */
        RemoveCommandBuffers(evt: any): void
        RemoveAllCommandBuffers(): void
        /** Add a command buffer to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        AddCommandBuffer(evt: any, buffer: any): void
        /** Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point.
         * @param evt The point during the graphics processing at which this command buffer should commence on the GPU.
         * @param buffer The buffer to execute.
         * @param queueType The desired async compute queue type to execute the buffer on.
         */
        AddCommandBufferAsync(evt: any, buffer: any, queueType: any): void
        /** Remove command buffer from execution at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @param buffer The buffer to execute.
         */
        RemoveCommandBuffer(evt: any, buffer: any): void
        /** Get command buffers to be executed at a specified place.
         * @param evt When to execute the command buffer during rendering.
         * @returns Array of command buffers. 
         */
        GetCommandBuffers(evt: any): Array<any>
        /** Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid. 
         */
        TryGetCullingParameters(stereoAware: boolean, cullingParameters: jsb.Out<any>): boolean
        /** Get culling parameters for a camera.
         * @param cullingParameters Resultant culling parameters.
         * @param stereoAware Generate single-pass stereo aware culling parameters.
         * @returns Flag indicating whether culling parameters are valid. 
         */
        TryGetCullingParameters(cullingParameters: jsb.Out<any>): boolean
        static CalculateProjectionMatrixFromPhysicalProperties(output: jsb.Out<Matrix4x4>, focalLength: number, sensorSize: Vector2, lensShift: Vector2, nearClip: number, farClip: number, gateFitParameters: any): void
        /** Converts focal length to field of view.
         * @param focalLength Focal length in millimeters.
         * @param sensorSize Sensor size in millimeters. Use the sensor height to get the vertical field of view. Use the sensor width to get the horizontal field of view.
         * @returns field of view in degrees. 
         */
        static FocalLengthToFieldOfView(focalLength: number, sensorSize: number): number
        /** Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view.
         * @param fieldOfView field of view in degrees.
         * @param sensorSize Sensor size in millimeters.
         * @returns Focal length in millimeters. 
         */
        static FieldOfViewToFocalLength(fieldOfView: number, sensorSize: number): number
        /** Converts the horizontal field of view (FOV) to the vertical FOV, based on the value of the aspect ratio parameter.
         * @param horizontalFOV The horizontal FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        static HorizontalToVerticalFieldOfView(horizontalFieldOfView: number, aspectRatio: number): number
        /** Converts the vertical field of view (FOV) to the horizontal FOV, based on the value of the aspect ratio parameter.
         * @param verticalFieldOfView The vertical FOV value in degrees.
         * @param aspectRatio The aspect ratio value used for the conversion
         */
        static VerticalToHorizontalFieldOfView(verticalFieldOfView: number, aspectRatio: number): number
        /** Fills an array of Camera with the current cameras in the Scene, without allocating a new array.
         * @param cameras An array to be filled up with cameras currently in the Scene.
         */
        static GetAllCameras(cameras: Array<Camera>): number
        static SetupCurrent(cur: Camera): void
        /** The distance of the near clipping plane from the the Camera, in world units.
         */
        nearClipPlane: number
        /** The distance of the far clipping plane from the Camera, in world units.
         */
        farClipPlane: number
        /** The vertical field of view of the Camera, in degrees.
         */
        fieldOfView: number
        /** The rendering path that should be used, if possible.
         */
        renderingPath: any
        /** The rendering path that is currently being used (Read Only).
         */
        readonly actualRenderingPath: any
        /** High dynamic range rendering.
         */
        allowHDR: boolean
        /** MSAA rendering.
         */
        allowMSAA: boolean
        /** Dynamic Resolution Scaling.
         */
        allowDynamicResolution: boolean
        /** Should camera rendering be forced into a RenderTexture.
         */
        forceIntoRenderTexture: boolean
        /** Camera's half-size when in orthographic mode.
         */
        orthographicSize: number
        /** Is the camera orthographic (true) or perspective (false)?
         */
        orthographic: boolean
        /** Opaque object sorting mode.
         */
        opaqueSortMode: any
        /** Transparent object sorting mode.
         */
        transparencySortMode: any
        /** An axis that describes the direction along which the distances of objects are measured for the purpose of sorting.
         */
        transparencySortAxis: Vector3
        /** Camera's depth in the camera rendering order.
         */
        depth: number
        /** The aspect ratio (width divided by height).
         */
        aspect: number
        /** Get the world-space speed of the camera (Read Only).
         */
        readonly velocity: Vector3
        /** This is used to render parts of the Scene selectively.
         */
        cullingMask: number
        /** Mask to select which layers can trigger events on the camera.
         */
        eventMask: number
        /** How to perform per-layer culling for a Camera.
         */
        layerCullSpherical: boolean
        /** Identifies what kind of camera this is, using the CameraType enum.
         */
        cameraType: any
        /** Sets the culling mask used to determine which objects from which Scenes to draw.
See EditorSceneManager.SetSceneCullingMask.
         */
        overrideSceneCullingMask: number
        /** Per-layer culling distances.
         */
        layerCullDistances: Array<number>
        /** Whether or not the Camera will use occlusion culling during rendering.
         */
        useOcclusionCulling: boolean
        /** Sets a custom matrix for the camera to use for all culling queries.
         */
        cullingMatrix: Matrix4x4
        /** The color with which the screen will be cleared.
         */
        backgroundColor: Color
        /** How the camera clears the background.
         */
        clearFlags: any
        /** How and if camera generates a depth texture.
         */
        depthTextureMode: any
        /** Should the camera clear the stencil buffer after the deferred light pass?
         */
        clearStencilAfterLightingPass: boolean
        /** Enable usePhysicalProperties to use physical camera properties to compute the field of view and the frustum.
         */
        usePhysicalProperties: boolean
        /** The size of the camera sensor, expressed in millimeters.
         */
        sensorSize: Vector2
        /** The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
         */
        lensShift: Vector2
        /** The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties.
         */
        focalLength: number
        /** There are two gates for a camera, the sensor gate and the resolution gate. The physical camera sensor gate is defined by the sensorSize property, the resolution gate is defined by the render target area.
         */
        gateFit: any
        /** Where on the screen is the camera rendered in normalized coordinates.
         */
        rect: Rect
        /** Where on the screen is the camera rendered in pixel coordinates.
         */
        pixelRect: Rect
        /** How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        readonly pixelWidth: number
        /** How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only).
         */
        readonly pixelHeight: number
        /** How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        readonly scaledPixelWidth: number
        /** How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only).
         */
        readonly scaledPixelHeight: number
        /** Destination render texture.
         */
        targetTexture: any
        /** Gets the temporary RenderTexture target for this Camera.
         */
        readonly activeTexture: any
        /** Set the target display for this Camera.
         */
        targetDisplay: number
        /** Matrix that transforms from camera space to world space (Read Only).
         */
        readonly cameraToWorldMatrix: Matrix4x4
        /** Matrix that transforms from world to camera space.
         */
        worldToCameraMatrix: Matrix4x4
        /** Set a custom projection matrix.
         */
        projectionMatrix: Matrix4x4
        /** Get or set the raw projection matrix with no camera offset (no jittering).
         */
        nonJitteredProjectionMatrix: Matrix4x4
        /** Should the jittered matrix be used for transparency rendering?
         */
        useJitteredProjectionMatrixForTransparentRendering: boolean
        /** Get the view projection matrix used on the last frame.
         */
        readonly previousViewProjectionMatrix: Matrix4x4
        /** The first enabled Camera component that is tagged "MainCamera" (Read Only).
         */
        static readonly main: Camera
        /** The camera we are currently rendering with, for low-level render control only (Read Only).
         */
        static readonly current: Camera
        /** If not null, the camera will only render the contents of the specified Scene.
         */
        scene: any
        /** Stereoscopic rendering.
         */
        readonly stereoEnabled: boolean
        /** The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect.
         */
        stereoSeparation: number
        /** Distance to a point where virtual eyes converge.
         */
        stereoConvergence: number
        /** Determines whether the stereo view matrices are suitable to allow for a single pass cull.
         */
        readonly areVRStereoViewMatricesWithinSingleCullTolerance: boolean
        /** Defines which eye of a VR display the Camera renders into.
         */
        stereoTargetEye: any
        /** Returns the eye that is currently rendering.
If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.

If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.

If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left.
         */
        readonly stereoActiveEye: any
        /** The number of cameras in the current Scene.
         */
        static readonly allCamerasCount: number
        /** Returns all enabled cameras in the Scene.
         */
        static readonly allCameras: Array<Camera>
        readonly sceneViewFilterMode: any
        /** Number of command buffers set up on this camera (Read Only).
         */
        readonly commandBufferCount: number
        static onPreCull(op: "get"): (cam: Camera) => void
        static onPreCull(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPreCull(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
        static onPreRender(op: "get"): (cam: Camera) => void
        static onPreRender(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPreRender(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
        static onPostRender(op: "get"): (cam: Camera) => void
        static onPostRender(op: "add" | "remove" | "set", fn?: (cam: Camera) => void): void
        static onPostRender(op: "add" | "remove" | "set" | "get", fn?: (cam: Camera) => void): (cam: Camera) => void | void
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Behaviours are Components that can be enabled or disabled.
     */
    class Behaviour extends Component {
        constructor()
        /** Enabled Behaviours are Updated, disabled Behaviours are not.
         */
        enabled: boolean
        /** Reports whether a GameObject and its associated Behaviour is active and enabled.
         */
        readonly isActiveAndEnabled: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    /** Base class for everything attached to a GameObject.
     */
    class Component extends Object {
        constructor()
        /** The non-generic version of this method.
         * @param type The type of Component to retrieve.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponent<T extends Component>(type: { new(): T }): T
        /** The string-based version of this method.
         * @param type The name of the type of Component to get.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponent(type: string): Component
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @param component The output argument that will contain the component or null.
         * @returns Returns true if the component is found, false otherwise. 
         */
        TryGetComponent(type: any, component: jsb.Out<Component>): boolean
        /** This is the non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T
        /** This is the non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInChildren<T extends Component>(type: { new(): T }): T
        /** The non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive child GameObjects in the search.
         * @returns An array of all found components matching the specified type. 
         */
        GetComponentsInChildren<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInChildren<T extends Component>(type: { new(): T }): T[]
        /** The non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInParent(t: any, includeInactive: boolean): Component
        /** The non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns A Component of the matching type, otherwise null if no Component is found. 
         */
        GetComponentInParent<T extends Component>(type: { new(): T }): T
        /** The non-generic version of this method.
         * @param t The type of component to search for.
         * @param includeInactive Whether to include inactive parent GameObjects in the search.
         * @returns An array of all found components matching the specified type. 
         */
        GetComponentsInParent<T extends Component>(type: { new(): T }, includeInactive: boolean): T[]
        GetComponentsInParent<T extends Component>(type: { new(): T }): T[]
        GetComponents(type: any, results: any): void
        /** The non-generic version of this method.
         * @param type The type of component to search for.
         * @returns An array containing all matching components of type type. 
         */
        GetComponents<T extends Component>(type: { new(): T }): T[]
        /** Checks the GameObject's tag against the defined tag.
         * @param tag The tag to compare.
         * @returns Returns true if GameObject has same tag. Returns false otherwise. 
         */
        CompareTag(tag: string): boolean
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour.
         * @param methodName Name of method to call.
         * @param value Optional parameter value for the method.
         * @param options Should an error be raised if the method does not exist on the target object?
         */
        SendMessageUpwards(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, value: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, value: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object.
         * @param methodName Name of the method to call.
         * @param value Optional parameter for the method.
         * @param options Should an error be raised if the target object doesn't implement the method for the message?
         */
        SendMessage(methodName: string): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, parameter: Object1, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, parameter: Object1): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string, options: any): void
        /** Calls the method named methodName on every MonoBehaviour in this game object or any of its children.
         * @param methodName Name of the method to call.
         * @param parameter Optional parameter to pass to the method (can be any value).
         * @param options Should an error be raised if the method does not exist for a given target object?
         */
        BroadcastMessage(methodName: string): void
        /** The Transform attached to this GameObject.
         */
        readonly transform: Transform
        /** The game object this component is attached to. A component is always attached to a game object.
         */
        readonly gameObject: GameObject
        /** The tag of this game object.
         */
        tag: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Object as Object1 } from "System";
    import { IEnumerator } from "System.Collections";
    /** Position, rotation and scale of an object.
     */
    class Transform extends Component {
        /** Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        SetParent(parent: Transform, worldPositionStays: boolean): void
        /** Set the parent of the transform.
         * @param parent The parent Transform to use.
         * @param worldPositionStays If true, the parent-relative position, scale and rotation are modified such that the object keeps the same world space position, rotation and scale as before.
         */
        SetParent(p: Transform): void
        /** Sets the world space position and rotation of the Transform component.
         */
        SetPositionAndRotation(position: Vector3, rotation: Quaternion): void
        /** Sets the position and rotation of the Transform component in local space (i.e. relative to its parent transform).
         */
        SetLocalPositionAndRotation(localPosition: Vector3, localRotation: Quaternion): void
        /** Gets the position and rotation of the Transform component in world space.
         */
        GetPositionAndRotation(position: jsb.Out<Vector3>, rotation: jsb.Out<Quaternion>): void
        /** Gets the position and rotation of the Transform component in local space (that is, relative to its parent transform).
         */
        GetLocalPositionAndRotation(localPosition: jsb.Out<Vector3>, localRotation: jsb.Out<Quaternion>): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number, relativeTo: any): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number, relativeTo: Transform): void
        /** Moves the transform by x along the x axis, y along the y axis, and z along the z axis.
         */
        Translate(x: number, y: number, z: number): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3, relativeTo: any): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3, relativeTo: Transform): void
        /** Moves the transform in the direction and distance of translation.
         */
        Translate(translation: Vector3): void
        /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        Rotate(xAngle: number, yAngle: number, zAngle: number, relativeTo: any): void
        /** The implementation of this method applies a rotation of zAngle degrees around the z axis, xAngle degrees around the x axis, and yAngle degrees around the y axis (in that order).
         * @param xAngle Degrees to rotate the GameObject around the X axis.
         * @param yAngle Degrees to rotate the GameObject around the Y axis.
         * @param zAngle Degrees to rotate the GameObject around the Z axis.
         */
        Rotate(xAngle: number, yAngle: number, zAngle: number): void
        /** Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param angle The degrees of rotation to apply.
         * @param axis The axis to apply rotation to.
         * @param relativeTo Determines whether to rotate the GameObject either locally to the GameObject or relative to the Scene in world space.
         */
        Rotate(axis: Vector3, angle: number, relativeTo: any): void
        /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         * @param relativeTo Determines whether to rotate the GameObject either locally to  the GameObject or relative to the Scene in world space.
         */
        Rotate(eulers: Vector3, relativeTo: any): void
        /** Rotates the object around the given axis by the number of degrees defined by the given angle.
         * @param axis The axis to apply rotation to.
         * @param angle The degrees of rotation to apply.
         */
        Rotate(axis: Vector3, angle: number): void
        /** Applies a rotation of eulerAngles.z degrees around the z-axis, eulerAngles.x degrees around the x-axis, and eulerAngles.y degrees around the y-axis (in that order).
         * @param eulers The rotation to apply in euler angles.
         */
        Rotate(eulers: Vector3): void
        /** Rotates the transform about axis passing through point in world coordinates by angle degrees.
         */
        RotateAround(point: Vector3, axis: Vector3, angle: number): void
        /** Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(target: Transform, worldUp: Vector3): void
        /** Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(worldPosition: Vector3, worldUp: Vector3): void
        /** Rotates the transform so the forward vector points at target's current position.
         * @param target Object to point towards.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(target: Transform): void
        /** Rotates the transform so the forward vector points at worldPosition.
         * @param worldPosition Point to look at.
         * @param worldUp Vector specifying the upward direction.
         */
        LookAt(worldPosition: Vector3): void
        /** Transforms direction x, y, z from local space to world space.
         */
        TransformDirection(x: number, y: number, z: number): Vector3
        /** Transforms direction from local space to world space.
         */
        TransformDirection(direction: Vector3): Vector3
        /** Transforms the direction x, y, z from world space to local space. The opposite of Transform.TransformDirection.
         */
        InverseTransformDirection(x: number, y: number, z: number): Vector3
        /** Transforms a direction from world space to local space. The opposite of Transform.TransformDirection.
         */
        InverseTransformDirection(direction: Vector3): Vector3
        /** Transforms vector x, y, z from local space to world space.
         */
        TransformVector(x: number, y: number, z: number): Vector3
        /** Transforms vector from local space to world space.
         */
        TransformVector(vector: Vector3): Vector3
        /** Transforms the vector x, y, z from world space to local space. The opposite of Transform.TransformVector.
         */
        InverseTransformVector(x: number, y: number, z: number): Vector3
        /** Transforms a vector from world space to local space. The opposite of Transform.TransformVector.
         */
        InverseTransformVector(vector: Vector3): Vector3
        /** Transforms the position x, y, z from local space to world space.
         */
        TransformPoint(x: number, y: number, z: number): Vector3
        /** Transforms position from local space to world space.
         */
        TransformPoint(position: Vector3): Vector3
        /** Transforms the position x, y, z from world space to local space. The opposite of Transform.TransformPoint.
         */
        InverseTransformPoint(x: number, y: number, z: number): Vector3
        /** Transforms position from world space to local space.
         */
        InverseTransformPoint(position: Vector3): Vector3
        DetachChildren(): void
        SetAsFirstSibling(): void
        SetAsLastSibling(): void
        /** Sets the sibling index.
         * @param index Index to set.
         */
        SetSiblingIndex(index: number): void
        GetSiblingIndex(): number
        /** Finds a child by name n and returns it.
         * @param n Name of child to be found.
         * @returns The found child transform. Null if child with matching name isn't found. 
         */
        Find(n: string): Transform
        /** Is this transform a child of parent?
         */
        IsChildOf(parent: Transform): boolean
        GetEnumerator(): IEnumerator
        /** Returns a transform child by index.
         * @param index Index of the child transform to return. Must be smaller than Transform.childCount.
         * @returns Transform child by index. 
         */
        GetChild(index: number): Transform
        ResetAll(): void
        TestWithArgs(pos: Vector3, rot: Quaternion, scale: Vector3): void
        TestWithArgsAndOut(pos: Vector3, rot: Quaternion, scale: Vector3, dist: jsb.Out<number>): boolean
        TestWithScriptObject(function_: any): void
        /*protected*/ constructor()
        /** The world space position of the Transform.
         */
        position: Vector3
        /** Position of the transform relative to the parent transform.
         */
        localPosition: Vector3
        /** The rotation as Euler angles in degrees.
         */
        eulerAngles: Vector3
        /** The rotation as Euler angles in degrees relative to the parent transform's rotation.
         */
        localEulerAngles: Vector3
        /** The red axis of the transform in world space.
         */
        right: Vector3
        /** The green axis of the transform in world space.
         */
        up: Vector3
        /** Returns a normalized vector representing the blue axis of the transform in world space.
         */
        forward: Vector3
        /** A Quaternion that stores the rotation of the Transform in world space.
         */
        rotation: Quaternion
        /** The rotation of the transform relative to the transform rotation of the parent.
         */
        localRotation: Quaternion
        /** The scale of the transform relative to the GameObjects parent.
         */
        localScale: Vector3
        /** The parent of the transform.
         */
        parent: Transform
        /** Matrix that transforms a point from world space into local space (Read Only).
         */
        readonly worldToLocalMatrix: Matrix4x4
        /** Matrix that transforms a point from local space into world space (Read Only).
         */
        readonly localToWorldMatrix: Matrix4x4
        /** Returns the topmost transform in the hierarchy.
         */
        readonly root: Transform
        /** The number of children the parent Transform has.
         */
        readonly childCount: number
        /** The global scale of the object (Read Only).
         */
        readonly lossyScale: Vector3
        /** Has the transform changed since the last time the flag was set to 'false'?
         */
        hasChanged: boolean
        /** The transform capacity of the transform's hierarchy data structure.
         */
        hierarchyCapacity: number
        /** The number of transforms in the transform's hierarchy data structure.
         */
        readonly hierarchyCount: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Enum } from "System";
    /** Position, size, anchor and pivot information for a rectangle.
     */
    class RectTransform extends Transform {
        constructor()
        ForceUpdateRectTransforms(): void
        /** Get the corners of the calculated rectangle in the local space of its Transform.
         * @param fourCornersArray The array that corners are filled into.
         */
        GetLocalCorners(fourCornersArray: Array<Vector3>): void
        /** Get the corners of the calculated rectangle in world space.
         * @param fourCornersArray The array that corners are filled into.
         */
        GetWorldCorners(fourCornersArray: Array<Vector3>): void
        SetInsetAndSizeFromParentEdge(edge: any, inset: number, size: number): void
        SetSizeWithCurrentAnchors(axis: any, size: number): void
        /** The calculated rectangle in the local space of the Transform.
         */
        readonly rect: Rect
        /** The normalized position in the parent RectTransform that the lower left corner is anchored to.
         */
        anchorMin: Vector2
        /** The normalized position in the parent RectTransform that the upper right corner is anchored to.
         */
        anchorMax: Vector2
        /** The position of the pivot of this RectTransform relative to the anchor reference point.
         */
        anchoredPosition: Vector2
        /** The size of this RectTransform relative to the distances between the anchors.
         */
        sizeDelta: Vector2
        /** The normalized position in this RectTransform that it rotates around.
         */
        pivot: Vector2
        /** The 3D position of the pivot of this RectTransform relative to the anchor reference point.
         */
        anchoredPosition3D: Vector3
        /** The offset of the lower left corner of the rectangle relative to the lower left anchor.
         */
        offsetMin: Vector2
        /** The offset of the upper right corner of the rectangle relative to the upper right anchor.
         */
        offsetMax: Vector2
        /** The object that is driving the values of this RectTransform. Value is null if not driven.
         */
        readonly drivenByObject: Object
        static reapplyDrivenProperties(op: "add" | "remove", fn: (driven: RectTransform) => void): void
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    import { IEnumerator } from "System.Collections";
    /** MonoBehaviour is the base class from which every Unity script derives.
     */
    class MonoBehaviour extends Behaviour {
        constructor()
        /** Is any invoke on methodName pending?
         */
        IsInvoking(methodName: string): boolean
        IsInvoking(): boolean
        /** Cancels all Invoke calls with name methodName on this behaviour.
         */
        CancelInvoke(methodName: string): void
        CancelInvoke(): void
        /** Invokes the method methodName in time seconds.
         */
        Invoke(methodName: string, time: number): void
        /** Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds.
         */
        InvokeRepeating(methodName: string, time: number, repeatRate: number): void
        /** Starts a coroutine named methodName.
         */
        StartCoroutine(methodName: string, value: Object1): Coroutine
        /** Starts a coroutine named methodName.
         */
        StartCoroutine(methodName: string): Coroutine
        /** Starts a Coroutine.
         */
        StartCoroutine(routine: IEnumerator): Coroutine
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(routine: IEnumerator): void
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(routine: Coroutine): void
        /** Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour.
         * @param methodName Name of coroutine.
         * @param routine Name of the function in code, including coroutines.
         */
        StopCoroutine(methodName: string): void
        StopAllCoroutines(): void
        /** Logs message to the Unity Console (identical to Debug.Log).
         */
        static print(message: Object1): void
        /** Disabling this lets you skip the GUI layout phase.
         */
        useGUILayout: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** A class you can derive from if you want to create objects that live independently of GameObjects.
     */
    class ScriptableObject extends Object {
        constructor()
        /** Creates an instance of a scriptable object.
         * @param className The type of the ScriptableObject to create, as the name of the type.
         * @param type The type of the ScriptableObject to create, as a System.Type instance.
         * @returns The created ScriptableObject. 
         */
        static CreateInstance<T extends ScriptableObject>(type: { new(): T }): T
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    /** Represents a Sprite object for use in 2D gameplay.
     */
    class Sprite extends Object {
        GetPhysicsShapeCount(): number
        /** The number of points in the selected physics shape for the Sprite.
         * @param shapeIdx The index of the physics shape to retrieve the number of points from.
         * @returns The number of points in the selected physics shape for the Sprite. 
         */
        GetPhysicsShapePointCount(shapeIdx: number): number
        GetPhysicsShape(shapeIdx: number, physicsShape: any): number
        OverridePhysicsShape(physicsShapes: any): void
        /** Sets up new Sprite geometry.
         * @param vertices Array of vertex positions in Sprite Rect space.
         * @param triangles Array of sprite mesh triangle indices.
         */
        OverrideGeometry(vertices: Array<Vector2>, triangles: Array<number>): void
        /** Returns a list of SpriteBone in this Sprite.
         * @param sprite The sprite to get the list of SpriteBone from.
         * @returns An array of SpriteBone that belongs to this Sprite. 
         */
        GetBones(): Array<any>
        /** Sets the SpriteBones for this Sprite.
         */
        SetBones(src: Array<any>): void
        /** Checks if a specific channel exists for this Sprite.
         * @returns True if the channel exists. 
         */
        HasVertexAttribute(channel: any): boolean
        /** Sets the vertex count. This resizes the internal buffer. It also preserves any configurations of VertexAttributes.
         */
        SetVertexCount(count: number): void
        /** Returns the number of vertices in this Sprite.
         */
        GetVertexCount(): number
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any, border: Vector4, generateFallbackPhysicsShape: boolean): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any, border: Vector4): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number, meshType: any): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number, extrude: number): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2, pixelsPerUnit: number): Sprite
        /** Create a new Sprite object.
         * @param texture Texture from which to obtain the sprite graphic.
         * @param rect Rectangular section of the texture to use for the sprite.
         * @param pivot Sprite's pivot point relative to its graphic rectangle.
         * @param pixelsPerUnit The number of pixels in the sprite that correspond to one unit in world space.
         * @param extrude Amount by which the sprite mesh should be expanded outwards.
         * @param meshType Controls the type of mesh generated for the sprite.
         * @param border The border sizes of the sprite (X=left, Y=bottom, Z=right, W=top).
         * @param generateFallbackPhysicsShape Generates a default physics shape for the sprite.
         */
        static Create(texture: Texture2D, rect: Rect, pivot: Vector2): Sprite
        protected constructor()
        /** Bounds of the Sprite, specified by its center and extents in world space units.
         */
        readonly bounds: Bounds
        /** Location of the Sprite on the original Texture, specified in pixels.
         */
        readonly rect: Rect
        /** Returns the border sizes of the sprite.
         */
        readonly border: Vector4
        /** Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite.
         */
        readonly texture: Texture2D
        /** The number of pixels in the sprite that correspond to one unit in world space. (Read Only)
         */
        readonly pixelsPerUnit: number
        /** The Variant scale of texture used by the Sprite. This is useful to check when a Variant SpriteAtlas is being used by Sprites.
         */
        readonly spriteAtlasTextureScale: number
        /** Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1.

Returns NULL if there is no associated alpha texture for the source sprite. This is the case if the sprite has not been setup to use ETC1 compression.
         */
        readonly associatedAlphaSplitTexture: Texture2D
        /** Location of the Sprite's center point in the Rect on the original Texture, specified in pixels.
         */
        readonly pivot: Vector2
        /** Returns true if this Sprite is packed in an atlas.
         */
        readonly packed: boolean
        /** If Sprite is packed (see Sprite.packed), returns its SpritePackingMode.
         */
        readonly packingMode: any
        /** If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation.
         */
        readonly packingRotation: any
        /** Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas.
         */
        readonly textureRect: Rect
        /** Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero.
         */
        readonly textureRectOffset: Vector2
        /** Returns a copy of the array containing sprite mesh vertex positions.
         */
        readonly vertices: Array<Vector2>
        /** Returns a copy of the array containing sprite mesh triangles.
         */
        readonly triangles: Array<number>
        /** The base texture coordinates of the sprite mesh.
         */
        readonly uv: Array<Vector2>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Renders a Sprite for 2D graphics.
     */
    class SpriteRenderer extends Renderer {
        constructor()
        RegisterSpriteChangeCallback(callback: (arg0: SpriteRenderer) => void): void
        UnregisterSpriteChangeCallback(callback: (arg0: SpriteRenderer) => void): void
        /** Stop using the deformable buffer to render the Sprite and use the original mesh instead.
         */
        DeactivateDeformableBuffer(): void
        /** The Sprite to render.
         */
        sprite: Sprite
        /** The current draw mode of the Sprite Renderer.
         */
        drawMode: any
        /** Property to set or get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced or SpriteDrawMode.Tiled.
         */
        size: Vector2
        /** The current threshold for Sprite Renderer tiling.
         */
        adaptiveModeThreshold: number
        /** The current tile mode of the Sprite Renderer.
         */
        tileMode: any
        /** Rendering color for the Sprite graphic.
         */
        color: Color
        /** Specifies how the sprite interacts with the masks.
         */
        maskInteraction: any
        /** Flips the sprite on the X axis.
         */
        flipX: boolean
        /** Flips the sprite on the Y axis.
         */
        flipY: boolean
        /** Determines the position of the Sprite used for sorting the SpriteRenderer.
         */
        spriteSortPoint: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    /** General functionality for all renderers.
     */
    class Renderer extends Component {
        constructor()
        ResetBounds(): void
        ResetLocalBounds(): void
        HasPropertyBlock(): boolean
        /** Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        SetPropertyBlock(properties: any, materialIndex: number): void
        /** Lets you set or clear per-renderer or per-material parameter overrides.
         * @param properties Property block with values you want to override.
         * @param materialIndex The index of the Material you want to override the parameters of. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        SetPropertyBlock(properties: any): void
        /** Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        GetPropertyBlock(properties: any, materialIndex: number): void
        /** Get per-Renderer or per-Material property block.
         * @param properties Material parameters to retrieve.
         * @param materialIndex The index of the Material you want to get overridden parameters from. The index ranges from 0 to Renderer.sharedMaterials.Length-1.
         */
        GetPropertyBlock(properties: any): void
        GetMaterials(m: any): void
        GetSharedMaterials(m: any): void
        GetClosestReflectionProbes(result: any): void
        /** Schedules an update of the albedo and emissive Textures of a system that contains the Renderer.
         */
        UpdateGIMaterials(): void
        /** The bounding box of the renderer in world space.
         */
        bounds: Bounds
        /** The bounding box of the renderer in local space.
         */
        localBounds: Bounds
        /** Makes the rendered 3D object visible if enabled.
         */
        enabled: boolean
        /** Is this renderer visible in any camera? (Read Only)
         */
        readonly isVisible: boolean
        /** Does this object cast shadows?
         */
        shadowCastingMode: any
        /** Does this object receive shadows?
         */
        receiveShadows: boolean
        /** Allows turning off rendering for a specific component.
         */
        forceRenderingOff: boolean
        /** Is this renderer a static shadow caster?
         */
        staticShadowCaster: boolean
        /** Specifies the mode for motion vector rendering.
         */
        motionVectorGenerationMode: any
        /** The light probe interpolation type.
         */
        lightProbeUsage: any
        /** Should reflection probes be used for this Renderer?
         */
        reflectionProbeUsage: any
        /** Determines which rendering layer this renderer lives on.
         */
        renderingLayerMask: number
        /** This value sorts renderers by priority. Lower values are rendered first and higher values are rendered last.
         */
        rendererPriority: number
        /** Describes how this renderer is updated for ray tracing.
         */
        rayTracingMode: any
        /** Name of the Renderer's sorting layer.
         */
        sortingLayerName: string
        /** Unique ID of the Renderer's sorting layer.
         */
        sortingLayerID: number
        /** Renderer's order within a sorting layer.
         */
        sortingOrder: number
        /** Controls if dynamic occlusion culling should be performed for this renderer.
         */
        allowOcclusionWhenDynamic: boolean
        /** Indicates whether the renderer is part of a with other renderers.
         */
        readonly isPartOfStaticBatch: boolean
        /** Matrix that transforms a point from world space into local space (Read Only).
         */
        readonly worldToLocalMatrix: Matrix4x4
        /** Matrix that transforms a point from local space into world space (Read Only).
         */
        readonly localToWorldMatrix: Matrix4x4
        /** If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject.
         */
        lightProbeProxyVolumeOverride: GameObject
        /** If set, Renderer will use this Transform's position to find the light or reflection probe.
         */
        probeAnchor: Transform
        /** The index of the baked lightmap applied to this renderer.
         */
        lightmapIndex: number
        /** The index of the real-time lightmap applied to this renderer.
         */
        realtimeLightmapIndex: number
        /** The UV scale & offset used for a lightmap.
         */
        lightmapScaleOffset: Vector4
        /** The UV scale & offset used for a real-time lightmap.
         */
        realtimeLightmapScaleOffset: Vector4
        /** Returns all the instantiated materials of this object.
         */
        materials: Array<Material>
        /** Returns the first instantiated Material assigned to the renderer.
         */
        material: Material
        /** The shared material of this object.
         */
        sharedMaterial: Material
        /** All the shared materials of this object.
         */
        sharedMaterials: Array<Material>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    import { IEnumerator } from "System.Collections";
    /** The animation component is used to play back animations.
     */
    class Animation extends Behaviour {
        constructor()
        $GetValue(name: string): AnimationState
        /** Stops an animation named name.
         */
        Stop(name: string): void
        Stop(): void
        /** Rewinds the animation named name.
         */
        Rewind(name: string): void
        Rewind(): void
        Sample(): void
        /** Is the animation named name playing?
         */
        IsPlaying(name: string): boolean
        /** Plays an animation without blending.
         */
        Play(animation: string, mode: any): boolean
        /** Plays an animation without blending.
         */
        Play(mode: any): boolean
        /** Plays an animation without blending.
         */
        Play(animation: string): boolean
        /** Plays an animation without blending.
         */
        Play(): boolean
        /** Fades in the animation with the name animation over a period of time defined by fadeLength.
         */
        CrossFade(animation: string, fadeLength: number, mode: any): void
        /** Fades in the animation with the name animation over a period of time defined by fadeLength.
         */
        CrossFade(animation: string, fadeLength: number): void
        /** Fades in the animation with the name animation over a period of time defined by fadeLength.
         */
        CrossFade(animation: string): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string, targetWeight: number, fadeLength: number): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string, targetWeight: number): void
        /** Blends the animation named animation towards targetWeight over the next time seconds.
         */
        Blend(animation: string): void
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number, queue: any, mode: any): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number, queue: any): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string, fadeLength: number): AnimationState
        /** Cross fades an animation after previous animations has finished playing.
         */
        CrossFadeQueued(animation: string): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string, queue: any, mode: any): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string, queue: any): AnimationState
        /** Plays an animation after previous animations has finished playing.
         */
        PlayQueued(animation: string): AnimationState
        /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
         * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
         */
        AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number, addLoopFrame: boolean): void
        /** Adds clip to the only play between firstFrame and lastFrame. The new clip will also be added to the animation with name newName.
         * @param addLoopFrame Should an extra frame be inserted at the end that matches the first frame? Turn this on if you are making a looping animation.
         */
        AddClip(clip: AnimationClip, newName: string, firstFrame: number, lastFrame: number): void
        /** Adds a clip to the animation with name newName.
         */
        AddClip(clip: AnimationClip, newName: string): void
        /** Remove clip from the animation list.
         */
        RemoveClip(clip: AnimationClip): void
        /** Remove clip from the animation list.
         */
        RemoveClip(clipName: string): void
        GetClipCount(): number
        SyncLayer(layer: number): void
        GetEnumerator(): IEnumerator
        GetClip(name: string): AnimationClip
        /** The default animation.
         */
        clip: AnimationClip
        /** Should the default animation clip (the Animation.clip property) automatically start playing on startup?
         */
        playAutomatically: boolean
        /** How should time beyond the playback range of the clip be treated?
         */
        wrapMode: WrapMode
        /** Is an animation currently being played?
         */
        readonly isPlaying: boolean
        /** When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies.
         */
        animatePhysics: boolean
        /** Controls culling of this Animation component.
         */
        cullingType: any
        /** AABB of this Animation animation component in local space.
         */
        localBounds: Bounds
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Object as Object1 } from "System";
    /** Stores keyframe based animations.
     */
    class AnimationClip extends Motion {
        constructor()
        /** Samples an animation at a given time for any animated properties.
         * @param go The animated game object.
         * @param time The time to sample an animation.
         */
        SampleAnimation(go: GameObject, time: number): void
        /** Assigns the curve to animate a specific property.
         * @param relativePath Path to the game object this curve applies to. The relativePath
        is formatted similar to a pathname, e.g. "rootspineleftArm".  If relativePath
        is empty it refers to the game object the animation clip is attached to.
         * @param type The class type of the component that is animated.
         * @param propertyName The name or path to the property being animated.
         * @param curve The animation curve.
         */
        SetCurve(relativePath: string, type: any, propertyName: string, curve: AnimationCurve): void
        EnsureQuaternionContinuity(): void
        ClearCurves(): void
        /** Adds an animation event to the clip.
         * @param evt AnimationEvent to add.
         */
        AddEvent(evt: any): void
        /** Animation length in seconds. (Read Only)
         */
        readonly length: number
        /** Frame rate at which keyframes are sampled. (Read Only)
         */
        frameRate: number
        /** Sets the default wrap mode used in the animation state.
         */
        wrapMode: WrapMode
        /** AABB of this Animation Clip in local space of Animation component that it is attached too.
         */
        localBounds: Bounds
        /** Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator ).
         */
        legacy: boolean
        /** Returns true if the animation contains curve that drives a humanoid rig.
         */
        readonly humanMotion: boolean
        /** Returns true if the animation clip has no curves and no events.
         */
        readonly empty: boolean
        /** Returns true if the Animation has animation on the root transform.
         */
        readonly hasGenericRootTransform: boolean
        /** Returns true if the AnimationClip has editor curves for its root motion.
         */
        readonly hasMotionFloatCurves: boolean
        /** Returns true if the AnimationClip has root motion curves.
         */
        readonly hasMotionCurves: boolean
        /** Returns true if the AnimationClip has root Curves.
         */
        readonly hasRootCurves: boolean
        /** Animation Events for this animation clip.
         */
        events: Array<any>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Base class for AnimationClips and BlendTrees.
     */
    class Motion extends Object {
        protected constructor()
        readonly averageDuration: number
        readonly averageAngularSpeed: number
        readonly averageSpeed: Vector3
        readonly apparentSpeed: number
        readonly isLooping: boolean
        readonly legacy: boolean
        readonly isHumanMotion: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array, Object as Object1, ValueType } from "System";
    /** Interface to control the Mecanim animation system.
     */
    class Animator extends Behaviour {
        constructor()
        /** Returns the value of the given float parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetFloat(name: string): number
        /** Returns the value of the given float parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetFloat(id: number): number
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(name: string, value: number, dampTime: number, deltaTime: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(id: number, value: number, dampTime: number, deltaTime: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(name: string, value: number): void
        /** Send float values to the Animator to affect transitions.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         * @param dampTime The damper total time.
         * @param deltaTime The delta time to give to the damper.
         */
        SetFloat(id: number, value: number): void
        /** Returns the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetBool(name: string): boolean
        /** Returns the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetBool(id: number): boolean
        /** Sets the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetBool(name: string, value: boolean): void
        /** Sets the value of the given boolean parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetBool(id: number, value: boolean): void
        /** Returns the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetInteger(name: string): number
        /** Returns the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns The value of the parameter. 
         */
        GetInteger(id: number): number
        /** Sets the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetInteger(name: string, value: number): void
        /** Sets the value of the given integer parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @param value The new parameter value.
         */
        SetInteger(id: number, value: number): void
        /** Sets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        SetTrigger(name: string): void
        /** Sets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        SetTrigger(id: number): void
        /** Resets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        ResetTrigger(name: string): void
        /** Resets the value of the given trigger parameter.
         * @param name The parameter name.
         * @param id The parameter ID.
         */
        ResetTrigger(id: number): void
        /** Returns true if the parameter is controlled by a curve, false otherwise.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns True if the parameter is controlled by a curve, false otherwise. 
         */
        IsParameterControlledByCurve(name: string): boolean
        /** Returns true if the parameter is controlled by a curve, false otherwise.
         * @param name The parameter name.
         * @param id The parameter ID.
         * @returns True if the parameter is controlled by a curve, false otherwise. 
         */
        IsParameterControlledByCurve(id: number): boolean
        /** Gets the position of an IK goal.
         * @param goal The AvatarIKGoal that is queried.
         * @returns Return the current position of this IK goal in world space. 
         */
        GetIKPosition(goal: any): Vector3
        /** Sets the position of an IK goal.
         * @param goal The AvatarIKGoal that is set.
         * @param goalPosition The position in world space.
         */
        SetIKPosition(goal: any, goalPosition: Vector3): void
        /** Gets the rotation of an IK goal.
         * @param goal The AvatarIKGoal that is is queried.
         */
        GetIKRotation(goal: any): Quaternion
        /** Sets the rotation of an IK goal.
         * @param goal The AvatarIKGoal that is set.
         * @param goalRotation The rotation in world space.
         */
        SetIKRotation(goal: any, goalRotation: Quaternion): void
        /** Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
         * @param goal The AvatarIKGoal that is queried.
         */
        GetIKPositionWeight(goal: any): number
        /** Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal).
         * @param goal The AvatarIKGoal that is set.
         * @param value The translative weight.
         */
        SetIKPositionWeight(goal: any, value: number): void
        /** Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
         * @param goal The AvatarIKGoal that is queried.
         */
        GetIKRotationWeight(goal: any): number
        /** Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal).
         * @param goal The AvatarIKGoal that is set.
         * @param value The rotational weight.
         */
        SetIKRotationWeight(goal: any, value: number): void
        /** Gets the position of an IK hint.
         * @param hint The AvatarIKHint that is queried.
         * @returns Return the current position of this IK hint in world space. 
         */
        GetIKHintPosition(hint: any): Vector3
        /** Sets the position of an IK hint.
         * @param hint The AvatarIKHint that is set.
         * @param hintPosition The position in world space.
         */
        SetIKHintPosition(hint: any, hintPosition: Vector3): void
        /** Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint).
         * @param hint The AvatarIKHint that is queried.
         * @returns Return translative weight. 
         */
        GetIKHintPositionWeight(hint: any): number
        /** Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint).
         * @param hint The AvatarIKHint that is set.
         * @param value The translative weight.
         */
        SetIKHintPositionWeight(hint: any, value: number): void
        /** Sets the look at position.
         * @param lookAtPosition The position to lookAt.
         */
        SetLookAtPosition(lookAtPosition: Vector3): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number, clampWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number, eyesWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number, headWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number, bodyWeight: number): void
        /** Set look at weights.
         * @param weight (0-1) the global weight of the LookAt, multiplier for other parameters.
         * @param bodyWeight (0-1) determines how much the body is involved in the LookAt.
         * @param headWeight (0-1) determines how much the head is involved in the LookAt.
         * @param eyesWeight (0-1) determines how much the eyes are involved in the LookAt.
         * @param clampWeight (0-1) 0.0 means the character is unrestrained in motion. 1.0 means the character is clamped (look at becomes impossible). 0.5 means the character is able to move on half of the possible range (180 degrees).
         */
        SetLookAtWeight(weight: number): void
        /** Sets local rotation of a human bone during a IK pass.
         * @param humanBoneId The human bone Id.
         * @param rotation The local rotation.
         */
        SetBoneLocalRotation(humanBoneId: any, rotation: Quaternion): void
        GetBehaviours(fullPathHash: number, layerIndex: number): Array<any>
        /** Returns the layer name.
         * @param layerIndex The layer index.
         * @returns The layer name. 
         */
        GetLayerName(layerIndex: number): string
        /** Returns the index of the layer with the given name.
         * @param layerName The layer name.
         * @returns The layer index. 
         */
        GetLayerIndex(layerName: string): number
        /** Returns the weight of the layer at the specified index.
         * @param layerIndex The layer index.
         * @returns The layer weight. 
         */
        GetLayerWeight(layerIndex: number): number
        /** Sets the weight of the layer at the given index.
         * @param layerIndex The layer index.
         * @param weight The new layer weight.
         */
        SetLayerWeight(layerIndex: number, weight: number): void
        /** Returns an AnimatorStateInfo with the information on the current state.
         * @param layerIndex The layer index.
         * @returns An AnimatorStateInfo with the information on the current state. 
         */
        GetCurrentAnimatorStateInfo(layerIndex: number): any
        /** Returns an AnimatorStateInfo with the information on the next state.
         * @param layerIndex The layer index.
         * @returns An AnimatorStateInfo with the information on the next state. 
         */
        GetNextAnimatorStateInfo(layerIndex: number): any
        /** Returns an AnimatorTransitionInfo with the informations on the current transition.
         * @param layerIndex The layer's index.
         * @returns An AnimatorTransitionInfo with the informations on the current transition. 
         */
        GetAnimatorTransitionInfo(layerIndex: number): any
        /** Returns the number of AnimatorClipInfo in the current state.
         * @param layerIndex The layer index.
         * @returns The number of AnimatorClipInfo in the current state. 
         */
        GetCurrentAnimatorClipInfoCount(layerIndex: number): number
        /** Returns the number of AnimatorClipInfo in the next state.
         * @param layerIndex The layer index.
         * @returns The number of AnimatorClipInfo in the next state. 
         */
        GetNextAnimatorClipInfoCount(layerIndex: number): number
        GetCurrentAnimatorClipInfo(layerIndex: number, clips: any): void
        /** Returns an array of all the AnimatorClipInfo in the current state of the given layer.
         * @param layerIndex The layer index.
         * @returns An array of all the AnimatorClipInfo in the current state. 
         */
        GetCurrentAnimatorClipInfo(layerIndex: number): Array<any>
        GetNextAnimatorClipInfo(layerIndex: number, clips: any): void
        /** Returns an array of all the AnimatorClipInfo in the next state of the given layer.
         * @param layerIndex The layer index.
         * @returns An array of all the AnimatorClipInfo in the next state. 
         */
        GetNextAnimatorClipInfo(layerIndex: number): Array<any>
        /** Returns true if there is a transition on the given layer, false otherwise.
         * @param layerIndex The layer index.
         * @returns True if there is a transition on the given layer, false otherwise. 
         */
        IsInTransition(layerIndex: number): boolean
        /** See AnimatorController.parameters.
         */
        GetParameter(index: number): any
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number, targetNormalizedTime: number, completeMatch: boolean): void
        /** Automatically adjust the GameObject position and rotation.
         * @param matchPosition The position we want the body part to reach.
         * @param matchRotation The rotation in which we want the body part to be.
         * @param targetBodyPart The body part that is involved in the match.
         * @param weightMask Structure that contains weights for matching position and rotation.
         * @param startNormalizedTime Start time within the animation clip (0 - beginning of clip, 1 - end of clip).
         * @param targetNormalizedTime End time within the animation clip (0 - beginning of clip, 1 - end of clip), values greater than 1 can be set to trigger a match after a certain number of loops. Ex: 2.3 means at 30% of 2nd loop.
         * @param completeMatch Allows you to specify what should happen if the MatchTarget function is interrupted. A value of true causes the GameObject to immediately move to the matchPosition if interrupted. A value of false causes the GameObject to stay at its current position if interrupted.
         */
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number, targetNormalizedTime: number): void
        MatchTarget(matchPosition: Vector3, matchRotation: Quaternion, targetBodyPart: any, weightMask: any, startNormalizedTime: number): void
        /** Interrupts the automatic target matching.
         */
        InterruptMatchTarget(completeMatch: boolean): void
        InterruptMatchTarget(): void
        /** Creates a crossfade from the current state to any other state using times in seconds.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param fixedTransitionDuration The duration of the transition (in seconds).
         * @param layer The layer where the crossfade occurs.
         * @param fixedTimeOffset The time of the state (in seconds).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void
        /** Creates a crossfade from the current state to any other state using times in seconds.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param fixedTransitionDuration The duration of the transition (in seconds).
         * @param layer The layer where the crossfade occurs.
         * @param fixedTimeOffset The time of the state (in seconds).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number, normalizedTransitionTime: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number, fixedTimeOffset: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number, layer: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number, layer: number): void
        CrossFadeInFixedTime(stateName: string, fixedTransitionDuration: number): void
        CrossFadeInFixedTime(stateHashName: number, fixedTransitionDuration: number): void
        WriteDefaultValues(): void
        /** Creates a crossfade from the current state to any other state using normalized times.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param normalizedTransitionDuration The duration of the transition (normalized).
         * @param layer The layer where the crossfade occurs.
         * @param normalizedTimeOffset The time of the state (normalized).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void
        /** Creates a crossfade from the current state to any other state using normalized times.
         * @param stateName The name of the state.
         * @param stateHashName The hash name of the state.
         * @param normalizedTransitionDuration The duration of the transition (normalized).
         * @param layer The layer where the crossfade occurs.
         * @param normalizedTimeOffset The time of the state (normalized).
         * @param normalizedTransitionTime The time of the transition (normalized).
         */
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number, normalizedTransitionTime: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number, normalizedTimeOffset: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number, layer: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number, layer: number): void
        CrossFade(stateName: string, normalizedTransitionDuration: number): void
        CrossFade(stateHashName: number, normalizedTransitionDuration: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param fixedTime The time offset (in seconds).
         */
        PlayInFixedTime(stateName: string, layer: number, fixedTime: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param fixedTime The time offset (in seconds).
         */
        PlayInFixedTime(stateNameHash: number, layer: number, fixedTime: number): void
        PlayInFixedTime(stateName: string, layer: number): void
        PlayInFixedTime(stateNameHash: number, layer: number): void
        PlayInFixedTime(stateName: string): void
        PlayInFixedTime(stateNameHash: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param normalizedTime The time offset between zero and one.
         */
        Play(stateName: string, layer: number, normalizedTime: number): void
        /** Plays a state.
         * @param stateName The state name.
         * @param stateNameHash The state hash name. If stateNameHash is 0, it changes the current state time.
         * @param layer The layer index. If layer is -1, it plays the first state with the given state name or hash.
         * @param normalizedTime The time offset between zero and one.
         */
        Play(stateNameHash: number, layer: number, normalizedTime: number): void
        Play(stateName: string, layer: number): void
        Play(stateNameHash: number, layer: number): void
        Play(stateName: string): void
        Play(stateNameHash: number): void
        /** Sets an AvatarTarget and a targetNormalizedTime for the current state.
         * @param targetIndex The avatar body part that is queried.
         * @param targetNormalizedTime The current state Time that is queried.
         */
        SetTarget(targetIndex: any, targetNormalizedTime: number): void
        /** Returns Transform mapped to this human bone id. Returns null if the animator is disabled, if it does not have a human description, or if the bone id is invalid.
         * @param humanBoneId The human bone that is queried, see enum HumanBodyBones for a list of possible values.
         */
        GetBoneTransform(humanBoneId: any): Transform
        StartPlayback(): void
        StopPlayback(): void
        /** Sets the animator in recording mode, and allocates a circular buffer of size frameCount.
         * @param frameCount The number of frames (updates) that will be recorded. If frameCount is 0, the recording will continue until the user calls StopRecording. The maximum value for frameCount is 10000.
         */
        StartRecording(frameCount: number): void
        StopRecording(): void
        /** Returns true if the state exists in this layer, false otherwise.
         * @param layerIndex The layer index.
         * @param stateID The state ID.
         * @returns True if the state exists in this layer, false otherwise. 
         */
        HasState(layerIndex: number, stateID: number): boolean
        /** Evaluates the animator based on deltaTime.
         * @param deltaTime The time delta.
         */
        Update(deltaTime: number): void
        Rebind(): void
        ApplyBuiltinRootMotion(): void
        /** Creates a dependency between animator jobs and the job represented by the supplied job handle. To add multiple job dependencies, call this method for each job that need to run before the Animator's jobs.
         * @param animator The Animator instance that calls this method.
         * @param jobHandle The JobHandle of the job that needs to run before animator jobs.
         */
        AddJobDependency(jobHandle: any): void
        /** Create a TransformStreamHandle representing the new binding between the Animator and a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to bind.
         * @returns Returns the TransformStreamHandle that represents the new binding. 
         */
        BindStreamTransform(transform: Transform): any
        /** Create a PropertyStreamHandle representing the new binding on the Component property of a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does animate an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindStreamProperty(transform: Transform, type: any, property: string, isObjectReference: boolean): any
        /** Create a PropertyStreamHandle representing the new binding on the Component property of a Transform already bound to the Animator.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does animate an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindStreamProperty(transform: Transform, type: any, property: string): any
        /** Create a custom property in the AnimationStream to pass extra data to downstream animation jobs in your graph. Custom properties created in the AnimationStream do not exist in the scene.
         * @param animator The Animator instance that calls this method.
         * @param name The name of the property.
         * @param type The type of property to create (float, integer or boolean).
         * @returns Returns the PropertyStreamHandle that represents the new binding. 
         */
        BindCustomStreamProperty(property: string, type: any): any
        /** Create a TransformSceneHandle representing the new binding between the Animator and a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to bind.
         * @returns Returns the TransformSceneHandle that represents the new binding. 
         */
        BindSceneTransform(transform: Transform): any
        /** Create a PropertySceneHandle representing the new binding on the Component property of a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does access an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertySceneHandle that represents the new binding. 
         */
        BindSceneProperty(transform: Transform, type: any, property: string, isObjectReference: boolean): any
        /** Create a PropertySceneHandle representing the new binding on the Component property of a Transform in the Scene.
         * @param animator The Animator instance that calls this method.
         * @param transform The Transform to target.
         * @param type The Component type.
         * @param property The property to bind.
         * @param isObjectReference isObjectReference need to be set to true if the property to bind does access an Object like SpriteRenderer.sprite.
         * @returns Returns the PropertySceneHandle that represents the new binding. 
         */
        BindSceneProperty(transform: Transform, type: any, property: string): any
        /** Open a new stream on the Animator.
         * @param animator The Animator instance that calls this method.
         * @param stream The new stream.
         * @returns Returns whether or not the stream has been opened. 
         */
        OpenAnimationStream(stream: jsb.Ref<any>): boolean
        /** Close a stream that has been opened using OpenAnimationStream.
         * @param animator The Animator instance that calls this method.
         * @param stream The stream to close.
         */
        CloseAnimationStream(stream: jsb.Ref<any>): void
        /** Newly created handles are always resolved lazily on the next access when the jobs are run. To avoid a cpu spike while evaluating the jobs you can manually resolve all handles from the main thread.
         * @param animator The Animator instance that calls this method.
         */
        ResolveAllStreamHandles(): void
        /** Newly created handles are always resolved lazily on the next access when the jobs are run. To avoid a cpu spike while evaluating the jobs you can manually resolve all handles from the main thread.
         * @param animator The Animator instance that calls this method.
         */
        ResolveAllSceneHandles(): void
        /** Removes all PropertyStreamHandles and TransformStreamHandles associated with the Animator instance. Use this method to manage the lifecycle of stream handles when the animated hierarchy changes.
         * @param animator The Animator instance that calls this method.
         */
        UnbindAllStreamHandles(): void
        /** Removes all PropertySceneHandles and TransformSceneHandles associated with the Animator instance. Use this method to manage the lifecycle of scene handles when the animated hierarchy changes.
         * @param animator The Animator instance that calls this method.
         */
        UnbindAllSceneHandles(): void
        /** Generates an parameter id from a string.
         * @param name The string to convert to Id.
         */
        static StringToHash(name: string): number
        /** Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy.
         */
        readonly isOptimizable: boolean
        /** Returns true if the current rig is humanoid, false if it is generic.
         */
        readonly isHuman: boolean
        /** Returns true if the current rig has root motion.
         */
        readonly hasRootMotion: boolean
        /** Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic).
         */
        readonly humanScale: number
        /** Returns whether the animator is initialized successfully.
         */
        readonly isInitialized: boolean
        /** Gets the avatar delta position for the last evaluated frame.
         */
        readonly deltaPosition: Vector3
        /** Gets the avatar delta rotation for the last evaluated frame.
         */
        readonly deltaRotation: Quaternion
        /** Gets the avatar velocity  for the last evaluated frame.
         */
        readonly velocity: Vector3
        /** Gets the avatar angular velocity for the last evaluated frame.
         */
        readonly angularVelocity: Vector3
        /** The root position, the position of the game object.
         */
        rootPosition: Vector3
        /** The root rotation, the rotation of the game object.
         */
        rootRotation: Quaternion
        /** Should root motion be applied?
         */
        applyRootMotion: boolean
        /** Specifies the update mode of the Animator.
         */
        updateMode: any
        /** Returns true if the object has a transform hierarchy.
         */
        readonly hasTransformHierarchy: boolean
        /** The current gravity weight based on current animations that are played.
         */
        readonly gravityWeight: number
        /** The position of the body center of mass.
         */
        bodyPosition: Vector3
        /** The rotation of the body center of mass.
         */
        bodyRotation: Quaternion
        /** Automatic stabilization of feet during transition and blending.
         */
        stabilizeFeet: boolean
        /** Returns the number of layers in the controller.
         */
        readonly layerCount: number
        /** The AnimatorControllerParameter list used by the animator. (Read Only)
         */
        readonly parameters: Array<any>
        /** Returns the number of parameters in the controller.
         */
        readonly parameterCount: number
        /** Blends pivot point between body center of mass and feet pivot.
         */
        feetPivotActive: number
        /** Gets the pivot weight.
         */
        readonly pivotWeight: number
        /** Get the current position of the pivot.
         */
        readonly pivotPosition: Vector3
        /** If automatic matching is active.
         */
        readonly isMatchingTarget: boolean
        /** The playback speed of the Animator. 1 is normal playback speed.
         */
        speed: number
        /** Returns the position of the target specified by SetTarget.
         */
        readonly targetPosition: Vector3
        /** Returns the rotation of the target specified by SetTarget.
         */
        readonly targetRotation: Quaternion
        /** Controls culling of this Animator component.
         */
        cullingMode: any
        /** Sets the playback position in the recording buffer.
         */
        playbackTime: number
        /** Start time of the first frame of the buffer relative to the frame at which StartRecording was called.
         */
        recorderStartTime: number
        /** End time of the recorded clip relative to when StartRecording was called.
         */
        recorderStopTime: number
        /** Gets the mode of the Animator recorder.
         */
        readonly recorderMode: any
        /** The runtime representation of AnimatorController that controls the Animator.
         */
        runtimeAnimatorController: any
        /** Returns true if Animator has any playables assigned to it.
         */
        readonly hasBoundPlayables: boolean
        /** Gets/Sets the current Avatar.
         */
        avatar: any
        /** The PlayableGraph created by the Animator.
         */
        readonly playableGraph: any
        /** Additional layers affects the center of mass.
         */
        layersAffectMassCenter: boolean
        /** Get left foot bottom height.
         */
        readonly leftFeetBottomHeight: number
        /** Get right foot bottom height.
         */
        readonly rightFeetBottomHeight: number
        logWarnings: boolean
        /** Sets whether the Animator sends events of type AnimationEvent.
         */
        fireEvents: boolean
        /** Controls the behaviour of the Animator component when a GameObject is disabled.
         */
        keepAnimatorStateOnDisable: boolean
        /** Specifies whether playable graph values are reset or preserved when the Animator is disabled.
         */
        writeDefaultValuesOnDisable: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** The AnimationState gives full control over animation blending.
     */
    class AnimationState extends TrackedReference {
        constructor()
        /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
         * @param mix The transform to animate.
         * @param recursive Whether to also animate all children of the specified transform.
         */
        AddMixingTransform(mix: Transform, recursive: boolean): void
        /** Adds a transform which should be animated. This allows you to reduce the number of animations you have to create.
         * @param mix The transform to animate.
         * @param recursive Whether to also animate all children of the specified transform.
         */
        AddMixingTransform(mix: Transform): void
        /** Removes a transform which should be animated.
         */
        RemoveMixingTransform(mix: Transform): void
        /** Enables / disables the animation.
         */
        enabled: boolean
        /** The weight of animation.
         */
        weight: number
        /** Wrapping mode of the animation.
         */
        wrapMode: WrapMode
        /** The current time of the animation.
         */
        time: number
        /** Normalized time of the State.
         */
        normalizedTime: number
        /** The playback speed of the animation. 1 is normal playback speed.
         */
        speed: number
        /** The normalized playback speed.
         */
        normalizedSpeed: number
        /** The length of the animation clip in seconds.
         */
        readonly length: number
        layer: number
        /** The clip that is being played by this animation state.
         */
        readonly clip: AnimationClip
        /** The name of the animation.
         */
        name: string
        /** Which blend mode should be used?
         */
        blendMode: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    class TrackedReference extends Object1 {
        Equals(o: Object1): boolean
        GetHashCode(): number
        static op_Equality(x: TrackedReference, y: TrackedReference): boolean
        static op_Inequality(x: TrackedReference, y: TrackedReference): boolean
        static op_Implicit(exists: TrackedReference): boolean
        // js_op_overloading: static ==(x: TrackedReference, y: TrackedReference): boolean
        protected constructor()
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Object {
        constructor()
        Equals(obj: Object): boolean
        GetHashCode(): number
        GetType(): any
        toString(): string
        static Equals(objA: Object, objB: Object): boolean
        static ReferenceEquals(objA: Object, objB: Object): boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.
     */
    enum WrapMode {
        /** Reads the default repeat mode set higher up.
         */
        Default = 0,
        Once = 1,
        Clamp = 1,
        /** When time reaches the end of the animation clip, time will continue at the beginning.
         */
        Loop = 2,
        /** When time reaches the end of the animation clip, time will ping pong back between beginning and end.
         */
        PingPong = 4,
        /** Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.
         */
        ClampForever = 8,
    }
}
declare module "System" {
    import * as jsb from "jsb";
    abstract class Enum extends ValueType {
        Equals(obj: Object): boolean
        GetHashCode(): number
        toString(format: string): string
        toString(): string
        CompareTo(target: Object): number
        HasFlag(flag: Enum): boolean
        GetTypeCode(): any
        static Parse(enumType: any, value: string, ignoreCase: boolean): Object
        static Parse(enumType: any, value: string): Object
        static GetUnderlyingType(enumType: any): any
        static GetValues(enumType: any): Array<any>
        static GetName(enumType: any, value: Object): string
        static GetNames(enumType: any): Array<string>
        static ToObject(enumType: any, value: Object): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: jsb.byte): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static ToObject(enumType: any, value: number): Object
        static IsDefined(enumType: any, value: Object): boolean
        static Format(enumType: any, value: Object, format: string): string
        static TryParse(enumType: any, value: string, ignoreCase: boolean, result: jsb.Out<Object>): boolean
        static TryParse(enumType: any, value: string, result: jsb.Out<Object>): boolean
    }
}
declare module "System" {
    import * as jsb from "jsb";
    abstract class ValueType extends Object {
        Equals(obj: Object): boolean
        GetHashCode(): number
        toString(): string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Exception } from "System";
    /** Class containing methods to ease debugging while developing a game.
     */
    class Debug extends Object1 {
        constructor()
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color, duration: number, depthTest: boolean): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color, duration: number): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawLine(start: Vector3, end: Vector3, color: Color): void
        /** Draws a line between specified start and end points.
         * @param start Point in world space where the line should start.
         * @param end Point in world space where the line should end.
         * @param color Color of the line.
         * @param duration How long the line should be visible for.
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawLine(start: Vector3, end: Vector3): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number, depthTest: boolean): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color, duration: number): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawRay(start: Vector3, dir: Vector3, color: Color): void
        /** Draws a line from start to start + dir in world coordinates.
         * @param start Point in world space where the ray should start.
         * @param dir Direction and length of the ray.
         * @param color Color of the drawn line.
         * @param duration How long the line will be visible for (in seconds).
         * @param depthTest Determines whether objects closer to the camera obscure the line.
         */
        static DrawRay(start: Vector3, dir: Vector3): void
        static Break(): void
        static DebugBreak(): void
        /** Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static Log(message: Object1, context: Object): void
        /** Logs a message to the Unity Console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static Log(message: Object1): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(logType: any, logOptions: any, context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         * @param logType Type of message e.g. warn or error etc.
         * @param logOptions Option flags to treat the log message special.
         */
        static LogFormat(format: string, ...args: Object1[]): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogError(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogError(message: Object1): void
        /** Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogErrorFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted error message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogErrorFormat(format: string, ...args: Object1[]): void
        static ClearDeveloperConsole(): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        static LogException(exception: Exception, context: Object): void
        /** A variant of Debug.Log that logs an error message to the console.
         * @param context Object to which the message applies.
         * @param exception Runtime Exception.
         */
        static LogException(exception: Exception): void
        /** A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogWarning(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs a warning message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogWarning(message: Object1): void
        /** Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogWarningFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted warning message to the Unity Console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogWarningFormat(format: string, ...args: Object1[]): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, message: Object1, context: Object): void
        static Assert(condition: boolean, message: string, context: Object): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, context: Object): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean, message: Object1): void
        static Assert(condition: boolean, message: string): void
        /** Assert a condition and logs an error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param context Object to which the message applies.
         * @param message String or object to be converted to string representation for display.
         */
        static Assert(condition: boolean): void
        /** Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static AssertFormat(condition: boolean, context: Object, format: string, ...args: Object1[]): void
        /** Assert a condition and logs a formatted error message to the Unity console on failure.
         * @param condition Condition you expect to be true.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static AssertFormat(condition: boolean, format: string, ...args: Object1[]): void
        /** A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogAssertion(message: Object1, context: Object): void
        /** A variant of Debug.Log that logs an assertion message to the console.
         * @param message String or object to be converted to string representation for display.
         * @param context Object to which the message applies.
         */
        static LogAssertion(message: Object1): void
        /** Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogAssertionFormat(context: Object, format: string, ...args: Object1[]): void
        /** Logs a formatted assertion message to the Unity console.
         * @param format A composite format string.
         * @param args Format arguments.
         * @param context Object to which the message applies.
         */
        static LogAssertionFormat(format: string, ...args: Object1[]): void
        /** Get default debug logger.
         */
        static readonly unityLogger: any
        /** Reports whether the development console is visible. The development console cannot be made to appear using:
         */
        static developerConsoleVisible: boolean
        /** In the Build Settings dialog there is a check box called "Development Build".
         */
        static readonly isDebugBuild: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Suspends the coroutine execution for the given amount of seconds using scaled time.
     */
    class WaitForSeconds extends YieldInstruction {
        constructor(seconds: number)
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** Base class for all yield instructions.
     */
    class YieldInstruction extends Object1 {
        constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Waits until the end of the frame after Unity has rendererd every Camera and GUI, just before displaying the frame on screen.
     */
    class WaitForEndOfFrame extends YieldInstruction {
        constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array, ValueType } from "System";
    /** Interface into the Input system.
     */
    class Input extends Object1 {
        constructor()
        /** Returns the value of the virtual axis identified by axisName.
         */
        static GetAxis(axisName: string): number
        /** Returns the value of the virtual axis identified by axisName with no smoothing filtering applied.
         */
        static GetAxisRaw(axisName: string): number
        /** Returns true while the virtual button identified by buttonName is held down.
         * @param buttonName The name of the button such as Jump.
         * @returns True when an axis has been pressed and not released. 
         */
        static GetButton(buttonName: string): boolean
        /** Returns true during the frame the user pressed down the virtual button identified by buttonName.
         */
        static GetButtonDown(buttonName: string): boolean
        /** Returns true the first frame the user releases the virtual button identified by buttonName.
         */
        static GetButtonUp(buttonName: string): boolean
        /** Returns whether the given mouse button is held down.
         */
        static GetMouseButton(button: number): boolean
        /** Returns true during the frame the user pressed the given mouse button.
         */
        static GetMouseButtonDown(button: number): boolean
        /** Returns true during the frame the user releases the given mouse button.
         */
        static GetMouseButtonUp(button: number): boolean
        static ResetInputAxes(): void
        static GetJoystickNames(): Array<string>
        /** Call Input.GetTouch to obtain a Touch struct.
         * @param index The touch input on the device screen.
         * @returns Touch details in the struct. 
         */
        static GetTouch(index: number): any
        /** Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables).
         */
        static GetAccelerationEvent(index: number): any
        /** Returns true while the user holds down the key identified by the key KeyCode enum parameter.
         */
        static GetKey(key: KeyCode): boolean
        /** Returns true while the user holds down the key identified by name.
         */
        static GetKey(name: string): boolean
        /** Returns true during the frame the user releases the key identified by the key KeyCode enum parameter.
         */
        static GetKeyUp(key: KeyCode): boolean
        /** Returns true during the frame the user releases the key identified by name.
         */
        static GetKeyUp(name: string): boolean
        /** Returns true during the frame the user starts pressing down the key identified by the key KeyCode enum parameter.
         */
        static GetKeyDown(key: KeyCode): boolean
        /** Returns true during the frame the user starts pressing down the key identified by name.
         */
        static GetKeyDown(name: string): boolean
        /** Enables/Disables mouse simulation with touches. By default this option is enabled.
         */
        static simulateMouseWithTouches: boolean
        /** Is any key or mouse button currently held down? (Read Only)
         */
        static readonly anyKey: boolean
        /** Returns true the first frame the user hits any key or mouse button. (Read Only)
         */
        static readonly anyKeyDown: boolean
        /** Returns the keyboard input entered this frame. (Read Only)
         */
        static readonly inputString: string
        /** The current mouse position in pixel coordinates. (Read Only).
         */
        static readonly mousePosition: Vector3
        /** The current mouse scroll delta. (Read Only)
         */
        static readonly mouseScrollDelta: Vector2
        /** Controls enabling and disabling of IME input composition.
         */
        static imeCompositionMode: any
        /** The current IME composition string being typed by the user.
         */
        static readonly compositionString: string
        /** Does the user have an IME keyboard input source selected?
         */
        static readonly imeIsSelected: boolean
        /** The current text input position used by IMEs to open windows.
         */
        static compositionCursorPos: Vector2
        /** Indicates if a mouse device is detected.
         */
        static readonly mousePresent: boolean
        /** Number of touches. Guaranteed not to change throughout the frame. (Read Only)
         */
        static readonly touchCount: number
        /** Bool value which let's users check if touch pressure is supported.
         */
        static readonly touchPressureSupported: boolean
        /** Returns true when Stylus Touch is supported by a device or platform.
         */
        static readonly stylusTouchSupported: boolean
        /** Returns whether the device on which application is currently running supports touch input.
         */
        static readonly touchSupported: boolean
        /** Property indicating whether the system handles multiple touches.
         */
        static multiTouchEnabled: boolean
        /** Device physical orientation as reported by OS. (Read Only)
         */
        static readonly deviceOrientation: any
        /** Last measured linear acceleration of a device in three-dimensional space. (Read Only)
         */
        static readonly acceleration: Vector3
        /** This property controls if input sensors should be compensated for screen orientation.
         */
        static compensateSensors: boolean
        /** Number of acceleration measurements which occurred during last frame.
         */
        static readonly accelerationEventCount: number
        /** Should  Back button quit the application?

Only usable on Android, Windows Phone or Windows Tablets.
         */
        static backButtonLeavesApp: boolean
        /** Property for accessing device location (handheld devices only). (Read Only)
         */
        static readonly location: any
        /** Property for accessing compass (handheld devices only). (Read Only)
         */
        static readonly compass: any
        /** Returns default gyroscope.
         */
        static readonly gyro: any
        /** Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables).
         */
        static readonly touches: Array<any>
        /** Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables).
         */
        static readonly accelerationEvents: Array<any>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum, Array } from "System";
    /** Access to application runtime data.
     */
    class Application extends Object1 {
        constructor()
        static Quit(exitCode: number): void
        static Quit(): void
        static Unload(): void
        /** Checks if the streamed level can be loaded.
         */
        static CanStreamedLevelBeLoaded(levelIndex: number): boolean
        /** Checks if the streamed level can be loaded.
         */
        static CanStreamedLevelBeLoaded(levelName: string): boolean
        /** Returns true if the given object is part of the playing world either in any kind of built Player or in Play Mode.
         * @param obj The object to test.
         * @returns True if the object is part of the playing world. 
         */
        static IsPlaying(obj: Object): boolean
        static GetBuildTags(): Array<string>
        /** Set an array of feature tags for this build.
         */
        static SetBuildTags(buildTags: Array<string>): void
        static HasProLicense(): boolean
        static RequestAdvertisingIdentifierAsync(delegateMethod: (advertisingId: string, trackingEnabled: boolean, errorMsg: string) => void): boolean
        /** Opens the URL specified, subject to the permissions and limitations of your app’s current platform and environment. 
         * @param url The URL to open.
         */
        static OpenURL(url: string): void
        /** Get stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
         */
        static GetStackTraceLogType(logType: any): any
        /** Set stack trace logging options. The default value is StackTraceLogType.ScriptOnly.
         */
        static SetStackTraceLogType(logType: any, stackTraceType: any): void
        /** Request authorization to use the webcam or microphone on iOS and WebGL.
         */
        static RequestUserAuthorization(mode: any): any
        /** Check if the user has authorized use of the webcam or microphone in the Web Player.
         */
        static HasUserAuthorization(mode: any): boolean
        /** Returns true when called in any kind of built Player, or when called in the Editor in Play Mode (Read Only).
         */
        static readonly isPlaying: boolean
        /** Whether the Player currently has focus (Read-only).
         */
        static readonly isFocused: boolean
        /** Returns a GUID for this build (Read Only).
         */
        static readonly buildGUID: string
        /** Should the Player be running when the application is in the background?
         */
        static runInBackground: boolean
        /** Returns true when Unity is launched with the -batchmode flag from the command line (Read Only).
         */
        static readonly isBatchMode: boolean
        /** Contains the path to the game data folder on the target device (Read Only).
         */
        static readonly dataPath: string
        /** The path to the StreamingAssets  folder (Read Only).
         */
        static readonly streamingAssetsPath: string
        /** Contains the path to a persistent data directory (Read Only).
         */
        static readonly persistentDataPath: string
        /** Contains the path to a temporary data / cache directory (Read Only).
         */
        static readonly temporaryCachePath: string
        /** The URL of the document. For WebGL, this a web URL. For Android, iOS, or Universal Windows Platform (UWP) this is a deep link URL (Read Only).
         */
        static readonly absoluteURL: string
        /** The version of the Unity runtime used to play the content.
         */
        static readonly unityVersion: string
        /** Returns application version number  (Read Only).
         */
        static readonly version: string
        /** Returns the name of the store or package that installed the application (Read Only).
         */
        static readonly installerName: string
        /** Returns application identifier at runtime. 
         */
        static readonly identifier: string
        /** Returns application install mode (Read Only).
         */
        static readonly installMode: any
        /** Returns application running in sandbox (Read Only).
         */
        static readonly sandboxType: any
        /** Returns application product name (Read Only).
         */
        static readonly productName: string
        /** Returns application company name (Read Only).
         */
        static readonly companyName: string
        /** A unique cloud project identifier. It is unique for every project (Read Only).
         */
        static readonly cloudProjectId: string
        /** Specifies the frame rate at which Unity tries to render your game.
         */
        static targetFrameRate: number
        /** Returns the path to the console log file, or an empty string if the current platform does not support log files.
         */
        static readonly consoleLogPath: string
        /** Priority of background loading thread.
         */
        static backgroundLoadingPriority: any
        /** Returns false if application is altered in any way after it was built.
         */
        static readonly genuine: boolean
        /** Returns true if application integrity can be confirmed.
         */
        static readonly genuineCheckAvailable: boolean
        /** Returns the platform the game is running on (Read Only).
         */
        static readonly platform: any
        /** Identifies whether the current Runtime platform is a known mobile platform.
         */
        static readonly isMobilePlatform: boolean
        /** Is the current Runtime platform a known console platform.
         */
        static readonly isConsolePlatform: boolean
        /** The language the user's operating system is running in.
         */
        static readonly systemLanguage: any
        /** Returns the type of internet reachability currently possible on the device.
         */
        static readonly internetReachability: any
        /** Whether the game is running inside the Unity Editor (Read Only).
         */
        static readonly isEditor: boolean
        static lowMemory(op: "add" | "remove", fn: () => void): void
        static logMessageReceived(op: "add" | "remove", fn: (condition: string, stackTrace: string, type: any) => void): void
        static logMessageReceivedThreaded(op: "add" | "remove", fn: (condition: string, stackTrace: string, type: any) => void): void
        static onBeforeRender(op: "add" | "remove", fn: () => void): void
        static focusChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        static deepLinkActivated(op: "add" | "remove", fn: (obj: string) => void): void
        static wantsToQuit(op: "add" | "remove", fn: () => boolean): void
        static quitting(op: "add" | "remove", fn: () => void): void
        static unloading(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Representation of rays.
     */
    class Ray extends ValueType {
        constructor(origin: Vector3, direction: Vector3)
        /** Returns a point at distance units along the ray.
         */
        GetPoint(distance: number): Vector3
        /** Returns a formatted string for this ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for this ray.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        /** The origin point of the ray.
         */
        origin: Vector3
        /** The direction of the ray.
         */
        direction: Vector3
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Structure used to get information back from a raycast.
     */
    class RaycastHit extends ValueType {
        constructor()
        /** The Collider that was hit.
         */
        readonly collider: Collider
        /** Instance ID of the Collider that was hit.
         */
        readonly colliderInstanceID: number
        /** The impact point in world space where the ray hit the collider.
         */
        point: Vector3
        /** The normal of the surface the ray hit.
         */
        normal: Vector3
        /** The barycentric coordinate of the triangle we hit.
         */
        barycentricCoordinate: Vector3
        /** The distance from the ray's origin to the impact point.
         */
        distance: number
        /** The index of the triangle that was hit.
         */
        readonly triangleIndex: number
        /** The uv texture coordinate at the collision location.
         */
        readonly textureCoord: Vector2
        /** The secondary uv texture coordinate at the impact point.
         */
        readonly textureCoord2: Vector2
        /** The Transform of the rigidbody or collider that was hit.
         */
        readonly transform: Transform
        /** The Rigidbody of the collider that was hit. If the collider is not attached to a rigidbody then it is null.
         */
        readonly rigidbody: Rigidbody
        /** The ArticulationBody of the collider that was hit. If the collider is not attached to an articulation body then it is null.
         */
        readonly articulationBody: any
        /** The uv lightmap coordinate at the impact point.
         */
        readonly lightmapCoord: Vector2
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, ValueType, Enum, Array } from "System";
    /** Global physics properties and helper methods.
     */
    class Physics extends Object1 {
        constructor()
        /** Makes the collision detection system ignore all collisions between collider1 and collider2.
         * @param collider1 Any collider.
         * @param collider2 Another collider you want to have collider1 to start or stop ignoring collisions with.
         * @param ignore Whether or not the collisions between the two colliders should be ignored or not.
         */
        static IgnoreCollision(collider1: Collider, collider2: Collider, ignore: boolean): void
        static IgnoreCollision(collider1: Collider, collider2: Collider): void
        /** Makes the collision detection system ignore all collisions between any collider in layer1 and any collider in layer2.

Note that IgnoreLayerCollision will reset the trigger state of affected colliders, so you might receive OnTriggerExit and OnTriggerEnter messages in response to calling this.
         */
        static IgnoreLayerCollision(layer1: number, layer2: number, ignore: boolean): void
        static IgnoreLayerCollision(layer1: number, layer2: number): void
        /** Are collisions between layer1 and layer2 being ignored?
         */
        static GetIgnoreLayerCollision(layer1: number, layer2: number): boolean
        /** Checks whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not.
         * @param collider1 The first collider to compare to collider2.
         * @param collider2 The second collider to compare to collider1.
         * @returns Whether the collision detection system will ignore all collisionstriggers between collider1 and collider2/ or not. 
         */
        static GetIgnoreCollision(collider1: Collider, collider2: Collider): boolean
        /** Casts a ray against all colliders in the Scene and returns detailed information on what was hit.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (Additional resources: RaycastHit).
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the Scene.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore Colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true if the ray intersects with a Collider, otherwise false. 
         */
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        /** Same as above using ray.origin and ray.direction instead of origin and direction.
         * @param ray The starting point and direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the closest collider was hit. (Additional resources: RaycastHit).
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** Same as above using ray.origin and ray.direction instead of origin and direction.
         * @param ray The starting point and direction of the ray.
         * @param maxDistance The max distance the ray should check for collisions.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns true when the ray intersects any collider, otherwise false. 
         */
        static Raycast(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, maxDistance: number): boolean
        static Raycast(origin: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static Raycast(ray: Ray, maxDistance: number, layerMask: number): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static Raycast(origin: Vector3, direction: Vector3): boolean
        static Raycast(ray: Ray, maxDistance: number): boolean
        static Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>): boolean
        static Raycast(ray: Ray): boolean
        /** Returns true if there is any collider intersecting the line between start and end.
         * @param start Start point.
         * @param end End point.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (Additional resources: RaycastHit).
         */
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>, layerMask: number, queryTriggerInteraction: any): boolean
        /** Returns true if there is any collider intersecting the line between start and end.
         * @param start Start point.
         * @param end End point.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static Linecast(start: Vector3, end: Vector3, layerMask: number, queryTriggerInteraction: any): boolean
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>, layerMask: number): boolean
        static Linecast(start: Vector3, end: Vector3, layerMask: number): boolean
        static Linecast(start: Vector3, end: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static Linecast(start: Vector3, end: Vector3): boolean
        /**
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (Additional resources: RaycastHit).
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the capsule sweep intersects any collider, otherwise false. 
         */
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static CapsuleCast(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): boolean
        /** Casts a sphere along a ray and returns detailed information on what was hit.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction into which to sweep the sphere.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (Additional resources: RaycastHit).
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the sphere sweep intersects any collider, otherwise false. 
         */
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        /**
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (Additional resources: RaycastHit).
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** Casts a sphere along a ray and returns detailed information on what was hit.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the sphere sweep intersects any collider, otherwise false. 
         */
        static SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, layerMask: number): boolean
        static SphereCast(origin: Vector3, radius: number, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static SphereCast(ray: Ray, radius: number, maxDistance: number, layerMask: number): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        static SphereCast(ray: Ray, radius: number, maxDistance: number): boolean
        static SphereCast(ray: Ray, radius: number, hitInfo: jsb.Out<RaycastHit>): boolean
        static SphereCast(ray: Ray, radius: number): boolean
        /** Casts the box along a ray and returns detailed information on what was hit.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit. (Additional resources: RaycastHit).
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if any intersections were found. 
         */
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        /** Casts the box along a ray and returns detailed information on what was hit.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if any intersections were found. 
         */
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion, maxDistance: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>, orientation: Quaternion): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        static BoxCast(center: Vector3, halfExtents: Vector3, direction: Vector3): boolean
        /** Additional resources: Raycast.
         * @param origin The starting point of the ray in world coordinates.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layermask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        /** Casts a ray through the Scene and returns all hits. Note that order of the results is undefined.
         * @param ray The starting point and direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of RaycastHit objects. Note that the order of the results is undefined. 
         */
        static RaycastAll(ray: Ray, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static RaycastAll(ray: Ray, maxDistance: number, layerMask: number): Array<RaycastHit>
        static RaycastAll(origin: Vector3, direction: Vector3): Array<RaycastHit>
        static RaycastAll(ray: Ray, maxDistance: number): Array<RaycastHit>
        static RaycastAll(ray: Ray): Array<RaycastHit>
        /** Cast a ray through the Scene and store the hits into the buffer.
         * @param origin The starting point and direction of the ray.
         * @param results The buffer to store the hits into.
         * @param direction The direction of the ray.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @returns The amount of hits stored into the results buffer. 
         */
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        /** Cast a ray through the Scene and store the hits into the buffer.
         * @param ray The starting point and direction of the ray.
         * @param results The buffer to store the hits into.
         * @param maxDistance The max distance the rayhit is allowed to be from the start of the ray.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>, maxDistance: number): number
        static RaycastNonAlloc(origin: Vector3, direction: Vector3, results: Array<RaycastHit>): number
        static RaycastNonAlloc(ray: Ray, results: Array<RaycastHit>): number
        /** Like Physics.CapsuleCast, but this function will return all hits the capsule sweep intersects.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param maxDistance The max length of the sweep.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static CapsuleCastAll(point1: Vector3, point2: Vector3, radius: number, direction: Vector3): Array<RaycastHit>
        /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction in which to sweep the sphere.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number, layerMask: number): Array<RaycastHit>
        /** Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3, maxDistance: number): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number, layerMask: number): Array<RaycastHit>
        static SphereCastAll(origin: Vector3, radius: number, direction: Vector3): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number, maxDistance: number): Array<RaycastHit>
        static SphereCastAll(ray: Ray, radius: number): Array<RaycastHit>
        /** Check the given capsule against the physics world and return all overlapping colliders.
         * @param point0 The center of the sphere at the start of the capsule.
         * @param point1 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Colliders touching or inside the capsule. 
         */
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number, layerMask: number): Array<Collider>
        static OverlapCapsule(point0: Vector3, point1: Vector3, radius: number): Array<Collider>
        /** Computes and stores colliders touching or inside the sphere.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param layerMask A defines which layers of colliders to include in the query.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns an array with all colliders touching or inside the sphere. 
         */
        static OverlapSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapSphere(position: Vector3, radius: number, layerMask: number): Array<Collider>
        static OverlapSphere(position: Vector3, radius: number): Array<Collider>
        /** Simulate physics in the Scene.
         * @param step The time to advance physics by.
         */
        static Simulate(step: number): void
        static SyncTransforms(): void
        /** Compute the minimal translation required to separate the given colliders apart at specified poses.
         * @param colliderA The first collider.
         * @param positionA Position of the first collider.
         * @param rotationA Rotation of the first collider.
         * @param colliderB The second collider.
         * @param positionB Position of the second collider.
         * @param rotationB Rotation of the second collider.
         * @param direction Direction along which the translation required to separate the colliders apart is minimal.
         * @param distance The distance along direction that is required to separate the colliders apart.
         * @returns True, if the colliders overlap at the given poses. 
         */
        static ComputePenetration(colliderA: Collider, positionA: Vector3, rotationA: Quaternion, colliderB: Collider, positionB: Vector3, rotationB: Quaternion, direction: jsb.Out<Vector3>, distance: jsb.Out<number>): boolean
        /** Returns a point on the given collider that is closest to the specified location.
         * @param point Location you want to find the closest point to.
         * @param collider The collider that you find the closest point on.
         * @param position The position of the collider.
         * @param rotation The rotation of the collider.
         * @returns The point on the collider that is closest to the specified location. 
         */
        static ClosestPoint(point: Vector3, collider: Collider, position: Vector3, rotation: Quaternion): Vector3
        /** Computes and stores colliders touching or inside the sphere into the provided buffer.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param results The buffer to store the results into.
         * @param layerMask A defines which layers of colliders to include in the query.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Returns the amount of colliders stored into the results buffer. 
         */
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>, layerMask: number, queryTriggerInteraction: any): number
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>, layerMask: number): number
        static OverlapSphereNonAlloc(position: Vector3, radius: number, results: Array<Collider>): number
        /** Returns true if there are any colliders overlapping the sphere defined by position and radius in world coordinates.
         * @param position Center of the sphere.
         * @param radius Radius of the sphere.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CheckSphere(position: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CheckSphere(position: Vector3, radius: number, layerMask: number): boolean
        static CheckSphere(position: Vector3, radius: number): boolean
        /** Casts a capsule against all colliders in the Scene and returns detailed information on what was hit into the buffer.
         * @param point1 The center of the sphere at the start of the capsule.
         * @param point2 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param direction The direction into which to sweep the capsule.
         * @param results The buffer to store the hits into.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the buffer. 
         */
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static CapsuleCastNonAlloc(point1: Vector3, point2: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>): number
        /** Cast sphere along the direction and store the results into buffer.
         * @param origin The center of the sphere at the start of the sweep.
         * @param radius The radius of the sphere.
         * @param direction The direction in which to sweep the sphere.
         * @param results The buffer to save the hits into.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        /** Cast sphere along the direction and store the results into buffer.
         * @param ray The starting point and direction of the ray into which the sphere sweep is cast.
         * @param radius The radius of the sphere.
         * @param results The buffer to save the results to.
         * @param maxDistance The max length of the sweep.
         * @param layerMask A that is used to selectively ignore colliders when casting a sphere.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored into the results buffer. 
         */
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>, maxDistance: number): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number, layerMask: number): number
        static SphereCastNonAlloc(origin: Vector3, radius: number, direction: Vector3, results: Array<RaycastHit>): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>, maxDistance: number): number
        static SphereCastNonAlloc(ray: Ray, radius: number, results: Array<RaycastHit>): number
        /** Checks if any colliders overlap a capsule-shaped volume in world space.
         * @param start The center of the sphere at the start of the capsule.
         * @param end The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         */
        static CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number, queryTriggerInteraction: any): boolean
        static CheckCapsule(start: Vector3, end: Vector3, radius: number, layerMask: number): boolean
        static CheckCapsule(start: Vector3, end: Vector3, radius: number): boolean
        /** Check whether the given box overlaps with other colliders or not.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param orientation Rotation of the box.
         * @param layermask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True, if the box overlaps with any colliders. 
         */
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layermask: number, queryTriggerInteraction: any): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): boolean
        static CheckBox(center: Vector3, halfExtents: Vector3): boolean
        /** Find all colliders touching or inside of the given box.
         * @param center Center of the box.
         * @param halfExtents Half of the size of the box in each dimension.
         * @param orientation Rotation of the box.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns Colliders that overlap with the given box. 
         */
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number, queryTriggerInteraction: any): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion, layerMask: number): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3, orientation: Quaternion): Array<Collider>
        static OverlapBox(center: Vector3, halfExtents: Vector3): Array<Collider>
        /** Find all colliders touching or inside of the given box, and store them into the buffer.
         * @param center Center of the box.
         * @param halfExtents Half of the size of the box in each dimension.
         * @param results The buffer to store the results in.
         * @param orientation Rotation of the box.
         * @param layerMask A that is used to selectively ignore colliders when casting a ray.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of colliders stored in results. 
         */
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion, mask: number, queryTriggerInteraction: any): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion, mask: number): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>, orientation: Quaternion): number
        static OverlapBoxNonAlloc(center: Vector3, halfExtents: Vector3, results: Array<Collider>): number
        /** Cast the box along the direction, and store hits in the provided buffer.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param results The buffer to store the results in.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of hits stored to the results buffer. 
         */
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number, layerMask: number): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion, maxDistance: number): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>, orientation: Quaternion): number
        static BoxCastNonAlloc(center: Vector3, halfExtents: Vector3, direction: Vector3, results: Array<RaycastHit>): number
        /** Like Physics.BoxCast, but returns all hits.
         * @param center Center of the box.
         * @param halfExtents Half the size of the box in each dimension.
         * @param direction The direction in which to cast the box.
         * @param orientation Rotation of the box.
         * @param maxDistance The max length of the cast.
         * @param layermask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns All colliders that were hit. 
         */
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number, queryTriggerInteraction: any): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number, layerMask: number): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion, maxDistance: number): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3, orientation: Quaternion): Array<RaycastHit>
        static BoxCastAll(center: Vector3, halfExtents: Vector3, direction: Vector3): Array<RaycastHit>
        /** Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer.
         * @param point0 The center of the sphere at the start of the capsule.
         * @param point1 The center of the sphere at the end of the capsule.
         * @param radius The radius of the capsule.
         * @param results The buffer to store the results into.
         * @param layerMask A that is used to selectively ignore colliders when casting a capsule.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns The amount of entries written to the buffer. 
         */
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>, layerMask: number, queryTriggerInteraction: any): number
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>, layerMask: number): number
        static OverlapCapsuleNonAlloc(point0: Vector3, point1: Vector3, radius: number, results: Array<Collider>): number
        /** Rebuild the broadphase interest regions as well as set the world boundaries.
         * @param worldBounds Boundaries of the physics world.
         * @param subdivisions How many cells to create along x and z axis.
         */
        static RebuildBroadphaseRegions(worldBounds: Bounds, subdivisions: number): void
        /** Prepares the Mesh for use with a MeshCollider.
         * @param meshID The instance ID of the Mesh to bake collision data from.
         * @param convex A flag to indicate whether to bake convex geometry or not.
         */
        static BakeMesh(meshID: number, convex: boolean): void
        /** The gravity applied to all rigid bodies in the Scene.
         */
        static gravity: Vector3
        /** The default contact offset of the newly created colliders.
         */
        static defaultContactOffset: number
        /** The mass-normalized energy threshold, below which objects start going to sleep.
         */
        static sleepThreshold: number
        /** Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default.
         */
        static queriesHitTriggers: boolean
        /** Whether physics queries should hit back-face triangles.
         */
        static queriesHitBackfaces: boolean
        /** Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive.
         */
        static bounceThreshold: number
        /** The maximum default velocity needed to move a Rigidbody's collider out of another collider's surface penetration. Must be positive.
         */
        static defaultMaxDepenetrationVelocity: number
        /** The defaultSolverIterations determines how accurately Rigidbody joints and collision contacts are resolved. (default 6). Must be positive.
         */
        static defaultSolverIterations: number
        /** The defaultSolverVelocityIterations affects how accurately the Rigidbody joints and collision contacts are resolved. (default 1). Must be positive.
         */
        static defaultSolverVelocityIterations: number
        /** Default maximum angular speed of the dynamic Rigidbody, in radians (default 50).
         */
        static defaultMaxAngularSpeed: number
        /** Enables an improved patch friction mode that guarantees static and dynamic friction do not exceed analytical results.
         */
        static improvedPatchFriction: boolean
        /** The PhysicsScene automatically created when Unity starts.
         */
        static readonly defaultPhysicsScene: any
        /** Sets whether the physics should be simulated automatically or not.
         */
        static autoSimulation: boolean
        /** Whether or not to automatically sync transform changes with the physics system whenever a Transform component changes.
         */
        static autoSyncTransforms: boolean
        /** Determines whether the garbage collector should reuse only a single instance of a Collision type for all collision callbacks.
         */
        static reuseCollisionCallbacks: boolean
        /** Sets the minimum separation distance for cloth inter-collision.
         */
        static interCollisionDistance: number
        /** Sets the cloth inter-collision stiffness.
         */
        static interCollisionStiffness: number
        static interCollisionSettingsToggle: boolean
        /** Cloth Gravity setting.
Set gravity for all cloth components.
         */
        static clothGravity: Vector3
        /** Layer mask constant to select ignore raycast layer.
         */
        static readonly IgnoreRaycastLayer: number
        /** Layer mask constant to select default raycast layers.
         */
        static readonly DefaultRaycastLayers: number
        /** Layer mask constant to select all layers.
         */
        static readonly AllLayers: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** A base class of all colliders.
     */
    class Collider extends Component {
        constructor()
        /** Returns a point on the collider that is closest to a given location.
         * @param position Location you want to find the closest point to.
         * @returns The point on the collider that is closest to the specified location. 
         */
        ClosestPoint(position: Vector3): Vector3
        /** Casts a Ray that ignores all Colliders except this one.
         * @param ray The starting point and direction of the ray.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit.
         * @param maxDistance The max length of the ray.
         * @returns True when the ray intersects the collider, otherwise false. 
         */
        Raycast(ray: Ray, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        /** The closest point to the bounding box of the attached collider.
         */
        ClosestPointOnBounds(position: Vector3): Vector3
        /** Enabled Colliders will collide with other Colliders, disabled Colliders won't.
         */
        enabled: boolean
        /** The rigidbody the collider is attached to.
         */
        readonly attachedRigidbody: Rigidbody
        /** The articulation body the collider is attached to.
         */
        readonly attachedArticulationBody: any
        /** Specify if this collider is configured as a trigger.
         */
        isTrigger: boolean
        /** Contact offset value of this collider.
         */
        contactOffset: number
        /** The world space bounding volume of the collider (Read Only).
         */
        readonly bounds: Bounds
        /** Specify whether this Collider's contacts are modifiable or not.
         */
        hasModifiableContacts: boolean
        /** The shared physic material of this collider.
         */
        sharedMaterial: any
        /** The material used by the collider.
         */
        material: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** A box-shaped primitive collider.
     */
    class BoxCollider extends Collider {
        constructor()
        /** The center of the box, measured in the object's local space.
         */
        center: Vector3
        /** The size of the box, measured in the object's local space.
         */
        size: Vector3
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** A sphere-shaped primitive collider.
     */
    class SphereCollider extends Collider {
        constructor()
        /** The center of the sphere in the object's local space.
         */
        center: Vector3
        /** The radius of the sphere measured in the object's local space.
         */
        radius: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array } from "System";
    /** Control of an object's position through physics simulation.
     */
    class Rigidbody extends Component {
        constructor()
        /** Sets the mass based on the attached colliders assuming a constant density.
         */
        SetDensity(density: number): void
        /** Moves the kinematic Rigidbody towards position.
         * @param position Provides the new position for the Rigidbody object.
         */
        MovePosition(position: Vector3): void
        /** Rotates the rigidbody to rotation.
         * @param rot The new rotation for the Rigidbody.
         */
        MoveRotation(rot: Quaternion): void
        Sleep(): void
        IsSleeping(): boolean
        WakeUp(): void
        ResetCenterOfMass(): void
        ResetInertiaTensor(): void
        /** The velocity relative to the rigidbody at the point relativePoint.
         */
        GetRelativePointVelocity(relativePoint: Vector3): Vector3
        /** The velocity of the rigidbody at the point worldPoint in global space.
         */
        GetPointVelocity(worldPoint: Vector3): Vector3
        /** Adds a force to the Rigidbody.
         * @param x Size of force along the world x-axis.
         * @param y Size of force along the world y-axis.
         * @param z Size of force along the world z-axis.
         * @param mode Type of force to apply.
         */
        AddForce(x: number, y: number, z: number, mode: any): void
        /** Adds a force to the Rigidbody.
         * @param x Size of force along the world x-axis.
         * @param y Size of force along the world y-axis.
         * @param z Size of force along the world z-axis.
         * @param mode Type of force to apply.
         */
        AddForce(x: number, y: number, z: number): void
        /** Adds a force to the Rigidbody.
         * @param force Force vector in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForce(force: Vector3, mode: any): void
        /** Adds a force to the Rigidbody.
         * @param force Force vector in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForce(force: Vector3): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param x Size of force along the local x-axis.
         * @param y Size of force along the local y-axis.
         * @param z Size of force along the local z-axis.
         * @param mode Type of force to apply.
         */
        AddRelativeForce(x: number, y: number, z: number, mode: any): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param x Size of force along the local x-axis.
         * @param y Size of force along the local y-axis.
         * @param z Size of force along the local z-axis.
         * @param mode Type of force to apply.
         */
        AddRelativeForce(x: number, y: number, z: number): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param force Force vector in local coordinates.
         * @param mode Type of force to apply.
         */
        AddRelativeForce(force: Vector3, mode: any): void
        /** Adds a force to the rigidbody relative to its coordinate system.
         * @param force Force vector in local coordinates.
         * @param mode Type of force to apply.
         */
        AddRelativeForce(force: Vector3): void
        /** Adds a torque to the rigidbody.
         * @param x Size of torque along the world x-axis.
         * @param y Size of torque along the world y-axis.
         * @param z Size of torque along the world z-axis.
         * @param mode The type of torque to apply.
         */
        AddTorque(x: number, y: number, z: number, mode: any): void
        /** Adds a torque to the rigidbody.
         * @param x Size of torque along the world x-axis.
         * @param y Size of torque along the world y-axis.
         * @param z Size of torque along the world z-axis.
         * @param mode The type of torque to apply.
         */
        AddTorque(x: number, y: number, z: number): void
        /** Adds a torque to the rigidbody.
         * @param torque Torque vector in world coordinates.
         * @param mode The type of torque to apply.
         */
        AddTorque(torque: Vector3, mode: any): void
        /** Adds a torque to the rigidbody.
         * @param torque Torque vector in world coordinates.
         * @param mode The type of torque to apply.
         */
        AddTorque(torque: Vector3): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param x Size of torque along the local x-axis.
         * @param y Size of torque along the local y-axis.
         * @param z Size of torque along the local z-axis.
         * @param mode Type of force to apply.
         */
        AddRelativeTorque(x: number, y: number, z: number, mode: any): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param x Size of torque along the local x-axis.
         * @param y Size of torque along the local y-axis.
         * @param z Size of torque along the local z-axis.
         * @param mode Type of force to apply.
         */
        AddRelativeTorque(x: number, y: number, z: number): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param torque Torque vector in local coordinates.
         * @param mode Type of force to apply.
         */
        AddRelativeTorque(torque: Vector3, mode: any): void
        /** Adds a torque to the rigidbody relative to its coordinate system.
         * @param torque Torque vector in local coordinates.
         * @param mode Type of force to apply.
         */
        AddRelativeTorque(torque: Vector3): void
        /** Applies force at position. As a result this will apply a torque and force on the object.
         * @param force Force vector in world coordinates.
         * @param position Position in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForceAtPosition(force: Vector3, position: Vector3, mode: any): void
        /** Applies force at position. As a result this will apply a torque and force on the object.
         * @param force Force vector in world coordinates.
         * @param position Position in world coordinates.
         * @param mode Type of force to apply.
         */
        AddForceAtPosition(force: Vector3, position: Vector3): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number, mode: any): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number, upwardsModifier: number): void
        /** Applies a force to a rigidbody that simulates explosion effects.
         * @param explosionForce The force of the explosion (which may be modified by distance).
         * @param explosionPosition The centre of the sphere within which the explosion has its effect.
         * @param explosionRadius The radius of the sphere within which the explosion has its effect.
         * @param upwardsModifier Adjustment to the apparent position of the explosion to make it seem to lift objects.
         * @param mode The method used to apply the force to its targets.
         */
        AddExplosionForce(explosionForce: number, explosionPosition: Vector3, explosionRadius: number): void
        /** The closest point to the bounding box of the attached colliders.
         */
        ClosestPointOnBounds(position: Vector3): Vector3
        /** Tests if a rigidbody would collide with anything, if it was moved through the Scene.
         * @param direction The direction into which to sweep the rigidbody.
         * @param hitInfo If true is returned, hitInfo will contain more information about where the collider was hit (Additional resources: RaycastHit).
         * @param maxDistance The length of the sweep.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns True when the rigidbody sweep intersects any collider, otherwise false. 
         */
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number, queryTriggerInteraction: any): boolean
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>, maxDistance: number): boolean
        SweepTest(direction: Vector3, hitInfo: jsb.Out<RaycastHit>): boolean
        /** Like Rigidbody.SweepTest, but returns all hits.
         * @param direction The direction into which to sweep the rigidbody.
         * @param maxDistance The length of the sweep.
         * @param queryTriggerInteraction Specifies whether this query should hit Triggers.
         * @returns An array of all colliders hit in the sweep. 
         */
        SweepTestAll(direction: Vector3, maxDistance: number, queryTriggerInteraction: any): Array<RaycastHit>
        SweepTestAll(direction: Vector3, maxDistance: number): Array<RaycastHit>
        SweepTestAll(direction: Vector3): Array<RaycastHit>
        /** The velocity vector of the rigidbody. It represents the rate of change of Rigidbody position.
         */
        velocity: Vector3
        /** The angular velocity vector of the rigidbody measured in radians per second.
         */
        angularVelocity: Vector3
        /** The drag of the object.
         */
        drag: number
        /** The angular drag of the object.
         */
        angularDrag: number
        /** The mass of the rigidbody.
         */
        mass: number
        /** Controls whether gravity affects this rigidbody.
         */
        useGravity: boolean
        /** Maximum velocity of a rigidbody when moving out of penetrating state.
         */
        maxDepenetrationVelocity: number
        /** Controls whether physics affects the rigidbody.
         */
        isKinematic: boolean
        /** Controls whether physics will change the rotation of the object.
         */
        freezeRotation: boolean
        /** Controls which degrees of freedom are allowed for the simulation of this Rigidbody.
         */
        constraints: any
        /** The Rigidbody's collision detection mode.
         */
        collisionDetectionMode: any
        /** The center of mass relative to the transform's origin.
         */
        centerOfMass: Vector3
        /** The center of mass of the rigidbody in world space (Read Only).
         */
        readonly worldCenterOfMass: Vector3
        /** The rotation of the inertia tensor.
         */
        inertiaTensorRotation: Quaternion
        /** The inertia tensor of this body, defined as a diagonal matrix in a reference frame positioned at this body's center of mass and rotated by Rigidbody.inertiaTensorRotation.
         */
        inertiaTensor: Vector3
        /** Should collision detection be enabled? (By default always enabled).
         */
        detectCollisions: boolean
        /** The position of the rigidbody.
         */
        position: Vector3
        /** The rotation of the Rigidbody.
         */
        rotation: Quaternion
        /** Interpolation allows you to smooth out the effect of running physics at a fixed frame rate.
         */
        interpolation: any
        /** The solverIterations determines how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverIterations. Must be positive.
         */
        solverIterations: number
        /** The mass-normalized energy threshold, below which objects start going to sleep.
         */
        sleepThreshold: number
        /** The maximimum angular velocity of the rigidbody measured in radians per second. (Default 7) range { 0, infinity }.
         */
        maxAngularVelocity: number
        /** The solverVelocityIterations affects how how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverVelocityIterations. Must be positive.
         */
        solverVelocityIterations: number
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array } from "System";
    /** The Resources class allows you to find and access Objects including assets.
     */
    class Resources extends Object1 {
        /** Returns a list of all objects of Type type.
         */
        static FindObjectsOfTypeAll<T extends Object>(type: { new(): T }): T[]
        /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
         * @param path Path to the target resource to load.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object. 
         */
        static Load(path: string, systemTypeInstance: any): Object
        /** Loads an asset stored at path in a Resources folder using an optional systemTypeInstance filter.
         * @param path Path to the target resource to load.
         * @param systemTypeInstance Type filter for objects returned.
         * @returns The requested asset returned as an Object. 
         */
        static Load(path: string): Object
        /** Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        static LoadAsync(path: string, type: any): any
        /** Asynchronously loads an asset stored at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        static LoadAsync(path: string): any
        /** Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         * @param systemTypeInstance Type filter for objects returned.
         */
        static LoadAll(path: string, systemTypeInstance: any): Array<Object>
        /** Loads all assets in a folder or file at path in a Resources folder.
         * @param path Pathname of the target folder. When using the empty string (i.e., ""), the function will load the entire contents of the Resources folder.
         */
        static LoadAll(path: string): Array<Object>
        static GetBuiltinResource(type: any, path: string): Object
        /** Unloads assetToUnload from memory.
         */
        static UnloadAsset(assetToUnload: Object): void
        static UnloadUnusedAssets(): any
        /** Translates an instance ID to an object reference.
         * @param instanceID Instance ID of an Object.
         * @returns Resolved reference or null if the instance ID didn't match anything. 
         */
        static InstanceIDToObject(instanceID: number): Object
        protected constructor()
    }
}
declare module "QuickJS.Unity" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    import { ByteBuffer } from "QuickJS.IO";
    class JSSerializationContext extends Object {
        AddReferencedObject(value: Object1): number
        GetReferencedObject(index: number): Object1
        Flush(byteBuffer: ByteBuffer): void
        AllocByteBuffer(): ByteBuffer
        AllocByteBuffer(): ByteBuffer
        Release(): void
        protected constructor()
        dataFormat: number
    }
}
declare module "QuickJS.Unity" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { Color, Texture } from "UnityEngine";
    import { MonoScript } from "UnityEditor";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class UnityHelper extends Object {
        static GetIcon(name: string): Texture
        static IsApplicationActive(): boolean
        static GenerateBindingsAndTypeDefinition(): void
        static GenerateTypeDefinition(): void
        static GetMonoScript(type: any): MonoScript
        static SetDefineSymbol(defineItem: string, isAdding: boolean): void
        static IsReflectBindingSupported(): boolean
        static Time(name: string, action: () => void): void
        static InvokeReflectBinding(): void
        static IsInMemoryBindingSupported(): boolean
        static InvokeInMemoryBinding(): void
        static CompileScripts(): void
        static ClearBindings(): void
        static OpenPrefsEditor(): void
        static ShowJSConsole(): void
        static ShowJSModuleView(): void
        static ShowScriptEditorWindowLauncher(): void
        static GetPlatform(): string
        static IsExplicitEditorType(type: any): boolean
        static IsExplicitEditorDomain(assembly: any): boolean
        static ReplacePathVars(value: string): string
        static CompileBytecode(workspace: string, assetPaths: any): void
        static CompileBytecode(assetPaths: any): void
        static NormalizePathString(path: string): string
        static ResolveScriptRef(sourceDirBase: string, sourceFile: string, normalizedPath: jsb.Out<string>, modulePath: jsb.Out<string>, hints: any): boolean
        static RowColor: Color
        static SelectRowColor: Color
        static JSBehaviourClassNameRegex: any
        static JSAssetClassNameRegex: any
        static JSCustomEditorClassNameRegex: any
        static JSEditorWindowClassNameRegex: any
    }
}
declare module "QuickJS.Binding" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Prefs extends Object {
        GetModuleStyle(): any
        protected constructor()
        readonly newline: string
        static readonly PATH: string
        filePath: string
        logPath: string
        sourceDir: string
        javascriptDir: string
        outDir: string
        typescriptDir: string
        typescriptExt: string
        xmlDocDir: string
        vendor: string
        jsModulePackInfoPath: string
        genTypescriptDoc: boolean
        editorScripting: boolean
        preferredBindingMethod: string
        enableOperatorOverloading: boolean
        alwaysEmitOperatorMethod: boolean
        enableTypeProxy: boolean
        excludeObsoleteItems: boolean
        editorEntryPoint: string
        assetPostProcessors: any
        editorRequires: any
        editorDecoratorScript: string
        debugCodegen: boolean
        skipDelegateWithByRefParams: boolean
        verboseLog: boolean
        optToString: boolean
        tsdSizeThreshold: number
        alwaysCheckArgType: boolean
        alwaysCheckArgc: boolean
        randomizedBindingCode: boolean
        typeBindingPrefix: string
        ns: string
        defaultJSModule: string
        moduleStyle: string
        singularModuleName: string
        extraExtForTypescript: string
        newLineStyle: string
        tab: string
        skipBinding: any
        cleanupDir: any
        explicitAssemblies: any
        implicitAssemblies: any
        typeFullNameBlacklist: any
        namespaceBlacklist: any
        assemblyBlacklist: any
    }
}
declare module "QuickJS.Utils" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TSConfig extends Object {
        protected constructor()
        compilerOptions: TSConfig.CompilerOptions
        compileOnSave: boolean
        include: Array<string>
        exclude: Array<string>
    }
}
declare module "QuickJS.Utils" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace TSConfig {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class CompilerOptions extends Object {
            protected constructor()
            module_: string
            target: string
            sourceRoot: string
            outDir: string
            outFile: string
            typeRoots: Array<string>
            moduleResolution: string
            types: Array<string>
            listEmittedFiles: boolean
            experimentalDecorators: boolean
            noImplicitAny: boolean
            allowJs: boolean
            inlineSourceMap: boolean
            sourceMap: boolean
        }
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    /** The GUI class is the interface for Unity's GUI with manual positioning.
     */
    class GUI extends Object1 {
        /** Set the name of the next control.
         */
        static SetNextControlName(name: string): void
        static GetNameOfFocusedControl(): string
        /** Move keyboard focus to a named control.
         * @param name Name set using SetNextControlName.
         */
        static FocusControl(name: string): void
        /** Make a window draggable.
         * @param position The part of the window that can be dragged. This is clipped to the actual window.
         */
        static DragWindow(position: Rect): void
        static DragWindow(): void
        /** Bring a specific window to front of the floating windows.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static BringWindowToFront(windowID: number): void
        /** Bring a specific window to back of the floating windows.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static BringWindowToBack(windowID: number): void
        /** Make a window become the active window.
         * @param windowID The identifier used when you created the window in the Window call.
         */
        static FocusWindow(windowID: number): void
        static UnfocusWindow(): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, text: string, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, image: Texture, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, text: string): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, image: Texture): void
        /** Make a text or texture label on screen.
         * @param position Rectangle on the screen to use for the label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Rect, content: GUIContent): void
        /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         * @param color A tint color to apply on the texture.
         * @param borderWidth The width of the border. If 0, the full texture is drawn.
         * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
         * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
         * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidth: number, borderRadius: number): void
        /** Draws a border with rounded corners within a rectangle. The texture is used to pattern the border.  Note that this method only works on shader model 2.5 and above.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         * @param color A tint color to apply on the texture.
         * @param borderWidth The width of the border. If 0, the full texture is drawn.
         * @param borderWidths The width of the borders (left, top, right and bottom). If Vector4.zero, the full texture is drawn.
         * @param borderRadius The radius for rounded corners. If 0, corners will not be rounded.
         * @param borderRadiuses The radiuses for rounded corners (top-left, top-right, bottom-right and bottom-left). If Vector4.zero, corners will not be rounded.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidths: Vector4, borderRadius: number): void
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number, color: Color, borderWidths: Vector4, borderRadiuses: Vector4): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean, imageAspect: number): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode, alphaBlend: boolean): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture, scaleMode: ScaleMode): void
        /** Draw a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to apply alpha blending when drawing the image (enabled by default).
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.  Pass in w/h for the desired aspect ratio.  This allows the aspect ratio of the source image to be adjusted without changing the pixel width and height.
         */
        static DrawTexture(position: Rect, image: Texture): void
        /** Draw a texture within a rectangle with the given texture coordinates.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
         */
        static DrawTextureWithTexCoords(position: Rect, image: Texture, texCoords: Rect, alphaBlend: boolean): void
        /** Draw a texture within a rectangle with the given texture coordinates.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param texCoords How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param alphaBlend Whether to alpha blend the image on to the display (the default). If false, the picture is drawn on to the display.
         */
        static DrawTextureWithTexCoords(position: Rect, image: Texture, texCoords: Rect): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, text: string, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, image: Texture, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, text: string): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, image: Texture): void
        /** Create a Box on the GUI Layer.
         * @param position Rectangle on the screen to use for the box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         */
        static Box(position: Rect, content: GUIContent): void
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, text: string, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, image: Texture, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, content: GUIContent, style: GUIStyle): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, text: string): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, image: Texture): boolean
        /** Make a single press button. The user clicks them and something happens immediately.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns true when the users clicks the button. 
         */
        static Button(position: Rect, content: GUIContent): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, text: string, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, image: Texture, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, content: GUIContent, style: GUIStyle): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, text: string): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, image: Texture): boolean
        /** Make a button that is active as long as the user holds it down.
         * @param position Rectangle on the screen to use for the button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns True when the users clicks the button. 
         */
        static RepeatButton(position: Rect, content: GUIContent): boolean
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, maxLength: number, style: GUIStyle): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, maxLength: number): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string, style: GUIStyle): string
        /** Make a single-line text field where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextField(position: Rect, text: string): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, maxLength: number, style: GUIStyle): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, maxLength: number): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string, style: GUIStyle): string
        /** Make a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the text field.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(position: Rect, password: string, maskChar: string): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, maxLength: number, style: GUIStyle): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, maxLength: number): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string, style: GUIStyle): string
        /** Make a Multi-line text area where the user can edit a string.
         * @param position Rectangle on the screen to use for the text field.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @returns The edited string. 
         */
        static TextArea(position: Rect, text: string): string
        static Toggle(position: Rect, id: number, value: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, text: string, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, image: Texture, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, text: string): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, image: Texture): boolean
        /** Make an on/off toggle button.
         * @param position Rectangle on the screen to use for the button.
         * @param value Is this button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the toggle style from the current GUISkin is used.
         * @returns The new value of the button. 
         */
        static Toggle(position: Rect, value: boolean, content: GUIContent): boolean
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>, style: GUIStyle, buttonSize: any): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, texts: Array<string>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, images: Array<Texture>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>, style: GUIStyle): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, texts: Array<string>): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, images: Array<Texture>): number
        /** Make a toolbar.
         * @param position Rectangle on the screen to use for the toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the toolbar buttons.
         * @param images An array of textures on the toolbar buttons.
         * @param contents An array of text, image and tooltips for the toolbar buttons.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(position: Rect, selected: number, contents: Array<GUIContent>): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, texts: Array<string>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, images: Array<Texture>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, contents: Array<GUIContent>, xCount: number, style: GUIStyle): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, texts: Array<string>, xCount: number): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, images: Array<Texture>, xCount: number): number
        /** Make a grid of buttons.
         * @param position Rectangle on the screen to use for the grid.
         * @param selected The index of the selected grid button.
         * @param texts An array of strings to show on the grid buttons.
         * @param images An array of textures on the grid buttons.
         * @param contents An array of text, image and tooltips for the grid button.
         * @param xCount How many elements to fit in the horizontal direction. The controls will be scaled to fit unless the style defines a fixedWidth to use.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(position: Rect, selected: number, content: Array<GUIContent>, xCount: number): number
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(position: Rect, value: number, leftValue: number, rightValue: number): number
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number, slider: GUIStyle, thumb: GUIStyle, thumbExtent: GUIStyle): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number, slider: GUIStyle, thumb: GUIStyle): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(position: Rect, value: number, topValue: number, bottomValue: number): number
        static Slider(position: Rect, value: number, size: number, start: number, end: number, slider: GUIStyle, thumb: GUIStyle, horiz: boolean, id: number, thumbExtent: GUIStyle): number
        /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(position: Rect, value: number, size: number, leftValue: number, rightValue: number, style: GUIStyle): number
        /** Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(position: Rect, value: number, size: number, leftValue: number, rightValue: number): number
        /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top of the scrollbar.
         * @param bottomValue The value at the bottom of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(position: Rect, value: number, size: number, topValue: number, bottomValue: number, style: GUIStyle): number
        /** Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead.
         * @param position Rectangle on the screen to use for the scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top of the scrollbar.
         * @param bottomValue The value at the bottom of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(position: Rect, value: number, size: number, topValue: number, bottomValue: number): number
        static BeginClip(position: Rect, scrollOffset: Vector2, renderOffset: Vector2, resetOffset: boolean): void
        static BeginClip(position: Rect): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, text: string, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, image: Texture, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, text: string): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, image: Texture): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, content: GUIContent): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect, style: GUIStyle): void
        /** Begin a group. Must be matched with a call to EndGroup.
         * @param position Rectangle on the screen to use for the group.
         * @param text Text to display on the group.
         * @param image Texture to display on the group.
         * @param content Text, image and tooltip for this group. If supplied, any mouse clicks are "captured" by the group and not If left out, no background is rendered, and mouse clicks are passed.
         * @param style The style to use for the background.
         */
        static BeginGroup(position: Rect): void
        static EndGroup(): void
        static EndClip(): void
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle): Vector2
        /** Begin a scrolling view inside your GUI.
         * @param position Rectangle on the screen to use for the ScrollView.
         * @param scrollPosition The pixel distance that the view is scrolled in the X and Y directions.
         * @param viewRect The rectangle used inside the scrollview.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @param alwaysShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when viewRect is wider than position.
         * @param alwaysShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when viewRect is taller than position.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(position: Rect, scrollPosition: Vector2, viewRect: Rect): Vector2
        /** Ends a scrollview started with a call to BeginScrollView.
         */
        static EndScrollView(handleScrollWheel: boolean): void
        static EndScrollView(): void
        /** Scrolls all enclosing scrollviews so they try to make position visible.
         */
        static ScrollTo(position: Rect): void
        static ScrollTowards(position: Rect, maxDelta: number): boolean
        static Window(id: number, clientRect: Rect, func: (id: number) => void, text: string, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, title: GUIContent, style: GUIStyle): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, text: string): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, image: Texture): Rect
        static Window(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, text: string, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent, style: GUIStyle): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, text: string): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, image: Texture): Rect
        static ModalWindow(id: number, clientRect: Rect, func: (id: number) => void, content: GUIContent): Rect
        protected constructor()
        /** Applies a global tint to the GUI. The tint affects backgrounds and text colors.
         */
        static color: Color
        /** Global tinting color for all background elements rendered by the GUI.
         */
        static backgroundColor: Color
        /** Tinting color for all text rendered by the GUI.
         */
        static contentColor: Color
        /** Returns true if any controls changed the value of the input data.
         */
        static changed: boolean
        /** Is the GUI enabled?
         */
        static enabled: boolean
        /** The sorting depth of the currently executing GUI behaviour.
         */
        static depth: number
        /** The global skin to use.
         */
        static skin: GUISkin
        /** The GUI transform matrix.
         */
        static matrix: Matrix4x4
        /** The tooltip of the control the mouse is currently over, or which has keyboard focus. (Read Only).
         */
        static tooltip: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** Utility class for making new GUI controls.
     */
    class GUIUtility extends Object1 {
        /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(contents: GUIContent, focus: FocusType, position: Rect): number
        /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(hint: number, focusType: FocusType, rect: Rect): number
        /** Get a unique ID for a control, using a the label content as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(contents: GUIContent, focus: FocusType): number
        /** Get a unique ID for a control.
         */
        static GetControlID(focus: FocusType, position: Rect): number
        /** Get a unique ID for a control, using an integer as a hint to help ensure correct matching of IDs to controls.
         */
        static GetControlID(hint: number, focus: FocusType): number
        /** Get a unique ID for a control.
         */
        static GetControlID(focus: FocusType): number
        /** Get a state object from a controlID.
         */
        static GetStateObject(t: any, controlID: number): Object1
        /** Get an existing state object from a controlID.
         */
        static QueryStateObject(t: any, controlID: number): Object1
        static ExitGUI(): void
        /** Convert a point from GUI position to screen space.
         */
        static GUIToScreenPoint(guiPoint: Vector2): Vector2
        /** Convert a rect from GUI position to screen space.
         */
        static GUIToScreenRect(guiRect: Rect): Rect
        /** Convert a point from screen space to GUI position.
         */
        static ScreenToGUIPoint(screenPoint: Vector2): Vector2
        /** Convert a rect from screen space to GUI position.
         */
        static ScreenToGUIRect(screenRect: Rect): Rect
        /** Helper function to rotate the GUI around a point.
         */
        static RotateAroundPivot(angle: number, pivotPoint: Vector2): void
        /** Helper function to scale the GUI around a point.
         */
        static ScaleAroundPivot(scale: Vector2, pivotPoint: Vector2): void
        /** Align a local space rectangle to the pixel grid.
         * @param local The local space rectangle that needs to be processed.
         * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @returns The aligned rectangle in local space. 
         */
        static AlignRectToDevice(rect: Rect, widthInPixels: jsb.Out<number>, heightInPixels: jsb.Out<number>): Rect
        /** Align a local space rectangle to the pixel grid.
         * @param local The local space rectangle that needs to be processed.
         * @param widthInPixels Width, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @param heightInPixels Height, in pixel units, of the axis-aligned bounding box that encompasses the aligned points.
         * @returns The aligned rectangle in local space. 
         */
        static AlignRectToDevice(rect: Rect): Rect
        protected constructor()
        /** The controlID of the current hot control.
         */
        static hotControl: number
        /** The controlID of the control that has keyboard focus.
         */
        static keyboardControl: number
        /** A global property, which is true if a ModalWindow is being displayed, false otherwise.
         */
        static readonly hasModalWindow: boolean
        /** Get access to the system-wide clipboard.
         */
        static systemCopyBuffer: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, Enum } from "System";
    /** The GUILayout class is the interface for Unity gui with automatic layout.
     */
    class GUILayout extends Object1 {
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(image: Texture, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(text: string, ...options: GUILayoutOption[]): void
        /** Make an auto-layout label.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Label(content: GUIContent, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(image: Texture, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(text: string, ...options: GUILayoutOption[]): void
        /** Make an auto-layout box.
         * @param text Text to display on the box.
         * @param image Texture to display on the box.
         * @param content Text, image and tooltip for this box.
         * @param style The style to use. If left out, the box style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Box(content: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(text: string, ...options: GUILayoutOption[]): boolean
        /** Make a single press button.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the users clicks the button. 
         */
        static Button(content: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(text: string, ...options: GUILayoutOption[]): boolean
        /** Make a repeating button. The button returns true as long as the user holds down the mouse.
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the holds down the mouse. 
         */
        static RepeatButton(content: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a single-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textArea style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param password Password to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maskChar Character to mask the password with.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @returns The edited password. 
         */
        static PasswordField(password: string, maskChar: string, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, maxLength: number, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, maxLength: number, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a multi-line text field where the user can edit a string.
         * @param text Text to edit. The return value of this function should be assigned back to the string as shown in the example.
         * @param maxLength The maximum length of the string. If left out, the user can type for ever and ever.
         * @param style The style to use. If left out, the textField style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.&amp;lt;br&amp;gt;
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The edited string. 
         */
        static TextArea(text: string, ...options: GUILayoutOption[]): string
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, text: string, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, image: Texture, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, text: string, ...options: GUILayoutOption[]): boolean
        /** Make an on/off toggle button.
         * @param value Is the button on or off?
         * @param text Text to display on the button.
         * @param image Texture to display on the button.
         * @param content Text, image and tooltip for this button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The new value of the button. 
         */
        static Toggle(value: boolean, content: GUIContent, ...options: GUILayoutOption[]): boolean
        static Toolbar(selected: number, contents: Array<GUIContent>, enabled: Array<boolean>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, texts: Array<string>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, images: Array<Texture>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, contents: Array<GUIContent>, style: GUIStyle, buttonSize: any, ...options: GUILayoutOption[]): number
        static Toolbar(selected: number, contents: Array<GUIContent>, enabled: Array<boolean>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, texts: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, images: Array<Texture>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, contents: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, texts: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, images: Array<Texture>, ...options: GUILayoutOption[]): number
        /** Make a toolbar.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param buttonSize Determines how toolbar button size is calculated.
         * @returns The index of the selected button. 
         */
        static Toolbar(selected: number, contents: Array<GUIContent>, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, texts: Array<string>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, images: Array<Texture>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, contents: Array<GUIContent>, xCount: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, texts: Array<string>, xCount: number, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, images: Array<Texture>, xCount: number, ...options: GUILayoutOption[]): number
        /** Make a Selection Grid.
         * @param selected The index of the selected button.
         * @param texts An array of strings to show on the buttons.
         * @param images An array of textures on the buttons.
         * @param contents An array of text, image and tooltips for the button.
         * @param xCount How many elements to fit in the horizontal direction. The elements will be scaled to fit unless the style defines a fixedWidth to use. The height of the control will be determined from the number of elements.
         * @param style The style to use. If left out, the button style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the selected button. 
         */
        static SelectionGrid(selected: number, content: Array<GUIContent>, xCount: number, ...options: GUILayoutOption[]): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, ...options: GUILayoutOption[]): number
        /** A horizontal slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static HorizontalSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(value: number, leftValue: number, rightValue: number, slider: GUIStyle, thumb: GUIStyle, ...options: GUILayoutOption[]): number
        /** A vertical slider the user can drag to change a value between a min and a max.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param topValue The value at the top end of the slider.
         * @param bottomValue The value at the bottom end of the slider.
         * @param slider The GUIStyle to use for displaying the dragging area. If left out, the horizontalSlider style from the current GUISkin is used.
         * @param thumb The GUIStyle to use for displaying draggable thumb. If left out, the horizontalSliderThumb style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The value that has been set by the user. 
         */
        static VerticalSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a horizontal scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(value: number, size: number, leftValue: number, rightValue: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a horizontal scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param leftValue The value at the left end of the scrollbar.
         * @param rightValue The value at the right end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static HorizontalScrollbar(value: number, size: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a vertical scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top end of the scrollbar.
         * @param bottomValue The value at the bottom end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(value: number, size: number, topValue: number, bottomValue: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a vertical scrollbar.
         * @param value The position between min and max.
         * @param size How much can we see?
         * @param topValue The value at the top end of the scrollbar.
         * @param bottomValue The value at the bottom end of the scrollbar.
         * @param style The style to use for the scrollbar background. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.
         * @returns The modified value. This can be changed by the user by dragging the scrollbar, or clicking the arrows at the end. 
         */
        static VerticalScrollbar(value: number, size: number, topValue: number, bottomValue: number, ...options: GUILayoutOption[]): number
        /** Insert a space in the current layout group.
         */
        static Space(pixels: number): void
        static FlexibleSpace(): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a Horizontal control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(...options: GUILayoutOption[]): void
        static EndHorizontal(): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Begin a vertical control group.
         * @param text Text to display on group.
         * @param image Texture to display on group.
         * @param content Text, image, and tooltip for this group.
         * @param style The style to use for background image and padding values. If left out, the background is transparent.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(...options: GUILayoutOption[]): void
        static EndVertical(): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, text: string, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, image: Texture, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, content: GUIContent, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, text: string): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, image: Texture): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, content: GUIContent): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect, style: GUIStyle): void
        /** Begin a GUILayout block of GUI controls in a fixed screen area.
         * @param text Optional text to display in the area.
         * @param image Optional texture to display in the area.
         * @param content Optional text, image and tooltip top display for this area.
         * @param style The style to use. If left out, the empty GUIStyle (GUIStyle.none) is used, giving a transparent background.
         */
        static BeginArea(screenRect: Rect): void
        static EndArea(): void
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, ...options: GUILayoutOption[]): Vector2
        static EndScrollView(): void
        static Window(id: number, screenRect: Rect, func: (id: number) => void, text: string, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, image: Texture, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, text: string, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, image: Texture, ...options: GUILayoutOption[]): Rect
        static Window(id: number, screenRect: Rect, func: (id: number) => void, content: GUIContent, ...options: GUILayoutOption[]): Rect
        /** Option passed to a control to give it an absolute width.
         */
        static Width(width: number): GUILayoutOption
        /** Option passed to a control to specify a minimum width.

         */
        static MinWidth(minWidth: number): GUILayoutOption
        /** Option passed to a control to specify a maximum width.
         */
        static MaxWidth(maxWidth: number): GUILayoutOption
        /** Option passed to a control to give it an absolute height.
         */
        static Height(height: number): GUILayoutOption
        /** Option passed to a control to specify a minimum height.
         */
        static MinHeight(minHeight: number): GUILayoutOption
        /** Option passed to a control to specify a maximum height.
         */
        static MaxHeight(maxHeight: number): GUILayoutOption
        /** Option passed to a control to allow or disallow horizontal expansion.
         */
        static ExpandWidth(expand: boolean): GUILayoutOption
        /** Option passed to a control to allow or disallow vertical expansion.
         */
        static ExpandHeight(expand: boolean): GUILayoutOption
        protected constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** Utility functions for implementing and extending the GUILayout class.
     */
    class GUILayoutUtility extends Object1 {
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, style: GUIStyle): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number): Rect
        /** Reserve layout space for a flexible rect.
         * @param minWidth The minimum width of the area passed back.
         * @param maxWidth The maximum width of the area passed back.
         * @param minHeight The minimum width of the area passed back.
         * @param maxHeight The maximum width of the area passed back.
         * @param style An optional style. If specified, the style's padding value will be added to the sizes requested & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle with size between minWidth & maxWidth on both axes. 
         */
        static GetRect(minWidth: number, maxWidth: number, minHeight: number, maxHeight: number, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectangle to put your control in. 
         */
        static GetRect(width: number, height: number, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectangle to put your control in. 
         */
        static GetRect(width: number, height: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle for displaying some contents with a specific style.
         * @param content The content to make room for displaying.
         * @param style The GUIStyle to layout for.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle that is large enough to contain content when rendered in style. 
         */
        static GetRect(content: GUIContent, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectangle to put your control in. 
         */
        static GetRect(width: number, height: number): Rect
        /** Reserve layout space for a rectangle for displaying some contents with a specific style.
         * @param content The content to make room for displaying.
         * @param style The GUIStyle to layout for.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns A rectangle that is large enough to contain content when rendered in style. 
         */
        static GetRect(content: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a fixed content area.
         * @param width The width of the area you want.
         * @param height The height of the area you want.
         * @param style An optional GUIStyle to layout for. If specified, the style's padding value will be added to your sizes & its margin value will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rectangle to put your control in. 
         */
        static GetRect(width: number, height: number, ...options: GUILayoutOption[]): Rect
        static GetLastRect(): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, style: GUIStyle): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number): Rect
        /** Reserve layout space for a rectangle with a specific aspect ratio.
         * @param aspect The aspect ratio of the element (width / height).
         * @param style An optional style. If specified, the style's padding value will be added to the sizes of the returned rectangle & the style's margin values will be used for spacing.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The rect for the control. 
         */
        static GetAspectRect(aspect: number, ...options: GUILayoutOption[]): Rect
        protected constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** Class internally used to pass layout options into GUILayout functions. You don't use these directly, but construct them with the layouting functions in the GUILayout class.
     */
    class GUILayoutOption extends Object1 {
        protected constructor()
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    /** The contents of a GUI element.
     */
    class GUIContent extends Object1 {
        constructor(text: string, image: Texture, tooltip: string)
        constructor(text: string, image: Texture)
        constructor(text: string, tooltip: string)
        constructor(image: Texture, tooltip: string)
        constructor(text: string)
        constructor(image: Texture)
        constructor(src: GUIContent)
        constructor()
        toString(): string
        /** The text contained.
         */
        text: string
        /** The icon image contained.
         */
        image: Texture
        /** The tooltip of this element.
         */
        tooltip: string
        /** Shorthand for empty content.
         */
        static none: GUIContent
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array, Object as Object1 } from "System";
    import { IEnumerator } from "System.Collections";
    /** Defines how GUI looks and behaves.
     */
    class GUISkin extends ScriptableObject {
        constructor()
        /** Get a named GUIStyle.
         */
        GetStyle(styleName: string): GUIStyle
        /** Try to search for a GUIStyle. This functions returns NULL and does not give an error.
         */
        FindStyle(styleName: string): GUIStyle
        GetEnumerator(): IEnumerator
        /** The default font to use for all styles.
         */
        font: any
        /** Style used by default for GUI.Box controls.
         */
        box: GUIStyle
        /** Style used by default for GUI.Label controls.
         */
        label: GUIStyle
        /** Style used by default for GUI.TextField controls.
         */
        textField: GUIStyle
        /** Style used by default for GUI.TextArea controls.
         */
        textArea: GUIStyle
        /** Style used by default for GUI.Button controls.
         */
        button: GUIStyle
        /** Style used by default for GUI.Toggle controls.
         */
        toggle: GUIStyle
        /** Style used by default for Window controls (Additional resources: GUI.Window).
         */
        window: GUIStyle
        /** Style used by default for the background part of GUI.HorizontalSlider controls.
         */
        horizontalSlider: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.HorizontalSlider controls.
         */
        horizontalSliderThumb: GUIStyle
        /** Style used by default for the background part of GUI.VerticalSlider controls.
         */
        verticalSlider: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.VerticalSlider controls.
         */
        verticalSliderThumb: GUIStyle
        /** Style used by default for the background part of GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbar: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarThumb: GUIStyle
        /** Style used by default for the left button on GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarLeftButton: GUIStyle
        /** Style used by default for the right button on GUI.HorizontalScrollbar controls.
         */
        horizontalScrollbarRightButton: GUIStyle
        /** Style used by default for the background part of GUI.VerticalScrollbar controls.
         */
        verticalScrollbar: GUIStyle
        /** Style used by default for the thumb that is dragged in GUI.VerticalScrollbar controls.
         */
        verticalScrollbarThumb: GUIStyle
        /** Style used by default for the up button on GUI.VerticalScrollbar controls.
         */
        verticalScrollbarUpButton: GUIStyle
        /** Style used by default for the down button on GUI.VerticalScrollbar controls.
         */
        verticalScrollbarDownButton: GUIStyle
        /** Style used by default for the background of ScrollView controls (see GUI.BeginScrollView).
         */
        scrollView: GUIStyle
        /** Array of GUI styles for specific needs.
         */
        customStyles: Array<GUIStyle>
        /** Generic settings for how controls should behave with this skin.
         */
        readonly settings: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum } from "System";
    /** Styling information for GUI elements.
     */
    class GUIStyle extends Object1 {
        constructor(other: GUIStyle)
        constructor()
        /** Draw the GUIStyle with a text string inside.
         */
        Draw(position: Rect, text: string, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw the GUIStyle with an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, image: Texture, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        /** Draw this GUIStyle on to the screen, internal version.
         */
        Draw(position: Rect, isHover: boolean, isActive: boolean, on: boolean, hasKeyboardFocus: boolean): void
        Draw(position: Rect, content: GUIContent, controlID: number, on: boolean, hover: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, controlID: number, on: boolean): void
        /** Draw the GUIStyle with text and an image inside. If the image is too large to fit within the content area of the style it is scaled down.
         */
        Draw(position: Rect, content: GUIContent, controlID: number): void
        /** Draw this GUIStyle with selected content.
         */
        DrawCursor(position: Rect, content: GUIContent, controlID: number, character: number): void
        /** Draw this GUIStyle with selected content.
         */
        DrawWithTextSelection(position: Rect, content: GUIContent, controlID: number, firstSelectedCharacter: number, lastSelectedCharacter: number): void
        /** Get the pixel position of a given string index.
         */
        GetCursorPixelPosition(position: Rect, content: GUIContent, cursorStringIndex: number): Vector2
        /** Get the cursor position (indexing into contents.text) when the user clicked at cursorPixelPosition.
         */
        GetCursorStringIndex(position: Rect, content: GUIContent, cursorPixelPosition: Vector2): number
        /** Calculate the size of some content if it is rendered with this style.
         */
        CalcSize(content: GUIContent): Vector2
        /** Calculate the size of an element formatted with this style, and a given space to content.
         */
        CalcScreenSize(contentSize: Vector2): Vector2
        /** How tall this element will be when rendered with content and a specific width.
         */
        CalcHeight(content: GUIContent, width: number): number
        /** Calculate the minimum and maximum widths for this style rendered with content.
         */
        CalcMinMaxWidth(content: GUIContent, minWidth: jsb.Out<number>, maxWidth: jsb.Out<number>): void
        toString(): string
        static op_Implicit(str: string): GUIStyle
        /** The font to use for rendering. If null, the default font for the current GUISkin is used instead.
         */
        font: any
        /** How image and text of the GUIContent is combined.
         */
        imagePosition: any
        /** Text alignment.
         */
        alignment: TextAnchor
        /** Should the text be wordwrapped?
         */
        wordWrap: boolean
        /** What to do when the contents to be rendered is too large to fit within the area given.
         */
        clipping: any
        /** Pixel offset to apply to the content of this GUIstyle.
         */
        contentOffset: Vector2
        /** If non-0, any GUI elements rendered with this style will have the width specified here.
         */
        fixedWidth: number
        /** If non-0, any GUI elements rendered with this style will have the height specified here.
         */
        fixedHeight: number
        /** Can GUI elements of this style be stretched horizontally for better layouting?
         */
        stretchWidth: boolean
        /** Can GUI elements of this style be stretched vertically for better layout?
         */
        stretchHeight: boolean
        /** The font size to use (for dynamic fonts).
         */
        fontSize: number
        /** The font style to use (for dynamic fonts).
         */
        fontStyle: any
        /** Enable HTML-style tags for Text Formatting Markup.
         */
        richText: boolean
        /** The name of this GUIStyle. Used for getting them based on name.
         */
        name: string
        /** Rendering settings for when the component is displayed normally.
         */
        normal: any
        /** Rendering settings for when the mouse is hovering over the control.
         */
        hover: any
        /** Rendering settings for when the control is pressed down.
         */
        active: any
        /** Rendering settings for when the control is turned on.
         */
        onNormal: any
        /** Rendering settings for when the control is turned on and the mouse is hovering it.
         */
        onHover: any
        /** Rendering settings for when the element is turned on and pressed down.
         */
        onActive: any
        /** Rendering settings for when the element has keyboard focus.
         */
        focused: any
        /** Rendering settings for when the element has keyboard and is turned on.
         */
        onFocused: any
        /** The borders of all background images.
         */
        border: any
        /** The margins between elements rendered in this style and any other GUI elements.
         */
        margin: any
        /** Space from the edge of GUIStyle to the start of the contents.
         */
        padding: any
        /** Extra space to be added to the background image.
         */
        overflow: any
        /** The height of one line of text with this style, measured in pixels. (Read Only)
         */
        readonly lineHeight: number
        /** Shortcut for an empty GUIStyle.
         */
        static readonly none: GUIStyle
        readonly isHeightDependantOnWidth: boolean
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Where the anchor of the text is placed.
     */
    enum TextAnchor {
        /** Text is anchored in upper left corner.
         */
        UpperLeft = 0,
        /** Text is anchored in upper side, centered horizontally.
         */
        UpperCenter = 1,
        /** Text is anchored in upper right corner.
         */
        UpperRight = 2,
        /** Text is anchored in left side, centered vertically.
         */
        MiddleLeft = 3,
        /** Text is centered both horizontally and vertically.
         */
        MiddleCenter = 4,
        /** Text is anchored in right side, centered vertically.
         */
        MiddleRight = 5,
        /** Text is anchored in lower left corner.
         */
        LowerLeft = 6,
        /** Text is anchored in lower side, centered horizontally.
         */
        LowerCenter = 7,
        /** Text is anchored in lower right corner.
         */
        LowerRight = 8,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Scaling mode to draw textures with.
     */
    enum ScaleMode {
        /** Stretches the texture to fill the complete rectangle passed in to GUI.DrawTexture.
         */
        StretchToFill = 0,
        /** Scales the texture, maintaining aspect ratio, so it completely covers the position rectangle passed to GUI.DrawTexture. If the texture is being draw to a rectangle with a different aspect ratio than the original, the image is cropped.
         */
        ScaleAndCrop = 1,
        /** Scales the texture, maintaining aspect ratio, so it completely fits withing the position rectangle passed to GUI.DrawTexture.
         */
        ScaleToFit = 2,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Used by GUIUtility.GetControlID to inform the IMGUI system if a given control can get keyboard focus. This allows the IMGUI system to give focus appropriately when a user presses tab for cycling between controls.
     */
    enum FocusType {
        Native = 0,
        /** This control can receive keyboard focus.
         */
        Keyboard = 1,
        /** This control can not receive keyboard focus.
         */
        Passive = 2,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Enum, Array } from "System";
    /** A container for audio data.
     */
    class AudioClip extends Object {
        LoadAudioData(): boolean
        UnloadAudioData(): boolean
        /** Fills an array with sample data from the clip.
         */
        GetData(data: Array<number>, offsetSamples: number): boolean
        /** Set sample data in a clip.
         */
        SetData(data: Array<number>, offsetSamples: number): boolean
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: (data: Array<number>) => void, pcmsetpositioncallback: (id: number) => void): AudioClip
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean, pcmreadercallback: (data: Array<number>) => void): AudioClip
        /** Creates a user AudioClip with a name and with the given length in samples, channels and frequency.
         * @param name Name of clip.
         * @param lengthSamples Number of sample frames.
         * @param channels Number of channels per frame.
         * @param frequency Sample frequency of clip.
         * @param _3D Audio clip is played back in 3D.
         * @param stream True if clip is streamed, that is if the pcmreadercallback generates data on the fly.
         * @param pcmreadercallback This callback is invoked to generate a block of sample data. Non-streamed clips call this only once at creation time while streamed clips call this continuously.
         * @param pcmsetpositioncallback This callback is invoked whenever the clip loops or changes playback position.
         * @returns A reference to the created AudioClip. 
         */
        static Create(name: string, lengthSamples: number, channels: number, frequency: number, stream: boolean): AudioClip
        protected constructor()
        /** The length of the audio clip in seconds. (Read Only)
         */
        readonly length: number
        /** The length of the audio clip in samples. (Read Only)
         */
        readonly samples: number
        /** The number of channels in the audio clip. (Read Only)
         */
        readonly channels: number
        /** The sample frequency of the clip in Hertz. (Read Only)
         */
        readonly frequency: number
        /** The load type of the clip (read-only).
         */
        readonly loadType: any
        /** Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.
         */
        readonly preloadAudioData: boolean
        /** Returns true if this audio clip is ambisonic (read-only).
         */
        readonly ambisonic: boolean
        /** Corresponding to the "Load In Background" flag in the inspector, when this flag is set, the loading will happen delayed without blocking the main thread.
         */
        readonly loadInBackground: boolean
        /** Returns the current load state of the audio data associated with an AudioClip.
         */
        readonly loadState: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** A 2D Rectangle defined by x, y, width, height with integers.
     */
    class RectInt extends ValueType {
        constructor(xMin: number, yMin: number, width: number, height: number)
        constructor(position: Vector2Int, size: Vector2Int)
        /** Sets the bounds to the min and max value of the rect.
         */
        SetMinMax(minPosition: Vector2Int, maxPosition: Vector2Int): void
        /** Clamps the position and size of the RectInt to the given bounds.
         * @param bounds Bounds to clamp the RectInt.
         */
        ClampToBounds(bounds: RectInt): void
        /** Returns true if the given position is within the RectInt.
         * @param position Position to check.
         * @returns Whether the position is within the RectInt. 
         */
        Contains(position: Vector2Int): boolean
        /** RectInts overlap if each RectInt Contains a shared point.
         * @param other Other rectangle to test overlapping with.
         * @returns True if the other rectangle overlaps this one. 
         */
        Overlaps(other: RectInt): boolean
        /** Returns the x, y, width and height of the RectInt.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns the x, y, width and height of the RectInt.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        /** Returns true if the given RectInt is equal to this RectInt.
         */
        Equals(other: RectInt): boolean
        Equals(obj: Object1): boolean
        /** Left coordinate of the rectangle.
         */
        x: number
        /** Top coordinate of the rectangle.
         */
        y: number
        /** Center coordinate of the rectangle.
         */
        readonly center: Vector2
        /** The lower left corner of the rectangle; which is the minimal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
         */
        min: Vector2Int
        /** The upper right corner of the rectangle; which is the maximal position of the rectangle along the x- and y-axes, when it is aligned to both axes.
         */
        max: Vector2Int
        /** Width of the rectangle.
         */
        width: number
        /** Height of the rectangle.
         */
        height: number
        /** Shows the minimum X value of the RectInt.
         */
        xMin: number
        /** Show the minimum Y value of the RectInt.
         */
        yMin: number
        /** Shows the maximum X value of the RectInt.
         */
        xMax: number
        /** Shows the maximum Y value of the RectInt.
         */
        yMax: number
        /** Returns the position (x, y) of the RectInt.
         */
        position: Vector2Int
        /** Returns the width and height of the RectInt.
         */
        size: Vector2Int
        /** A RectInt.PositionCollection that contains all positions within the RectInt.
         */
        readonly allPositionsWithin: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Represents an axis aligned bounding box.
     */
    class Bounds extends ValueType {
        constructor(center: Vector3, size: Vector3)
        /** Is point contained in the bounding box?
         */
        Contains(point: Vector3): boolean
        /** The smallest squared distance between the point and this bounding box.
         */
        SqrDistance(point: Vector3): number
        /** The closest point on the bounding box.
         * @param point Arbitrary point.
         * @returns The point on the bounding box or inside the bounding box. 
         */
        ClosestPoint(point: Vector3): Vector3
        GetHashCode(): number
        Equals(other: Object1): boolean
        Equals(other: Bounds): boolean
        /** Sets the bounds to the min and max value of the box.
         */
        SetMinMax(min: Vector3, max: Vector3): void
        /** Grows the Bounds to include the point.
         */
        Encapsulate(point: Vector3): void
        /** Grow the bounds to encapsulate the bounds.
         */
        Encapsulate(bounds: Bounds): void
        /** Expand the bounds by increasing its size by amount along each side.
         */
        Expand(amount: number): void
        /** Expand the bounds by increasing its size by amount along each side.
         */
        Expand(amount: Vector3): void
        /** Does another bounding box intersect with this bounding box?
         */
        Intersects(bounds: Bounds): boolean
        /** Does ray intersect this bounding box?
         */
        IntersectRay(ray: Ray, distance: jsb.Out<number>): boolean
        /** Does ray intersect this bounding box?
         */
        IntersectRay(ray: Ray): boolean
        /** Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        static op_Equality(lhs: Bounds, rhs: Bounds): boolean
        static op_Inequality(lhs: Bounds, rhs: Bounds): boolean
        // js_op_overloading: static ==(lhs: Bounds, rhs: Bounds): boolean
        /** The center of the bounding box.
         */
        center: Vector3
        /** The total size of the box. This is always twice as large as the extents.
         */
        size: Vector3
        /** The extents of the Bounding Box. This is always half of the size of the Bounds.
         */
        extents: Vector3
        /** The minimal point of the box. This is always equal to center-extents.
         */
        min: Vector3
        /** The maximal point of the box. This is always equal to center+extents.
         */
        max: Vector3
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Represents an axis aligned bounding box with all values as integers.
     */
    class BoundsInt extends ValueType {
        constructor(xMin: number, yMin: number, zMin: number, sizeX: number, sizeY: number, sizeZ: number)
        constructor(position: Vector3Int, size: Vector3Int)
        /** Sets the bounds to the min and max value of the box.
         */
        SetMinMax(minPosition: Vector3Int, maxPosition: Vector3Int): void
        /** Clamps the position and size of this bounding box to the given bounds.
         * @param bounds Bounds to clamp to.
         */
        ClampToBounds(bounds: BoundsInt): void
        /** Is point contained in the bounding box?
         * @param position Point to check.
         * @returns Is point contained in the bounding box? 
         */
        Contains(position: Vector3Int): boolean
        /** Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string, formatProvider: any): string
        /** Returns a formatted string for the bounds.
         * @param format A numeric format string.
         * @param formatProvider An object that specifies culture-specific formatting.
         */
        toString(format: string): string
        toString(): string
        Equals(other: Object1): boolean
        Equals(other: BoundsInt): boolean
        GetHashCode(): number
        static op_Equality(lhs: BoundsInt, rhs: BoundsInt): boolean
        static op_Inequality(lhs: BoundsInt, rhs: BoundsInt): boolean
        // js_op_overloading: static ==(lhs: BoundsInt, rhs: BoundsInt): boolean
        /** X value of the minimal point of the box.
         */
        x: number
        /** Y value of the minimal point of the box.
         */
        y: number
        /** Z value of the minimal point of the box.
         */
        z: number
        /** The center of the bounding box.
         */
        readonly center: Vector3
        /** The minimal point of the box.
         */
        min: Vector3Int
        /** The maximal point of the box.
         */
        max: Vector3Int
        /** The minimal x point of the box.
         */
        xMin: number
        /** The minimal y point of the box.
         */
        yMin: number
        /** The minimal z point of the box.
         */
        zMin: number
        /** The maximal x point of the box.
         */
        xMax: number
        /** The maximal y point of the box.
         */
        yMax: number
        /** The maximal z point of the box.
         */
        zMax: number
        /** The position of the bounding box.
         */
        position: Vector3Int
        /** The total size of the box.
         */
        size: Vector3Int
        /** A BoundsInt.PositionCollection that contains all positions within the BoundsInt.
         */
        readonly allPositionsWithin: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, ValueType, Enum } from "System";
    /** Gradient used for animating colors.
     */
    class Gradient extends Object1 {
        constructor()
        /** Calculate color at a given time.
         * @param time Time of the key (0 - 1).
         */
        Evaluate(time: number): Color
        /** Setup Gradient with an array of color keys and alpha keys.
         * @param colorKeys Color keys of the gradient (maximum 8 color keys).
         * @param alphaKeys Alpha keys of the gradient (maximum 8 alpha keys).
         */
        SetKeys(colorKeys: Array<any>, alphaKeys: Array<any>): void
        Equals(o: Object1): boolean
        Equals(other: Gradient): boolean
        GetHashCode(): number
        /** All color keys defined in the gradient.
         */
        colorKeys: Array<any>
        /** All alpha keys defined in the gradient.
         */
        alphaKeys: Array<any>
        /** Control how the gradient is evaluated.
         */
        mode: any
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Array, ValueType } from "System";
    /** Store a collection of Keyframes that can be evaluated over time.
     */
    class AnimationCurve extends Object1 {
        constructor()
        constructor(...keys: any[])
        $GetValue(index: number): any
        /** Evaluate the curve at time.
         * @param time The time within the curve you want to evaluate (the horizontal axis in the curve graph).
         * @returns The value of the curve, at the point in time specified. 
         */
        Evaluate(time: number): number
        /** Add a new key to the curve.
         * @param time The time at which to add the key (horizontal axis in the curve graph).
         * @param value The value for the key (vertical axis in the curve graph).
         * @returns The index of the added key, or -1 if the key could not be added. 
         */
        AddKey(time: number, value: number): number
        /** Add a new key to the curve.
         * @param key The key to add to the curve.
         * @returns The index of the added key, or -1 if the key could not be added. 
         */
        AddKey(key: any): number
        /** Removes the keyframe at index and inserts key.
         * @param index The index of the key to move.
         * @param key The key (with its new time) to insert.
         * @returns The index of the keyframe after moving it. 
         */
        MoveKey(index: number, key: any): number
        /** Removes a key.
         * @param index The index of the key to remove.
         */
        RemoveKey(index: number): void
        /** Smooth the in and out tangents of the keyframe at index.
         * @param index The index of the keyframe to be smoothed.
         * @param weight The smoothing weight to apply to the keyframe's tangents.
         */
        SmoothTangents(index: number, weight: number): void
        Equals(o: Object1): boolean
        Equals(other: AnimationCurve): boolean
        GetHashCode(): number
        /** Creates a constant "curve" starting at timeStart, ending at timeEnd, and set to the value value.
         * @param timeStart The start time for the constant curve.
         * @param timeEnd The end time for the constant curve.
         * @param value The value for the constant curve.
         * @returns The constant curve created from the specified values. 
         */
        static Constant(timeStart: number, timeEnd: number, value: number): AnimationCurve
        /** A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the linear curve.
         * @param valueStart The start value for the linear curve.
         * @param timeEnd The end time for the linear curve.
         * @param valueEnd The end value for the linear curve.
         * @returns The linear curve created from the specified values. 
         */
        static Linear(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve
        /** Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd.
         * @param timeStart The start time for the ease curve.
         * @param valueStart The start value for the ease curve.
         * @param timeEnd The end time for the ease curve.
         * @param valueEnd The end value for the ease curve.
         * @returns The ease-in and out curve generated from the specified values. 
         */
        static EaseInOut(timeStart: number, valueStart: number, timeEnd: number, valueEnd: number): AnimationCurve
        /** All keys defined in the animation curve.
         */
        keys: Array<any>
        /** The number of keys in the curve. (Read Only)
         */
        readonly length: number
        /** The behaviour of the animation before the first keyframe.
         */
        preWrapMode: WrapMode
        /** The behaviour of the animation after the last keyframe.
         */
        postWrapMode: WrapMode
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1, Enum } from "System";
    /** A UnityGUI event.
     */
    class Event extends Object1 {
        constructor(displayIndex: number)
        constructor(other: Event)
        constructor()
        GetHashCode(): number
        Equals(obj: Object1): boolean
        toString(): string
        Use(): void
        /** Get a filtered event type for a given control ID.
         * @param controlID The ID of the control you are querying from.
         */
        GetTypeForControl(controlID: number): EventType
        /** Create a keyboard event.
         * @param key A string representing keyboard keys and modifiers.
         * @returns A new Event with EventType.KeyDown and the requested KeyCode and optional EventModifier. 
         */
        static KeyboardEvent(key: string): Event
        /** Get the next queued [Event] from the event system.
         * @param outEvent Next Event.
         */
        static PopEvent(outEvent: Event): boolean
        static GetEventCount(): number
        /** Is Shift held down? (Read Only)
         */
        shift: boolean
        /** Is Control key held down? (Read Only)
         */
        control: boolean
        /** Is Alt/Option key held down? (Read Only)
         */
        alt: boolean
        /** Is Command/Windows key held down? (Read Only)
         */
        command: boolean
        /** Is Caps Lock on? (Read Only)
         */
        capsLock: boolean
        /** Is the current keypress on the numeric keyboard? (Read Only)
         */
        numeric: boolean
        /** Is the current keypress a function key? (Read Only)
         */
        readonly functionKey: boolean
        /** The current event that's being processed right now.
         */
        static current: Event
        /** Is this event a keyboard event? (Read Only)
         */
        readonly isKey: boolean
        /** Is this event a mouse event? (Read Only)
         */
        readonly isMouse: boolean
        readonly isScrollWheel: boolean
        readonly rawType: EventType
        /** The mouse position.
         */
        mousePosition: Vector2
        /** The relative movement of the mouse compared to last event.
         */
        delta: Vector2
        /** The type of pointer that created this event (for example, mouse, touch screen, pen).
         */
        pointerType: any
        /** Which mouse button was pressed.
         */
        button: number
        /** Which modifier keys are held down.
         */
        modifiers: any
        /** How hard stylus pressure is applied.
         */
        pressure: number
        /** How many consecutive mouse clicks have we received.
         */
        clickCount: number
        /** The character typed.
         */
        character: string
        /** The raw key code for keyboard events.
         */
        keyCode: KeyCode
        /** Index of display that the event belongs to.
         */
        displayIndex: number
        /** The type of event.
         */
        type: EventType
        /** The name of an ExecuteCommand or ValidateCommand Event.
         */
        commandName: string
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** Types of UnityGUI input and processing events.
     */
    enum EventType {
        /** An event that is called when the mouse is clicked.
         */
        MouseDown = 0,
        /** An event that is called when the mouse is no longer being clicked.
         */
        MouseUp = 1,
        MouseMove = 2,
        /** An event that is called when the mouse is clicked and dragged.
         */
        MouseDrag = 3,
        /** A keyboard key was pressed.
         */
        KeyDown = 4,
        KeyUp = 5,
        ScrollWheel = 6,
        Repaint = 7,
        /** A layout event.
         */
        Layout = 8,
        /** Editor only: drag & drop operation updated.
         */
        DragUpdated = 9,
        DragPerform = 10,
        /** Event should be ignored.
         */
        Ignore = 11,
        /** Already processed event.
         */
        Used = 12,
        /** Validates a special command (e.g. copy & paste).
         */
        ValidateCommand = 13,
        /** Execute a special command (eg. copy & paste).
         */
        ExecuteCommand = 14,
        /** Editor only: drag & drop operation exited.
         */
        DragExited = 15,
        /** User has right-clicked (or control-clicked on the mac).
         */
        ContextClick = 16,
        /** Mouse entered a window (Editor views only).
         */
        MouseEnterWindow = 20,
        /** Mouse left a window (Editor views only).
         */
        MouseLeaveWindow = 21,
        /** Direct manipulation device (finger, pen) touched the screen.
         */
        TouchDown = 30,
        /** Direct manipulation device (finger, pen) left the screen.
         */
        TouchUp = 31,
        /** Direct manipulation device (finger, pen) moved on the screen (drag).
         */
        TouchMove = 32,
        /** Direct manipulation device (finger, pen) moving into the window (drag).
         */
        TouchEnter = 33,
        /** Direct manipulation device (finger, pen) moved out of the window (drag).
         */
        TouchLeave = 34,
        /** Direct manipulation device (finger, pen) stationary event (long touch down).
         */
        TouchStationary = 35,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    /** MonoBehaviour.StartCoroutine returns a Coroutine. Instances of this class are only used to reference these coroutines, and do not hold any exposed properties or functions.
     */
    class Coroutine extends YieldInstruction {
        protected constructor()
    }
}
declare module "System.Collections" {
    import * as jsb from "jsb";
    import { Object } from "System";
    interface IEnumerator {
        MoveNext(): boolean
        Reset(): void
        readonly Current: Object
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    import { Object } from "System";
    interface IEnumerable_String {
        GetEnumerator(): any
    }
}
declare module "System.Collections.Generic" {
    import * as jsb from "jsb";
    interface IEnumerable<T> {
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect, GUIStyle, GUILayoutOption } from "UnityEngine";
    /** The SearchField control creates a text field for a user to input text that can be used for searching.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SearchField extends Object {
        constructor()
        SetFocus(): void
        HasFocus(): boolean
        /** This function displays a search text field with the given Rect and UI style parameters.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @param style The text field style.
         * @param cancelButtonStyle The cancel button style used when there is text in the search field.
         * @param emptyCancelButtonStyle The cancel button style used when there is no text in the search field.
         * @returns The text entered in the SearchField. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(rect: Rect, text: string, style: GUIStyle, cancelButtonStyle: GUIStyle, emptyCancelButtonStyle: GUIStyle): string
        /** This function displays the search field with the default UI style in the given Rect.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(rect: Rect, text: string): string
        /** This function displays the search field with the default UI style and uses the GUILayout class to automatically calculate the position and size of the Rect it is rendered to. Pass an optional list to specify extra layout properties.
         * @param text Text string to display in the search field.
         * @param options An optional list of layout options that specify extra layout properties. <br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnGUI(text: string, ...options: GUILayoutOption[]): string
        /** This function displays the search field with a toolbar style in the given Rect.
         * @param rect Rectangle to use for the search field.
         * @param text Text string to display in the search field.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnToolbarGUI(rect: Rect, text: string): string
        /** This function displays the search field with the toolbar UI style and uses the GUILayout class to automatically calculate the position and size of the Rect it is rendered to. Pass an optional list to specify extra layout properties.
         * @param text Text string to display in the search field.
         * @param options An optional list of layout options that specify extra layout properties. <br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered in the search field. The original input string is returned instead if the search field text was not changed. 
         */
        OnToolbarGUI(text: string, ...options: GUILayoutOption[]): string
        /** This is the controlID used for the text field to obtain keyboard focus.
         */
        searchFieldControlID: number
        /** Changes the keyboard focus to the search field when the user presses ‘Ctrl/Cmd + F’ when set to true. It is true by default.
         */
        autoSetFocusOnFindCommand: boolean
        downOrUpArrowKeyPressed(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIStyle, Object as Object1 } from "UnityEngine";
    /** Common GUIStyles used for EditorGUI controls.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorStyles extends Object {
        constructor()
        static FromUSS(baseStyle: GUIStyle, ussStyleRuleName: string, ussInPlaceStyleOverride: string): GUIStyle
        static FromUSS(ussStyleRuleName: string, ussInPlaceStyleOverride: string): GUIStyle
        static ApplyUSS(style: GUIStyle, ussStyleRuleName: string, ussInPlaceStyleOverride: string): GUIStyle
        /** Style used for the labelled on all EditorGUI overloads that take a prefix label.
         */
        static readonly label: GUIStyle
        /** Style for label with small font.
         */
        static readonly miniLabel: GUIStyle
        /** Style for label with large font.
         */
        static readonly largeLabel: GUIStyle
        /** Style for bold label.
         */
        static readonly boldLabel: GUIStyle
        /** Style for mini bold label.
         */
        static readonly miniBoldLabel: GUIStyle
        /** Style for label with small font which is centered and grey.
         */
        static readonly centeredGreyMiniLabel: GUIStyle
        /** Style for word wrapped mini label.
         */
        static readonly wordWrappedMiniLabel: GUIStyle
        /** Style for word wrapped label.
         */
        static readonly wordWrappedLabel: GUIStyle
        /** Style used for links.
         */
        static readonly linkLabel: GUIStyle
        /** Style for white label.
         */
        static readonly whiteLabel: GUIStyle
        /** Style for white mini label.
         */
        static readonly whiteMiniLabel: GUIStyle
        /** Style for white large label.
         */
        static readonly whiteLargeLabel: GUIStyle
        /** Style for white bold label.
         */
        static readonly whiteBoldLabel: GUIStyle
        /** Style used for a radio button.
         */
        static readonly radioButton: GUIStyle
        /** Style used for a standalone small button.
         */
        static readonly miniButton: GUIStyle
        /** Style used for the leftmost button in a horizontal button group.
         */
        static readonly miniButtonLeft: GUIStyle
        /** Style used for the middle buttons in a horizontal group.
         */
        static readonly miniButtonMid: GUIStyle
        /** Style used for the rightmost button in a horizontal group.
         */
        static readonly miniButtonRight: GUIStyle
        /** Style used for the drop-down controls.
         */
        static readonly miniPullDown: GUIStyle
        /** Style used for EditorGUI.TextField.
         */
        static readonly textField: GUIStyle
        /** Style used for EditorGUI.TextArea.
         */
        static readonly textArea: GUIStyle
        /** Smaller text field.
         */
        static readonly miniTextField: GUIStyle
        /** Style used for field editors for numbers.
         */
        static readonly numberField: GUIStyle
        /** Style used for EditorGUI.Popup, EditorGUI.EnumPopup,.
         */
        static readonly popup: GUIStyle
        /** Style used for headings for object fields.
         */
        static readonly objectField: GUIStyle
        /** Style used for headings for the Select button in object fields.
         */
        static readonly objectFieldThumb: GUIStyle
        /** Style used for object fields that have a thumbnail (e.g Textures). 
         */
        static readonly objectFieldMiniThumb: GUIStyle
        /** Style used for headings for Color fields.
         */
        static readonly colorField: GUIStyle
        /** Style used for headings for Layer masks.
         */
        static readonly layerMaskField: GUIStyle
        /** Style used for headings for EditorGUI.Toggle.
         */
        static readonly toggle: GUIStyle
        /** Style used for headings for EditorGUI.Foldout.
         */
        static readonly foldout: GUIStyle
        /** Style used for headings for EditorGUI.Foldout.
         */
        static readonly foldoutPreDrop: GUIStyle
        /** Style used for headings for EditorGUILayout.BeginFoldoutHeaderGroup.
         */
        static readonly foldoutHeader: GUIStyle
        /** Style used for icon for EditorGUILayout.BeginFoldoutHeaderGroup.
         */
        static readonly foldoutHeaderIcon: GUIStyle
        /** Style used for headings for EditorGUILayout.BeginToggleGroup.
         */
        static readonly toggleGroup: GUIStyle
        /** Standard font.
         */
        static readonly standardFont: any
        /** Bold font.
         */
        static readonly boldFont: any
        /** Mini font.
         */
        static readonly miniFont: any
        /** Mini Bold font.
         */
        static readonly miniBoldFont: any
        /** Toolbar background from top of windows.
         */
        static readonly toolbar: GUIStyle
        /** Style for Button and Toggles in toolbars.
         */
        static readonly toolbarButton: GUIStyle
        /** Toolbar Popup.
         */
        static readonly toolbarPopup: GUIStyle
        /** Toolbar Dropdown.
         */
        static readonly toolbarDropDown: GUIStyle
        /** Toolbar text field.
         */
        static readonly toolbarTextField: GUIStyle
        /** Wrap content in a vertical group with this style to get the default margins used in the Inspector.
         */
        static readonly inspectorDefaultMargins: GUIStyle
        /** Wrap content in a vertical group with this style to get full width margins in the Inspector.
         */
        static readonly inspectorFullWidthMargins: GUIStyle
        /** Style used for background box for EditorGUI.HelpBox.
         */
        static readonly helpBox: GUIStyle
        /** Toolbar search field.
         */
        static readonly toolbarSearchField: GUIStyle
        /** Style used for a standalone icon button.
         */
        static readonly iconButton: GUIStyle
        /** Style used to draw a marquee selection rect in the SceneView.
         */
        static readonly selectionRect: GUIStyle
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIContent, Rect } from "UnityEngine";
    /** GenericMenu lets you create custom context menus and dropdown menus.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GenericMenu extends Object {
        constructor()
        AddItem(content: GUIContent, on: boolean, func: (userData: Object) => void, userData: Object): void
        AddItem(content: GUIContent, on: boolean, func: () => void): void
        /** Add a disabled item to the menu.
         * @param content The GUIContent to display as a disabled menu item.
         * @param on Specifies whether to show that the item is currently activated (i.e. a tick next to the item in the menu).
         */
        AddDisabledItem(content: GUIContent, on: boolean): void
        /** Add a disabled item to the menu.
         * @param content The GUIContent to display as a disabled menu item.
         */
        AddDisabledItem(content: GUIContent): void
        /** Add a seperator item to the menu.
         * @param path The path to the submenu, if adding a separator to a submenu. When adding a separator to the top level of a menu, use an empty string as the path.
         */
        AddSeparator(path: string): void
        GetItemCount(): number
        ShowAsContext(): void
        /** Show the menu at the given screen rect.
         * @param position The position at which to show the menu.
         */
        DropDown(position: Rect): void
        /** Allow the menu to have multiple items with the same name.
         */
        allowDuplicateNames: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum indicating the type of Prefab Asset, such as Regular, Model and Variant.
     */
    enum PrefabAssetType {
        /** The object being queried is not part of a Prefab at all.
         */
        NotAPrefab = 0,
        /** The object being queried is part of a regular Prefab.
         */
        Regular = 1,
        /** The object being queried is part of a Model Prefab.
         */
        Model = 2,
        /** The object being queried is part of a Prefab Variant.
         */
        Variant = 3,
        /** The object being queried is part of a Prefab instance, but because the asset is missing the actual type of Prefab can’t be determined.
         */
        MissingAsset = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum with status about whether a Prefab instance is properly connected to its asset.
     */
    enum PrefabInstanceStatus {
        /** The object is not part of a Prefab instance.
         */
        NotAPrefab = 0,
        /** The Prefab instance is connected to its Prefab Asset.
         */
        Connected = 1,
        /** The Prefab instance is not connected to its Prefab Asset.
         */
        Disconnected = 2,
        /** The Prefab instance is missing its Prefab Asset.
         */
        MissingAsset = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Default mobile device orientation.
     */
    enum UIOrientation {
        /** Portrait.
         */
        Portrait = 0,
        /** Portrait upside down.
         */
        PortraitUpsideDown = 1,
        /** Landscape: clockwise from Portrait.
         */
        LandscapeRight = 2,
        /** Landscape : counter-clockwise from Portrait.
         */
        LandscapeLeft = 3,
        /** Auto Rotation Enabled.
         */
        AutoRotation = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** User message types.
     */
    enum MessageType {
        /** Neutral message.
         */
        None = 0,
        /** Info message.
         */
        Info = 1,
        /** Warning message.
         */
        Warning = 2,
        /** Error message.
         */
        Error = 3,
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { ValueType, Object as Object1 } from "System";
    /** Represents  a 128-bit hash value.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Hash128 extends ValueType {
        constructor(u32_0: number, u32_1: number, u32_2: number, u32_3: number)
        constructor(u64_0: number, u64_1: number)
        CompareTo(rhs: Hash128): number
        CompareTo(obj: Object1): number
        toString(): string
        /** Hash new input string and combine with the current hash value.
         * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
         */
        Append(data: string): void
        /** Hash new input data and combine with the current hash value.
         * @param val Input value.
         */
        Append(val: number): void
        /** Hash new input data and combine with the current hash value.
         * @param val Input value.
         */
        Append(val: number): void
        Equals(obj: Object1): boolean
        Equals(obj: Hash128): boolean
        GetHashCode(): number
        /** Convert a hex-encoded string into Hash128 value.
         * @param hashString A hexadecimal-encoded hash string.
         * @returns The 128-bit hash. 
         */
        static Parse(hashString: string): Hash128
        /** Compute a hash of input data string.
         * @param data Input data string. Note that Unity interprets the string as UTF-8 data, even if internally in C# strings are UTF-16.
         * @returns The 128-bit hash. 
         */
        static Compute(data: string): Hash128
        /** Compute a hash of input data.
         * @param val Input value.
         * @returns The 128-bit hash. 
         */
        static Compute(val: number): Hash128
        /** Compute a hash of input data.
         * @param val Input value.
         * @returns The 128-bit hash. 
         */
        static Compute(val: number): Hash128
        static op_Equality(hash1: Hash128, hash2: Hash128): boolean
        static op_Inequality(hash1: Hash128, hash2: Hash128): boolean
        static op_LessThan(x: Hash128, y: Hash128): boolean
        static op_GreaterThan(x: Hash128, y: Hash128): boolean
        // js_op_overloading: static ==(hash1: Hash128, hash2: Hash128): boolean
        // js_op_overloading: static <(x: Hash128, y: Hash128): boolean
        /** Returns true is the hash value is valid. (Read Only)
         */
        readonly isValid: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Asset importing options.
     */
    enum ImportAssetOptions {
        /** Default import options.
         */
        Default = 0,
        /** User initiated asset import.
         */
        ForceUpdate = 1,
        /** Import all assets synchronously.
         */
        ForceSynchronousImport = 8,
        /** When a folder is imported, import all its contents as well.
         */
        ImportRecursive = 256,
        /** Force a full reimport but don't download the assets from the cache server.
         */
        DontDownloadFromCacheServer = 8192,
        /** Forces asset import as uncompressed for edition facilities.
         */
        ForceUncompressedImport = 16384,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** AssetPostprocessor lets you hook into the import pipeline and run scripts prior or after importing assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetPostprocessor extends Object {
        /** Logs an import warning to the console.
         */
        LogWarning(warning: string, context: Object1): void
        /** Logs an import warning to the console.
         */
        LogWarning(warning: string): void
        /** Logs an import error message to the console.
         */
        LogError(warning: string, context: Object1): void
        /** Logs an import error message to the console.
         */
        LogError(warning: string): void
        GetVersion(): number
        GetPostprocessOrder(): number
        protected constructor()
        /** The path name of the asset being imported.
         */
        assetPath: string
        /** The import context.
         */
        readonly context: any
        /** Reference to the asset importer.
         */
        readonly assetImporter: AssetImporter
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Object as Object1 } from "System";
    /** Base class from which asset importers for specific asset types derive.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetImporter extends Object {
        constructor()
        /** Set the AssetBundle name and variant.
         * @param assetBundleName AssetBundle name.
         * @param assetBundleVariant AssetBundle variant.
         */
        SetAssetBundleNameAndVariant(assetBundleName: string, assetBundleVariant: string): void
        SaveAndReimport(): void
        AddRemap(identifier: AssetImporter.SourceAssetIdentifier, externalObject: Object): void
        RemoveRemap(identifier: AssetImporter.SourceAssetIdentifier): boolean
        GetExternalObjectMap(): any
        /** Checks if the AssetImporter supports remapping the given asset type.
         * @param type The type of asset to check.
         * @returns Returns true if the importer supports remapping the given type. Otherwise, returns false. 
         */
        SupportsRemappedAssetType(type: any): boolean
        /** Retrieves the asset importer for the asset at path.
         */
        static GetAtPath(path: string): AssetImporter
        /** The path name of the asset for this importer. (Read Only)
         */
        readonly assetPath: string
        /** The value is true when no meta file is provided with the imported asset.
         */
        readonly importSettingsMissing: boolean
        readonly assetTimeStamp: number
        /** Get or set any user data.
         */
        userData: string
        /** Get or set the AssetBundle name.
         */
        assetBundleName: string
        /** Get or set the AssetBundle variant.
         */
        assetBundleVariant: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array, ValueType } from "System";
    import { WrapMode, Object } from "UnityEngine";
    /** Model importer lets you modify import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ModelImporter extends AssetImporter {
        constructor()
        /** Creates a mask that matches the model hierarchy, and applies it to the provided ModelImporterClipAnimation.
         * @param clip Clip to which the mask will be applied.
         */
        CreateDefaultMaskForClip(clip: ModelImporterClipAnimation): void
        /** Extracts the embedded textures from a model file (such as FBX or SketchUp).
         * @param folderPath The directory where the textures will be extracted.
         * @returns Returns true if the textures are extracted successfully, otherwise false. 
         */
        ExtractTextures(folderPath: string): boolean
        /** Search the project for matching materials and use them instead of the internal materials.
         * @param nameOption The name matching option.
         * @param searchOption The search type option.
         * @returns Returns false if the source file is empty or invalid. Returns true otherwise. 
         */
        SearchAndRemapMaterials(nameOption: ModelImporterMaterialName, searchOption: ModelImporterMaterialSearch): boolean
        /** Material naming setting.
         */
        materialName: ModelImporterMaterialName
        /** Existing material search setting.
         */
        materialSearch: ModelImporterMaterialSearch
        /** Material import location options.
         */
        materialLocation: ModelImporterMaterialLocation
        /** Global scale factor for importing.
         */
        globalScale: number
        /** Is useFileUnits supported for this asset.
         */
        readonly isUseFileUnitsSupported: boolean
        /** Use visibility properties to enable or disable MeshRenderer components.
         */
        importVisibility: boolean
        /** Detect file units and import as 1FileUnit=1UnityUnit, otherwise it will import as 1cm=1UnityUnit.
         */
        useFileUnits: boolean
        /** Scaling factor used when useFileScale is set to true (Read-only).
         */
        readonly fileScale: number
        /** Use FileScale when importing.
         */
        useFileScale: boolean
        /** Controls import of BlendShapes.
         */
        importBlendShapes: boolean
        /** Controls import of cameras. Basic properties like field of view, near plane distance and far plane distance can be animated.
         */
        importCameras: boolean
        /** Controls import of lights. Note that because light are defined differently in DCC tools, some light types or properties may not be exported. Basic properties like color and intensity can be animated.
         */
        importLights: boolean
        /** Add to imported meshes.
         */
        addCollider: boolean
        /** Smoothing angle (in degrees) for calculating normals.
         */
        normalSmoothingAngle: number
        /** Swap primary and secondary UV channels when importing.
         */
        swapUVChannels: boolean
        /** Combine vertices that share the same position in space.
         */
        weldVertices: boolean
        /** Computes the axis conversion on geometry and animation for Models defined in an axis system that differs from Unity's (left handed, Z forward, Y-up).

                    When enabled, Unity transforms the geometry and animation data in order to convert the axis.

                    When disabled, Unity transforms the root GameObject of the hierarchy in order to convert the axis.
         */
        bakeAxisConversion: boolean
        /** Only import bones where they are connected to vertices.
         */
        optimizeBones: boolean
        /** If this is true, any quad faces that exist in the mesh data before it is imported are kept as quads instead of being split into two triangles, for the purposes of tessellation. Set this to false to disable this behavior.
         */
        keepQuads: boolean
        /** Format of the imported mesh index buffer data.
         */
        indexFormat: ModelImporterIndexFormat
        /** If true, always create an explicit Prefab root. Otherwise, if the model has a single root, it is reused as the Prefab root.
         */
        preserveHierarchy: boolean
        /** Generate secondary UV set for lightmapping.
         */
        generateSecondaryUV: boolean
        /** Threshold for angle distortion (in degrees) when generating secondary UV.
         */
        secondaryUVAngleDistortion: number
        /** Threshold for area distortion when generating secondary UV.
         */
        secondaryUVAreaDistortion: number
        /** Hard angle (in degrees) for generating secondary UV.
         */
        secondaryUVHardAngle: number
        /** Method to use for handling margins when generating secondary UV.
         */
        secondaryUVMarginMethod: ModelImporterSecondaryUVMarginMethod
        /** Margin to be left between charts when packing secondary UV.
         */
        secondaryUVPackMargin: number
        /** The minimum lightmap resolution in texels per unit that the associated model is expected to have.
         */
        secondaryUVMinLightmapResolution: number
        /** The minimum object scale that the associated model is expected to have.
         */
        secondaryUVMinObjectScale: number
        /** Animation generation options.
         */
        generateAnimations: ModelImporterGenerateAnimations
        /** Generates the list of all imported take.
         */
        readonly importedTakeInfos: Array<any>
        /** Generates the list of all imported Transforms.
         */
        readonly transformPaths: Array<string>
        /** Generates the list of all imported Animations.
         */
        readonly referencedClips: Array<string>
        /** Are mesh vertices and indices accessible from script?
         */
        isReadable: boolean
        /** Options to control the optimization of mesh data during asset import.
         */
        meshOptimizationFlags: MeshOptimizationFlags
        /** Optimize the order of polygons in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        optimizeMeshPolygons: boolean
        /** Optimize the order of vertices in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        optimizeMeshVertices: boolean
        /** Skin weights import options.
         */
        skinWeights: ModelImporterSkinWeights
        /** The maximum number of bones per vertex stored in this mesh data.
         */
        maxBonesPerVertex: number
        /** Minimum bone weight to keep.
         */
        minBoneWeight: number
        /** Vertex normal import options.
         */
        importNormals: ModelImporterNormals
        /** Source of smoothing information for calculation of normals.
         */
        normalSmoothingSource: ModelImporterNormalSmoothingSource
        /** Blend shape normal import options.
         */
        importBlendShapeNormals: ModelImporterNormals
        /** Normal generation options for ModelImporter.
         */
        normalCalculationMode: ModelImporterNormalCalculationMode
        /** Vertex tangent import options.
         */
        importTangents: ModelImporterTangents
        /** Bake Inverse Kinematics (IK) when importing.
         */
        bakeIK: boolean
        /** Is Bake Inverse Kinematics (IK) supported by this importer.
         */
        readonly isBakeIKSupported: boolean
        /** If set to false, the importer will not resample curves when possible.
Read more about.

Notes:

- Some unsupported FBX features (such as PreRotation or PostRotation on transforms) will override this setting. In these situations, animation curves will still be resampled even if the setting is disabled. For best results, avoid using PreRotation, PostRotation and GetRotationPivot.

- This option was introduced in Version 5.3. Prior to this version, Unity's import behaviour was as if this option was always enabled. Therefore enabling the option gives the same behaviour as pre-5.3 animation import.

         */
        resampleCurves: boolean
        /** Is import of tangents supported by this importer.
         */
        readonly isTangentImportSupported: boolean
        /** Removes constant animation curves with values identical to the object initial scale value.
         */
        removeConstantScaleCurves: boolean
        /** Enables strict checks on imported vertex data.
         */
        strictVertexDataChecks: boolean
        /** Mesh compression setting.
         */
        meshCompression: ModelImporterMeshCompression
        /** Import animation from file.
         */
        importAnimation: boolean
        /** Animation optimization setting.
         */
        optimizeGameObjects: boolean
        /** Animation optimization setting.
         */
        extraExposedTransformPaths: Array<string>
        /** Additional properties to treat as user properties.
         */
        extraUserProperties: Array<string>
        /** Animation compression setting.
         */
        animationCompression: ModelImporterAnimationCompression
        /** Import animated custom properties from file.
         */
        importAnimatedCustomProperties: boolean
        /** Import animation constraints.
         */
        importConstraints: boolean
        /** Allowed error of animation rotation compression.
         */
        animationRotationError: number
        /** Allowed error of animation position compression.
         */
        animationPositionError: number
        /** Allowed error of animation scale compression.
         */
        animationScaleError: number
        /** The default wrap mode for the generated animation clips.
         */
        animationWrapMode: WrapMode
        /** Animator generation mode.
         */
        animationType: ModelImporterAnimationType
        /** Controls how much oversampling is used when importing humanoid animations for retargeting.
         */
        humanoidOversampling: ModelImporterHumanoidOversampling
        /** The path of the transform used to generation the motion of the animation.
         */
        motionNodeName: string
        /** The Avatar generation of the imported model.
         */
        avatarSetup: ModelImporterAvatarSetup
        /** Imports the HumanDescription from the given Avatar.
         */
        sourceAvatar: any
        /** The human description that is used to generate an Avatar during the import process.
         */
        humanDescription: any
        /** Animation clips to split animation into. Additional resources: ModelImporterClipAnimation.
         */
        clipAnimations: Array<ModelImporterClipAnimation>
        /** Generate a list of all default animation clip based on TakeInfo.
         */
        readonly defaultClipAnimations: Array<ModelImporterClipAnimation>
        /** When disabled, imported material albedo colors are converted to gamma space. This property should be disabled when using linear color space in Player rendering settings.
The default value is true.
         */
        useSRGBMaterialColor: boolean
        /** Sorts the gameObject hierarchy by name.
         */
        sortHierarchyByName: boolean
        /** Material creation options.
         */
        materialImportMode: ModelImporterMaterialImportMode
        /** Generate auto mapping if no avatarSetup is provided when importing humanoid animation.
         */
        autoGenerateAvatarMappingIfUnspecified: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Audio importer lets you modify AudioClip import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AudioImporter extends AssetImporter {
        constructor()
        /** Returns whether a given build target has its sample settings currently overridden.
         * @param platform The platform for which to query if this AudioImporter has an override.

See BuildTargetGroup for the complete list of options and type the desired platform enum name in the form of a string.
         * @returns Returns true if the platform is currently overriden in this AudioImporter. 
         */
        ContainsSampleSettingsOverride(platform: string): boolean
        /** Return the current override settings for the given platform.
         * @param platform The platform for which to get the override settings.

See BuildTargetGroup for the complete list of options and type the desired platform enum name in the form of a string.
         * @returns The override sample settings for the given platform. 
         */
        GetOverrideSampleSettings(platform: string): AudioImporterSampleSettings
        /** Sets the override sample settings for the given platform.
         * @param platform The platform which will have the sample settings overridden.

See BuildTargetGroup for the complete list of options and type the desired platform enum name in the form of a string.
         * @param settings The override settings for the given platform.
         * @returns Returns true if the settings were successfully overriden. Some setting overrides are not possible for the given platform, in which case false is returned and the settings are not registered. 
         */
        SetOverrideSampleSettings(platform: string, settings: AudioImporterSampleSettings): boolean
        /** Clears the sample settings override for the given platform.
         * @param platform The platform for which to clear the overrides.

See BuildTargetGroup for the complete list of options and type the desired platform enum name in the form of a string.
         * @returns Returns true if any overrides were actually cleared. 
         */
        ClearSampleSettingOverride(platform: string): boolean
        /** The default sample settings for the AudioClip importer.
         */
        defaultSampleSettings: AudioImporterSampleSettings
        /** Force audioclips to mono?
         */
        forceToMono: boolean
        /** When this flag is set, the audio clip will be treated as being ambisonic.
         */
        ambisonic: boolean
        /** Corresponding to the "Load In Background" flag in the AudioClip inspector, when this flag is set, the loading of the clip will happen delayed without blocking the main thread.
         */
        loadInBackground: boolean
        /** Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded.
         */
        preloadAudioData: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Texture } from "UnityEngine";
    import { Object } from "System";
    /** VideoClipImporter lets you modify Video.VideoClip import settings from Editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VideoClipImporter extends AssetImporter {
        constructor()
        /** Returns the platform-specific import settings for the specified platform.
         * @param platform Platform name.
         * @returns The platform-specific import settings. Throws an exception if the platform is unknown. 
         */
        GetTargetSettings(platform: string): VideoImporterTargetSettings
        /** Sets the platform-specific import settings for the specified platform.
         * @param platform Platform name.
         * @param settings The new platform-specific import settings. Throws an exception if the platform is unknown.
         */
        SetTargetSettings(platform: string, settings: VideoImporterTargetSettings): void
        /** Clear the platform-specific import settings for the specified platform, causing them to go back to the default settings.
         * @param platform Platform name.
         */
        ClearTargetSettings(platform: string): void
        PlayPreview(): void
        StopPreview(): void
        GetPreviewTexture(): Texture
        /** Get the full name of the resize operation for the specified resize mode.
         * @param mode Mode for which the width is queried.
         * @returns Name for the specified resize mode. 
         */
        GetResizeModeName(mode: VideoResizeMode): string
        /** Get the resulting width of the resize operation for the specified resize mode.
         * @param mode Mode for which the width is queried.
         * @returns Width for the specified resize mode. 
         */
        GetResizeWidth(mode: VideoResizeMode): number
        /** Get the resulting height of the resize operation for the specified resize mode.
         * @param mode Mode for which the height is queried.
         * @returns Height for the specified resize mode. 
         */
        GetResizeHeight(mode: VideoResizeMode): number
        /** Number of audio channels in the specified source track.
         * @param audioTrackIdx Index of the audio track to query.
         * @returns Number of channels. 
         */
        GetSourceAudioChannelCount(audioTrackIdx: number): number
        /** Sample rate of the specified audio track.
         * @param audioTrackIdx Index of the audio track to query.
         * @returns Sample rate in Hertz. 
         */
        GetSourceAudioSampleRate(audioTrackIdx: number): number
        /** Performs a value comparison with another VideoClipImporter.
         * @param rhs The importer to compare with.
         * @returns Returns true if the settings for both VideoClipImporters match. Returns false otherwise. 
         */
        Equals(rhs: VideoClipImporter): boolean
        Equals(other: Object): boolean
        /** Size in bytes of the file before importing.
         */
        readonly sourceFileSize: number
        /** Size in bytes of the file once imported.
         */
        readonly outputFileSize: number
        /** Number of frames in the clip.
         */
        readonly frameCount: number
        /** Frame rate of the clip.
         */
        readonly frameRate: number
        /** Whether to keep the alpha from the source into the transcoded clip.
         */
        keepAlpha: boolean
        /** True if the source file has a channel for per-pixel transparency.
         */
        readonly sourceHasAlpha: boolean
        /** Images are deinterlaced during transcode.  This tells the importer how to interpret fields in the source, if any.
         */
        deinterlaceMode: VideoDeinterlaceMode
        /** Apply a vertical flip during import.
         */
        flipVertical: boolean
        /** Apply a horizontal flip during import.
         */
        flipHorizontal: boolean
        /** Import audio tracks from source file.
         */
        importAudio: boolean
        /** Whether the imported clip contains sRGB color data.
         */
        sRGBClip: boolean
        /** Default values for the platform-specific import settings.
         */
        defaultTargetSettings: VideoImporterTargetSettings
        /** Whether the preview is currently playing.
         */
        readonly isPlayingPreview: boolean
        /** Number of audio tracks in the source file.
         */
        readonly sourceAudioTrackCount: number
        /** Numerator of the pixel aspect ratio (num:den).
         */
        readonly pixelAspectRatioNumerator: number
        /** Denominator of the pixel aspect ratio (num:den).
         */
        readonly pixelAspectRatioDenominator: number
        /** Returns true if transcoding was skipped during import, false otherwise. (Read Only)

When VideoImporterTargetSettings.enableTranscoding is set to true, the resulting transcoding operation done at import time may be quite long, up to many hours depending on source resolution and content duration. An option to skip this process is offered in the asset import progress bar. When skipped, the transcoding instead provides a non-transcoded verision of the asset. However, the importer settings stay intact so this property can be inspected to detect the incoherence with the generated artifact.

Re-importing without stopping the transcode process, or with transcode turned off, causes this property to become false.
         */
        readonly transcodeSkipped: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum, Array, ValueType } from "System";
    import { Vector2, Vector4 } from "UnityEngine";
    /** Texture importer lets you modify Texture2D import settings from editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TextureImporter extends AssetImporter {
        constructor()
        /** Get platform specific texture settings.
         * @param platform The platform for which settings are required (see options below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture for the given platform.
         * @param compressionQuality Value from 0..100, equivalent to the standard JPEG quality setting.
         * @param etc1AlphaSplitEnabled Status of the ETC1 and alpha split flag.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<TextureImporterFormat>, compressionQuality: jsb.Out<number>, etc1AlphaSplitEnabled: jsb.Out<boolean>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture.
         * @param compressionQuality Value from 0..100, equivalent to the standard JPEG quality setting.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<TextureImporterFormat>, compressionQuality: jsb.Out<number>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @param maxTextureSize Maximum texture width/height in pixels.
         * @param textureFormat Format of the texture.
         * @returns True if the platform override was found, false if no override was found. 
         */
        GetPlatformTextureSettings(platform: string, maxTextureSize: jsb.Out<number>, textureFormat: jsb.Out<TextureImporterFormat>): boolean
        /** Get platform specific texture settings.
         * @param platform The platform whose settings are required (see below).
         * @returns A TextureImporterPlatformSettings structure containing the platform parameters. 
         */
        GetPlatformTextureSettings(platform: string): TextureImporterPlatformSettings
        GetDefaultPlatformTextureSettings(): TextureImporterPlatformSettings
        /** Returns the TextureImporterFormat that would be automatically chosen for this platform.
         * @returns Format chosen by the system for the provided platform, TextureImporterFormat.Automatic if the platform does not exist. 
         */
        GetAutomaticFormat(platform: string): TextureImporterFormat
        /** Set specific target platform settings.
         * @param platformSettings Structure containing the platform settings.
         */
        SetPlatformTextureSettings(platformSettings: TextureImporterPlatformSettings): void
        /** Clear specific target platform settings.
         * @param platform The platform whose settings are to be cleared (see below).
         */
        ClearPlatformTextureSettings(platform: string): void
        /** Gets the source texture's width and height.
         * @param width The source texture's width.
         * @param height The source texture's height.
         */
        GetSourceTextureWidthAndHeight(width: jsb.Out<number>, height: jsb.Out<number>): void
        DoesSourceTextureHaveAlpha(): boolean
        /** Read texture settings into TextureImporterSettings class.
         */
        ReadTextureSettings(dest: TextureImporterSettings): void
        /** Set texture importers settings from TextureImporterSettings class.
         */
        SetTextureSettings(src: TextureImporterSettings): void
        ReadTextureImportInstructions(target: BuildTarget, desiredFormat: jsb.Out<any>, colorSpace: jsb.Out<any>, compressionQuality: jsb.Out<number>): void
        /** Validates TextureImporterFormat based on a specified import type (TextureImporterType) and a specified build target (BuildTarget.).
         * @param textureType The TextureImporterType that the importer uses.
         * @param target The platform that the setting targets, referred to as the BuilTarget.
         * @param currentFormat The TextureImporterFormat to validate.
         * @returns Returns true if TextureImporterFormat is valid and can be set. Returns false otherwise. 
         */
        static IsPlatformTextureFormatValid(textureType: TextureImporterType, target: BuildTarget, currentFormat: TextureImporterFormat): boolean
        /** Validates TextureImporterFormat based on the type of the current format (TextureImporterType) and the default platform.
         * @param currentFormat The TextureImporterType that the importer uses.
         * @param textureType The TextureImporterFormat to validate.
         * @returns Returns true if TextureImporterFormat is valid and can be set. Returns false otherwise. 
         */
        static IsDefaultPlatformTextureFormatValid(textureType: TextureImporterType, currentFormat: TextureImporterFormat): boolean
        /** Maximum texture size.
         */
        maxTextureSize: number
        /** The quality of Crunch texture compression. The range is 0 through 100. A higher quality means larger textures and longer compression times.
         */
        compressionQuality: number
        /** Use crunched compression when available.
         */
        crunchedCompression: boolean
        /** Allows alpha splitting on relevant platforms for this texture.
         */
        allowAlphaSplitting: boolean
        /** ETC2 texture decompression fallback override on Android devices that don't support ETC2.
         */
        androidETC2FallbackOverride: any
        /** Compression of imported texture.
         */
        textureCompression: TextureImporterCompression
        /** Select how the alpha of the imported texture is generated.
         */
        alphaSource: TextureImporterAlphaSource
        /** Cubemap generation mode.
         */
        generateCubemap: TextureImporterGenerateCubemap
        /** Scaling mode for non power of two textures.
         */
        npotScale: TextureImporterNPOTScale
        /** Whether Unity stores an additional copy of the imported texture's pixel data in CPU-addressable memory.
         */
        isReadable: boolean
        /** Enable mipmap streaming for this texture.
         */
        streamingMipmaps: boolean
        /** Relative priority for this texture when reducing memory size in order to hit the memory budget.
         */
        streamingMipmapsPriority: number
        /** When enabled, this texture can solely be used in combination with a Texture Stack for Virtual Texturing. When enabled the texture is not guaranteed to be available as a Texture2D in the Player (e.g., not accessible from a script). When disabled, the Player includes the texture both as a Texture2D (e.g., accessible from script) and as a streamable texture in a Texture Stack.
         */
        vtOnly: boolean
        /** Generate Mip Maps.
         */
        mipmapEnabled: boolean
        /** Keeps texture borders the same when generating mipmaps.
         */
        borderMipmap: boolean
        /** Whether this texture stores data in sRGB (also called gamma) color space.
         */
        sRGBTexture: boolean
        /** Enables or disables coverage-preserving alpha mipmapping.
         */
        mipMapsPreserveCoverage: boolean
        /** Returns or assigns the alpha test reference value.
         */
        alphaTestReferenceValue: number
        /** Mipmap filtering mode.
         */
        mipmapFilter: TextureImporterMipFilter
        /** Fade out mip levels to gray color.
         */
        fadeout: boolean
        /** Mip level where texture begins to fade out.
         */
        mipmapFadeDistanceStart: number
        /** Mip level where texture is faded out completely.
         */
        mipmapFadeDistanceEnd: number
        /** Convert heightmap to normal map
         */
        convertToNormalmap: boolean
        /** Normal map filtering mode.
         */
        normalmapFilter: TextureImporterNormalFilter
        /** Amount of bumpyness in the heightmap.
         */
        heightmapScale: number
        /** Anisotropic filtering level of the texture.
         */
        anisoLevel: number
        /** Filtering mode of the texture.
         */
        filterMode: any
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** Mip map bias of the texture.
         */
        mipMapBias: number
        /** If the alpha channel of your texture represents transparency, enable this property to dilate the color channels of visible texels into fully transparent areas. This effectively adds padding around transparent areas that prevents filtering artifacts from forming on their edges. Unity does not support this property for HDR textures.

This property makes the color data of invisible texels undefined. Disable this property to preserve invisible texels' original color data.
         */
        alphaIsTransparency: boolean
        /** Returns true if this TextureImporter is setup for Sprite packing.
         */
        readonly qualifiesForSpritePacking: boolean
        /** Selects Single or Manual import mode for Sprite textures.
         */
        spriteImportMode: SpriteImportMode
        /** Array representing the sections of the atlas corresponding to individual sprite graphics.
         */
        spritesheet: Array<SpriteMetaData>
        /** Secondary textures for the imported Sprites.
         */
        secondarySpriteTextures: Array<any>
        /** Selects the Sprite packing tag.
         */
        spritePackingTag: string
        /** The number of pixels in the sprite that correspond to one unit in world space.
         */
        spritePixelsPerUnit: number
        /** The point in the Sprite object's coordinate space where the graphic is located.
         */
        spritePivot: Vector2
        /** Border sizes of the generated sprites.
         */
        spriteBorder: Vector4
        /** Which type of texture are we dealing with here.
         */
        textureType: TextureImporterType
        /** The shape of the imported texture.
         */
        textureShape: TextureImporterShape
        /** Ignore the Gamma attribute in PNG files. This property does not effect other file formats.
         */
        ignorePngGamma: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Custom mouse cursor shapes used with EditorGUIUtility.AddCursorRect.
     */
    enum MouseCursor {
        /** Normal pointer arrow.
         */
        Arrow = 0,
        /** Text cursor.
         */
        Text = 1,
        /** Vertical resize arrows.
         */
        ResizeVertical = 2,
        /** Horizontal resize arrows.
         */
        ResizeHorizontal = 3,
        /** Arrow with a Link badge (for assigning pointers).
         */
        Link = 4,
        /** Arrow with small arrows for indicating sliding at number fields.
         */
        SlideArrow = 5,
        /** Resize up-right for window edges.
         */
        ResizeUpRight = 6,
        /** Resize up-Left for window edges.
         */
        ResizeUpLeft = 7,
        /** Arrow with the move symbol next to it for the sceneview.
         */
        MoveArrow = 8,
        /** Arrow with the rotate symbol next to it for the sceneview.
         */
        RotateArrow = 9,
        /** Arrow with the scale symbol next to it for the sceneview.
         */
        ScaleArrow = 10,
        /** Arrow with the plus symbol next to it.
         */
        ArrowPlus = 11,
        /** Arrow with the minus symbol next to it.
         */
        ArrowMinus = 12,
        /** Cursor with a dragging hand for pan.
         */
        Pan = 13,
        /** Cursor with an eye for orbit.
         */
        Orbit = 14,
        /** Cursor with a magnifying glass for zoom.
         */
        Zoom = 15,
        /** Cursor with an eye and stylized arrow keys for FPS navigation.
         */
        FPS = 16,
        /** The current user defined cursor.
         */
        CustomCursor = 17,
        /** Up-Down resize arrows for window splitters.
         */
        SplitResizeUpDown = 18,
        /** Left-Right resize arrows for window splitters.
         */
        SplitResizeLeftRight = 19,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enumeration specifying the current pause state of the Editor.

Additional resources: PlayModeStateChange, EditorApplication.pauseStateChanged, EditorApplication.isPaused.
     */
    enum PauseState {
        /** Occurs as soon as the Editor is paused, which may occur during either edit mode or play mode.
         */
        Paused = 0,
        /** Occurs as soon as the Editor is unpaused, which may occur during either edit mode or play mode.
         */
        Unpaused = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enumeration specifying a change in the Editor's play mode state.

Additional resources: PauseState, EditorApplication.playModeStateChanged, EditorApplication.isPlaying.
     */
    enum PlayModeStateChange {
        /** Occurs during the next update of the Editor application if it is in edit mode and was previously in play mode.
         */
        EnteredEditMode = 0,
        /** Occurs when exiting edit mode, before the Editor is in play mode.
         */
        ExitingEditMode = 1,
        /** Occurs during the next update of the Editor application if it is in play mode and was previously in edit mode.
         */
        EnteredPlayMode = 2,
        /** Occurs when exiting play mode, before the Editor is in edit mode.
         */
        ExitingPlayMode = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Export package option. Multiple options can be combined together using the | operator.
     */
    enum ExportPackageOptions {
        /** Default mode. Will not include dependencies or subdirectories nor include Library assets unless specifically included in the asset list.
         */
        Default = 0,
        /** The export operation will be run asynchronously and reveal the exported package file in a file browser window after the export is finished.
         */
        Interactive = 1,
        /** Will recurse through any subdirectories listed and include all assets inside them.
         */
        Recurse = 2,
        /** In addition to the assets paths listed, all dependent assets will be included as well.
         */
        IncludeDependencies = 4,
        /** The exported package will include all library assets, ie. the project settings located in the Library folder of the project.
         */
        IncludeLibraryAssets = 8,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for AssetDatabase.ForceReserializeAssets.
     */
    enum ForceReserializeAssetsOptions {
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save the assets at the paths passed to the function, but not their accompanying .meta files.
         */
        ReserializeAssets = 1,
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save the .meta files for the assets at the paths passed to the function, but not the assets themselves.
         */
        ReserializeMetadata = 2,
        /** Specifies that AssetDatabase.ForceReserializeAssets should load, upgrade, and save both the assets at the paths passed to the function, and also their accompanying .meta files.
         */
        ReserializeAssetsAndMetadata = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for querying the version control system status of a file.
     */
    enum StatusQueryOptions {
        /** Force a refresh of the version control system status of the file. This is slow but accurate.
         */
        ForceUpdate = 0,
        /** This option sets the status query to first use the latest valid version control system status of the file and query for a valid status synchronously if otherwise.
         */
        UseCachedIfPossible = 1,
        /** This option sets the status query to first use the latest valid version control system status of the file and query for a valid status asynchronously if otherwise.
         */
        UseCachedAsync = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** SerializedObject and SerializedProperty are classes for editing serialized fields on Object|Unity objects in a completely generic way. These classes automatically handle dirtying individual serialized fields so they will be processed by the Undo system and styled correctly for Prefab overrides when drawn in the Inspector.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SerializedObject extends Object {
        constructor(obj: Object1, context: Object1)
        constructor(objs: Array<Object1>, context: Object1)
        constructor(obj: Object1)
        constructor(objs: Array<Object1>)
        Dispose(): void
        GetIterator(): SerializedProperty
        /** Find serialized property by name.
         */
        FindProperty(propertyPath: string): SerializedProperty
        ApplyModifiedProperties(): boolean
        SetIsDifferentCacheDirty(): void
        Update(): void
        UpdateIfRequiredOrScript(): boolean
        ApplyModifiedPropertiesWithoutUndo(): boolean
        /** Copies a value from a SerializedProperty to the corresponding serialized property on the serialized object.
         */
        CopyFromSerializedProperty(prop: SerializedProperty): void
        /** Copies a changed value from a SerializedProperty to the corresponding serialized property on the serialized object.
         */
        CopyFromSerializedPropertyIfDifferent(prop: SerializedProperty): boolean
        /** The inspected object (Read Only).
         */
        readonly targetObject: Object1
        /** The inspected objects (Read Only).
         */
        readonly targetObjects: Array<Object1>
        /** The context used to store and resolve ExposedReference types. This is set by the SerializedObject constructor.
         */
        readonly context: Object1
        /** Is true when the SerializedObject has a modified property that has not been applied.
         */
        readonly hasModifiedProperties: boolean
        /** Does the serialized object represents multiple objects due to multi-object editing? (Read Only)
         */
        readonly isEditingMultipleObjects: boolean
        /** Defines the maximum size beyond which arrays cannot be edited when multiple objects are selected.
         */
        maxArraySizeForMultiEditing: number
        /** Controls the visibility of the child hidden fields.
         */
        forceChildVisibility: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, Color, AnimationCurve, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, Quaternion, Rect, RectInt, Bounds, BoundsInt, Hash128 } from "UnityEngine";
    import { IEnumerator } from "System.Collections";
    /** SerializedProperty and SerializedObject are classes for editing properties on objects in a completely generic way that automatically handles undo, multi-object editing and Prefab overrides.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SerializedProperty extends Object {
        Copy(): SerializedProperty
        /** Retrieves the SerializedProperty at a relative path to the current property.
         */
        FindPropertyRelative(relativePropertyPath: string): SerializedProperty
        GetEnumerator(): IEnumerator
        /** Returns the element at the specified index in the array.
         */
        GetArrayElementAtIndex(index: number): SerializedProperty
        /** Move to next visible property.
         */
        NextVisible(enterChildren: boolean): boolean
        ClearArray(): void
        Dispose(): void
        /** Move to next property.
         */
        Next(enterChildren: boolean): boolean
        Reset(): void
        CountRemaining(): number
        CountInProperty(): number
        DuplicateCommand(): boolean
        DeleteCommand(): boolean
        /** Retrieves the SerializedProperty that defines the end range of this property.
         */
        GetEndProperty(includeInvisible: boolean): SerializedProperty
        GetEndProperty(): SerializedProperty
        /** Insert an empty element at the specified index in the array.
         */
        InsertArrayElementAtIndex(index: number): void
        /** Delete the element at the specified index in the array.
         */
        DeleteArrayElementAtIndex(index: number): void
        /** Move an array element from srcIndex to dstIndex.
         */
        MoveArrayElement(srcIndex: number, dstIndex: number): boolean
        /** Returns the element at the specified index in the fixed buffer.
         */
        GetFixedBufferElementAtIndex(index: number): SerializedProperty
        /** See if contained serialized properties are equal.
         */
        static EqualContents(x: SerializedProperty, y: SerializedProperty): boolean
        /** Compares the data for two SerializedProperties. This method ignores paths and SerializedObjects.
         */
        static DataEquals(x: SerializedProperty, y: SerializedProperty): boolean
        protected constructor()
        /** SerializedObject this property belongs to (Read Only).
         */
        readonly serializedObject: SerializedObject
        /** A reference to another Object in the Scene. This reference is resolved in the context of the SerializedObject containing the SerializedProperty.
         */
        exposedReferenceValue: Object1
        /** Does this property represent multiple different values due to multi-object editing? (Read Only)
         */
        readonly hasMultipleDifferentValues: boolean
        /** Nice display name of the property. (Read Only)
         */
        readonly displayName: string
        /** Name of the property. (Read Only)
         */
        readonly name: string
        /** Type name of the property. (Read Only)
         */
        readonly type: string
        /** Type name of the element in an array property. (Read Only)
         */
        readonly arrayElementType: string
        /** Tooltip of the property. (Read Only)
         */
        readonly tooltip: string
        /** Nesting depth of the property. (Read Only)
         */
        readonly depth: number
        /** Full path of the property. (Read Only)
         */
        readonly propertyPath: string
        /** Is this property editable? (Read Only)
         */
        readonly editable: boolean
        readonly isAnimated: boolean
        /** Is this property expanded in the inspector?
         */
        isExpanded: boolean
        /** Does it have child properties? (Read Only)
         */
        readonly hasChildren: boolean
        /** Does it have visible child properties? (Read Only)
         */
        readonly hasVisibleChildren: boolean
        /** Is property part of a Prefab instance? (Read Only)
         */
        readonly isInstantiatedPrefab: boolean
        /** Allows you to check whether a property's value is overriden (i.e. different to the Prefab it belongs to).
         */
        prefabOverride: boolean
        /** Allows you to check whether his property is a PrefabUtility.IsDefaultOverride|default override.

Certain properties on Prefab instances are default overrides.

See PrefabUtility.IsDefaultOverride for more information.
         */
        readonly isDefaultOverride: boolean
        /** Type of this property (Read Only).
         */
        readonly propertyType: SerializedPropertyType
        /** Value of an integer property.
         */
        intValue: number
        /** Value of a integer property as a long.
         */
        longValue: number
        /** Value of a boolean property.
         */
        boolValue: boolean
        /** Value of a float property.
         */
        floatValue: number
        /** Value of a float property as a double.
         */
        doubleValue: number
        /** Value of a string property.
         */
        stringValue: string
        /** Value of a color property.
         */
        colorValue: Color
        /** Value of a animation curve property.
         */
        animationCurveValue: AnimationCurve
        /** Value of an object reference property.
         */
        objectReferenceValue: Object1
        /** The object assigned to a field with SerializeReference attribute.
         */
        managedReferenceValue: Object
        /** Id associated with a managed reference.
         */
        managedReferenceId: number
        /** String corresponding to the value of the managed reference object (dynamic) full type string.
         */
        readonly managedReferenceFullTypename: string
        /** String corresponding to the value of the managed reference field full type string.
         */
        readonly managedReferenceFieldTypename: string
        objectReferenceInstanceIDValue: number
        /** Enum index of an enum property.
         */
        enumValueIndex: number
        /** Int32 representation of an enum property with Mixed Values.
         */
        enumValueFlag: number
        /** Names of enumeration of an enum property.
         */
        readonly enumNames: Array<string>
        /** Display-friendly names of enumeration of an enum property.
         */
        readonly enumDisplayNames: Array<string>
        /** Value of a 2D vector property.
         */
        vector2Value: Vector2
        /** Value of a 3D vector property.
         */
        vector3Value: Vector3
        /** Value of a 4D vector property.
         */
        vector4Value: Vector4
        /** Value of a 2D integer vector property.
         */
        vector2IntValue: Vector2Int
        /** Value of a 3D integer vector property.
         */
        vector3IntValue: Vector3Int
        /** Value of a quaternion property.
         */
        quaternionValue: Quaternion
        /** Value of a rectangle property.
         */
        rectValue: Rect
        /** Value of a rectangle with integer values property.
         */
        rectIntValue: RectInt
        /** Value of bounds property.
         */
        boundsValue: Bounds
        /** Value of bounds with integer values property.
         */
        boundsIntValue: BoundsInt
        /** The value of a Hash128 property.
         */
        hash128Value: Hash128
        /** Is this property an array? (Read Only)
         */
        readonly isArray: boolean
        /** The number of elements in the array.
         */
        arraySize: number
        /** The smallest number of elements in the array across all target objects. (Read Only)
         */
        readonly minArraySize: number
        /** Is this property a fixed buffer? (Read Only)
         */
        readonly isFixedBuffer: boolean
        /** The number of elements in the fixed buffer. (Read Only)
         */
        readonly fixedBufferSize: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Type of a SerializedProperty.
     */
    enum SerializedPropertyType {
        /** Integer property, for example int, byte, short, uint and long. 
         */
        Integer = 0,
        /** Boolean property.
         */
        Boolean = 1,
        /** Float or Double property.
         */
        Float = 2,
        /** String property.
         */
        String = 3,
        /** Color property.
         */
        Color = 4,
        /** Reference to an object that derives from UnityEngine.Object.
         */
        ObjectReference = 5,
        /** LayerMask property.
         */
        LayerMask = 6,
        /** Enumeration property.
         */
        Enum = 7,
        /** 2D vector property.
         */
        Vector2 = 8,
        /** 3D vector property.
         */
        Vector3 = 9,
        /** 4D vector property.
         */
        Vector4 = 10,
        /** Rectangle property.
         */
        Rect = 11,
        /** Array size property.
         */
        ArraySize = 12,
        /** Character property.
         */
        Character = 13,
        /** AnimationCurve property.
         */
        AnimationCurve = 14,
        /** Bounds property.
         */
        Bounds = 15,
        /** Gradient property.
         */
        Gradient = 16,
        /** Quaternion property.
         */
        Quaternion = 17,
        /** A reference to another Object in the Scene.
         */
        ExposedReference = 18,
        /** Fixed buffer size property.
         */
        FixedBufferSize = 19,
        /** 2D integer vector property.
         */
        Vector2Int = 20,
        /** 3D integer vector property.
         */
        Vector3Int = 21,
        /** Rectangle with Integer values property.
         */
        RectInt = 22,
        /** Bounds with Integer values property.
         */
        BoundsInt = 23,
        /** Property that references an object that does not derive from UnityEngine.Object.
         */
        ManagedReference = 24,
        /** A Hash128 property.
         */
        Hash128 = 25,
        Generic = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Provide various options to control the behavior of BuildPipeline.BuildPlayer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPlayerOptions extends ValueType {
        constructor()
        /** The Scenes to be included in the build.
         */
        scenes: Array<string>
        /** The path where the application will be built.
         */
        locationPathName: string
        /** The path to an manifest file describing all of the asset bundles used in the build (optional).
         */
        assetBundleManifestPath: string
        /** The BuildTargetGroup to build.
         */
        targetGroup: BuildTargetGroup
        /** The BuildTarget to build.
         */
        target: BuildTarget
        /** The Subtarget to build.
         */
        subtarget: number
        /** Additional BuildOptions, like whether to run the built player.
         */
        options: BuildOptions
        /** User-specified preprocessor defines used while compiling assemblies for the player.
         */
        extraScriptingDefines: Array<string>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Asset Bundle building options.
     */
    enum BuildAssetBundleOptions {
        /** Build assetBundle without any special option.
         */
        None = 0,
        /** Don't compress the data when creating the AssetBundle.
         */
        UncompressedAssetBundle = 1,
        /** Includes all dependencies.
         */
        CollectDependencies = 2,
        /** Forces inclusion of the entire asset.
         */
        CompleteAssets = 4,
        /** Do not include type information within the AssetBundle.
         */
        DisableWriteTypeTree = 8,
        /** Builds an asset bundle using a hash for the id of the object stored in the asset bundle.
         */
        DeterministicAssetBundle = 16,
        /** Force rebuild the assetBundles.
         */
        ForceRebuildAssetBundle = 32,
        /** Ignore the type tree changes when doing the incremental build check.
         */
        IgnoreTypeTreeChanges = 64,
        /** Append the hash to the assetBundle name.
         */
        AppendHashToAssetBundleName = 128,
        /** Use chunk-based LZ4 compression when creating the AssetBundle.
         */
        ChunkBasedCompression = 256,
        /** Do not allow the build to succeed if any errors are reporting during it.
         */
        StrictMode = 512,
        /** Do a dry run build.
         */
        DryRunBuild = 1024,
        /** Disables Asset Bundle LoadAsset by file name.
         */
        DisableLoadAssetByFileName = 4096,
        /** Disables Asset Bundle LoadAsset by file name with extension.
         */
        DisableLoadAssetByFileNameWithExtension = 8192,
        /** Removes the Unity Version number in the Archive File & Serialized File headers during the build.
         */
        AssetBundleStripUnityVersion = 32768,
        /** Use the content of the asset bundle to calculate the hash. Enabling this flag is recommended to improve incremental build results, but it will force a rebuild of all existing AssetBundles that have been built without the flag.
         */
        UseContentHash = 65536,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Target build platform.
     */
    enum BuildTarget {
        /** Build a macOS standalone (Intel 64-bit).
         */
        StandaloneOSX = 2,
        StandaloneOSXUniversal = 3,
        /** Build a macOS Intel 32-bit standalone. (This build target is deprecated)
         */
        StandaloneOSXIntel = 4,
        /** Build a Windows standalone.
         */
        StandaloneWindows = 5,
        /** Build a web player. (This build target is deprecated. Building for web player will no longer be supported in future versions of Unity.)
         */
        WebPlayer = 6,
        /** Build a streamed web player.
         */
        WebPlayerStreamed = 7,
        /** Build an iOS player.
         */
        iOS = 9,
        PS3 = 10,
        XBOX360 = 11,
        /** Build an Android .apk standalone app.
         */
        Android = 13,
        /** Build a Linux standalone.
         */
        StandaloneLinux = 17,
        /** Build a Windows 64-bit standalone.
         */
        StandaloneWindows64 = 19,
        /** WebGL.
         */
        WebGL = 20,
        /** Build an Windows Store Apps player.
         */
        WSAPlayer = 21,
        /** Build a Linux 64-bit standalone.
         */
        StandaloneLinux64 = 24,
        /** Build a Linux universal standalone.
         */
        StandaloneLinuxUniversal = 25,
        WP8Player = 26,
        /** Build a macOS Intel 64-bit standalone. (This build target is deprecated)
         */
        StandaloneOSXIntel64 = 27,
        BlackBerry = 28,
        Tizen = 29,
        PSP2 = 30,
        /** Build a PS4 Standalone.
         */
        PS4 = 31,
        PSM = 32,
        /** Build a Xbox One Standalone.
         */
        XboxOne = 33,
        SamsungTV = 34,
        /** Build to Nintendo 3DS platform.
         */
        N3DS = 35,
        WiiU = 36,
        /** Build to Apple's tvOS platform.
         */
        tvOS = 37,
        /** Build a Nintendo Switch player.
         */
        Switch = 38,
        Lumin = 39,
        /** Build a Stadia standalone.
         */
        Stadia = 40,
        /** Build a LinuxHeadlessSimulation standalone.
         */
        LinuxHeadlessSimulation = 41,
        /** Build a LinuxHeadlessSimulation standalone.
         */
        CloudRendering = 41,
        GameCoreScarlett = 42,
        GameCoreXboxSeries = 42,
        GameCoreXboxOne = 43,
        /** Build to PlayStation 5 platform.
         */
        PS5 = 44,
        EmbeddedLinux = 45,
        NoTarget = -2,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        iPhone = -1,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        BB10 = -1,
        /** OBSOLETE: Use iOS. Build an iOS player.
         */
        MetroPlayer = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Building options. Multiple options can be combined together.
     */
    enum BuildOptions {
        /** Force full optimizations for script compilation in Development builds.
         */
        None = 0,
        /** Force full optimizations for script compilation in Development builds.
         */
        CompressTextures = 0,
        /** Force full optimizations for script compilation in Development builds.
         */
        StripDebugSymbols = 0,
        /** Force full optimizations for script compilation in Development builds.
         */
        ForceOptimizeScriptCompilation = 0,
        /** Force full optimizations for script compilation in Development builds.
         */
        Il2CPP = 0,
        /** Build a development version of the player.
         */
        Development = 1,
        /** Run the built player.
         */
        AutoRunPlayer = 4,
        /** Show the built player.
         */
        ShowBuiltPlayer = 8,
        /** Build a compressed asset bundle that contains streamed Scenes loadable with the UnityWebRequest class.
         */
        BuildAdditionalStreamedScenes = 16,
        /** Used when building Xcode (iOS) or Eclipse (Android) projects.
         */
        AcceptExternalModificationsToPlayer = 32,
        InstallInBuildFolder = 64,
        /** Clear all cached build results, resulting in a full rebuild of all scripts and all player data.
         */
        CleanBuildCache = 128,
        /** Start the player with a connection to the profiler in the editor.
         */
        ConnectWithProfiler = 256,
        /** Allow script debuggers to attach to the Player remotely. You can debug your scripts only if you use BuildOptions.Development.
         */
        AllowDebugging = 512,
        /** Symlink runtime libraries when generating iOS Xcode project. (Faster iteration time).
         */
        SymlinkLibraries = 1024,
        /** Symlink runtime libraries when generating iOS Xcode project. (Faster iteration time).
         */
        SymlinkSources = 1024,
        /** Don't compress the data when creating the asset bundle.
         */
        UncompressedAssetBundle = 2048,
        /** Sets the Player to connect to the Editor.
         */
        ConnectToHost = 4096,
        /** Determines if the player should be using the custom connection ID.
         */
        CustomConnectionID = 8192,
        /** Options for building the standalone player in headless mode.
         */
        EnableHeadlessMode = 16384,
        /** Only build the scripts in a Project.
         */
        BuildScriptsOnly = 32768,
        /** Patch a Development app package rather than completely rebuilding it.

Supported platforms: Android.
         */
        PatchPackage = 65536,
        /** Include assertions in the build. By default, the assertions are only included in development builds.
         */
        ForceEnableAssertions = 131072,
        /** Use chunk-based LZ4 compression when building the Player.
         */
        CompressWithLz4 = 262144,
        /** Use chunk-based LZ4 high-compression when building the Player.
         */
        CompressWithLz4HC = 524288,
        ComputeCRC = 1048576,
        /** Do not allow the build to succeed if any errors are reporting during it.
         */
        StrictMode = 2097152,
        /** Build will include Assemblies for testing.
         */
        IncludeTestAssemblies = 4194304,
        /** Will force the buildGUID to all zeros.
         */
        NoUniqueIdentifier = 8388608,
        /** Sets the Player to wait for player connection on player start.
         */
        WaitForPlayerConnection = 33554432,
        /** Enables code coverage. You can use this as a complimentary way of enabling code coverage on platforms that do not support command line arguments.
         */
        EnableCodeCoverage = 67108864,
        /** Enables Deep Profiling support in the player.
         */
        EnableDeepProfilingSupport = 268435456,
        /** Generates more information in the BuildReport.
         */
        DetailedBuildReport = 536870912,
        /** Enable Shader Livelink support.
         */
        ShaderLivelinkSupport = 1073741824,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType, Enum } from "System";
    import { Component, Object as Object1, GameObject, PrimitiveType } from "UnityEngine";
    /** Use the DefaultObject to create a new UnityEngine.Object in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ObjectFactory extends Object {
        /** Create a new instance of the given type.
         * @param type The type of instance to create.
         */
        static CreateInstance(type: any): Object1
        /** Creates a new component and adds it to the specified GameObject.
         * @param gameObject The GameObject to add the new component to.
         * @param type The type of component to create and add to the GameObject.
         * @returns Returns the component that was created and added to the GameObject. 
         */
        static AddComponent(gameObject: GameObject, type: any): Component
        /** Creates a new GameObject.
         * @param name Name of the GameObject.
         * @param types The optional types to add to the GameObject when created.
         * @param scene Scene where the GameObject should be created.
         * @param hideFlags HideFlags to assign to the GameObject.
         * @returns Returns the GameObject that was created. 
         */
        static CreateGameObject(scene: any, hideFlags: any, name: string, ...types: any[]): GameObject
        /** Creates a new GameObject.
         * @param name Name of the GameObject.
         * @param types The optional types to add to the GameObject when created.
         * @param scene Scene where the GameObject should be created.
         * @param hideFlags HideFlags to assign to the GameObject.
         * @returns Returns the GameObject that was created. 
         */
        static CreateGameObject(name: string, ...types: any[]): GameObject
        /** Creates a GameObject primitive.
         * @param type The type of primitive to create.
         */
        static CreatePrimitive(type: PrimitiveType): GameObject
        static componentWasAdded(op: "add" | "remove", fn: (obj: Component) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Unity Camera Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CameraEditor extends Editor {
        constructor()
        OnEnable(): void
        OnDestroy(): void
        OnDisable(): void
        OnInspectorGUI(): void
        OnSceneGUI(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Camera, Vector3, Rect, Matrix4x4 } from "UnityEngine";
    /** Utilities for cameras.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class CameraEditorUtils extends Object {
        static HandleFrustum(c: Camera, cameraEditorTargetIndex: number): void
        /** Draw the frustrum gizmo of a camera.
         * @param camera The camera to use.
         */
        static DrawFrustumGizmo(camera: Camera): void
        /** Calculate the frustrum corners from the sensor physical properties, without taking gate fitting into account.
To get the actual frustum with gate fit adjustment, use CameraEditorUtils.TryGetFrustum.
This method is equivalent to CameraEditorUtils.TryGetFrustum for non-physical cameras.

Corners are calculated in this order: left bottom, left top, right top, right bottom.
         * @param camera Camera to use.
         * @param near The corners of the near plane. (A minimum size of 4 elements is required.)
         * @param far The corners of the far plane. (A minimum size of 4 elements is required.)
         * @param frustumAspect The aspect ratio of the frustrum.
         * @returns Whether the frustrum was calculated. 
         */
        static TryGetSensorGateFrustum(camera: Camera, near: Array<Vector3>, far: Array<Vector3>, frustumAspect: jsb.Out<number>): boolean
        /** Calculate the frustrum corners.

Corners are calculated in this order: left bottom, left top, right top, right bottom.
         * @param camera Camera to use.
         * @param near The corners of the near plane. (A minimum size of 4 elements is required.)
         * @param far The corners of the far plane. (A minimum size of 4 elements is required.)
         * @param frustumAspect The aspect ratio of the frustrum.
         * @returns Whether the frustrum was calculated. 
         */
        static TryGetFrustum(camera: Camera, near: Array<Vector3>, far: Array<Vector3>, frustumAspect: jsb.Out<number>): boolean
        /** Check whether a viewport is valid.
         * @param normalizedViewPortRect Viewport to check.
         * @returns Whether the viewport is valid. 
         */
        static IsViewportRectValidToRender(normalizedViewPortRect: Rect): boolean
        /** Calculate the frustrum aspect ratio of a camera.
         * @param camera Camera to use.
         * @returns The frustrum aspect ratio of the provided camera. 
         */
        static GetFrustumAspectRatio(camera: Camera): number
        /** Calculate the world space position of a point in clip space.

The z component will be used to get the point at the distance z from the viewer.
         * @param clipToWorld Clip to world matrix to use.
         * @param viewPositionWS The viewer's position in world space.
         * @param positionCS The position in clip space.
         * @returns The corresponding world space position. 
         */
        static PerspectiveClipToWorld(clipToWorld: Matrix4x4, viewPositionWS: Vector3, positionCS: Vector3): Vector3
        /** Calculate the points of the frustrum plane facing the viewer at a specific distance.

The points array will be filled with the calculated points in the following order: left bottom, left top, right top and right bottom.
         * @param clipToWorld Clip space to world space matrix.
         * @param viewPosition View position in world space.
         * @param distance Distance from the view position of the plane.
         * @param points Calculated points.  (A minimum size of 4 elements is required).
         */
        static GetFrustumPlaneAt(clipToWorld: Matrix4x4, viewPosition: Vector3, distance: number, points: Array<Vector3>): void
        /** The aspect ratio of the game view.
         */
        static readonly GameViewAspectRatio: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector3, Transform } from "UnityEngine";
    /** Editor Transform Utility Class.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TransformUtils extends Object {
        /** Returns the rotation of a transform as it is shown in the Transform Inspector window.
         * @param t Transform to get the rotation from.
         * @returns Rotation as it is shown in the Transform Inspector window. 
         */
        static GetInspectorRotation(t: Transform): Vector3
        /** Sets the rotation of a transform as it would be set by the Transform Inspector window.
         * @param t Transform to set the rotation on.
         * @param r Rotation as it would be set by the Transform Inspector window.
         */
        static SetInspectorRotation(t: Transform, r: Vector3): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Utility functions for working with JSON data and engine objects.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorJsonUtility extends Object {
        /** Generate a JSON representation of an object.
         * @param obj The object to convert to JSON form.
         * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
         * @returns The object's data in JSON format. 
         */
        static ToJson(obj: Object, prettyPrint: boolean): string
        /** Generate a JSON representation of an object.
         * @param obj The object to convert to JSON form.
         * @param prettyPrint If true, format the output for readability. If false, format the output for minimum size. Default is false.
         * @returns The object's data in JSON format. 
         */
        static ToJson(obj: Object): string
        /** Overwrite data in an object by reading from its JSON representation.
         * @param json The JSON representation of the object.
         * @param objectToOverwrite The object to overwrite.
         */
        static FromJsonOverwrite(json: string, objectToOverwrite: Object): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GameObject, Transform } from "UnityEngine";
    /** GameObject utility functions.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GameObjectUtility extends Object {
        constructor()
        /** Gets the StaticEditorFlags of the GameObject specified.
         * @param go The GameObject whose flags you are interested in.
         * @returns The static editor flags of the GameObject specified. 
         */
        static GetStaticEditorFlags(go: GameObject): StaticEditorFlags
        /** Sets the StaticEditorFlags of the specified GameObject.
         * @param go The GameObject whose Static Editor Flags you want to set.
         * @param flags The StaticEditorFlags to set on the GameObject.
         */
        static SetStaticEditorFlags(go: GameObject, flags: StaticEditorFlags): void
        /** Returns true if the passed in StaticEditorFlags are set on the GameObject specified.
         * @param go The GameObject to check.
         * @param flags The flags you want to check.
         * @returns Whether the GameObject's static flags match the flags specified. 
         */
        static AreStaticEditorFlagsSet(go: GameObject, flags: StaticEditorFlags): boolean
        /** Get the navmesh area index for the GameObject.
         * @param go The GameObject to query.
         * @returns NavMesh area index. 
         */
        static GetNavMeshArea(go: GameObject): number
        /** Set the navmesh area for the gameobject.
         * @param go GameObject to modify.
         * @param areaIndex NavMesh area index to set.
         */
        static SetNavMeshArea(go: GameObject, areaIndex: number): void
        /** Get the navmesh area index from the area name.
         * @param name NavMesh area name to query.
         * @returns The NavMesh area index. If there is no NavMesh area with the requested name, the return value is -1. 
         */
        static GetNavMeshAreaFromName(name: string): number
        static GetNavMeshAreaNames(): Array<string>
        /** You can use this method before instantiating a new sibling, or before parenting one GameObject to another, to ensure the new child GameObject has a unique name compared to its siblings in the hierarchy.
         * @param parent Target parent for a new GameObject. Null means root level.
         * @param name Requested name for a new GameObject.
         * @returns Unique name for a new GameObject. 
         */
        static GetUniqueNameForSibling(parent: Transform, name: string): string
        /** You can use this method after parenting one GameObject to another to ensure the child GameObject has a unique name compared to its siblings in the hierarchy.
         * @param self The GameObject whose name you want to ensure is unique.
         */
        static EnsureUniqueNameForSibling(self: GameObject): void
        /** Sets the parent and gives the child the same layer and position.
         * @param child The GameObject that should have a new parent set.
         * @param parent The GameObject that the child should get as a parent and have position and layer copied from. If null, this function does nothing.
         */
        static SetParentAndAlign(child: GameObject, parent: GameObject): void
        /** Gets the number of MonoBehaviours with a missing script for the given GameObject.
         * @param go GameObject to query.
         * @returns The number of MonoBehaviours with a missing script. 
         */
        static GetMonoBehavioursWithMissingScriptCount(go: GameObject): number
        /** Removes the MonoBehaviours with a missing script from the given GameObject.
         * @param go The GameObject to remove MonoBehaviours with a missing script from.
         * @returns The number of MonoBehaviours with a missing script that were removed. 
         */
        static RemoveMonoBehavioursWithMissingScript(go: GameObject): number
        /** Use this method if a custom scene culling mask is needed for renderers that should be shown or hidden in a Scene view when Prefab Mode in Context is active.
         * @param sceneCullingMask The scene culling mask intended to be used with the custom renderer.
         * @param gameObject The GameObject associated with the custom renderer.
         * @returns If the GameObject is hidden for Prefab Mode in Context, a modified scene culling mask is returned. If it's not hidden, then the input scene culling mask is returned. 
         */
        static ModifyMaskIfGameObjectIsHiddenForPrefabModeInContext(sceneCullingMask: number, gameObject: GameObject): number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Stores and accesses Unity Editor preferences.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorPrefs extends Object {
        /** Sets the value of the preference identified by key as an integer.
         * @param key Name of key to write integer to.
         * @param value Value of the integer to write into the storage.
         */
        static SetInt(key: string, value: number): void
        /** Returns the value corresponding to key in the preference file if it exists.
         * @param key Name of key to read integer from.
         * @param defaultValue Integer value to return if the key is not in the storage.
         * @returns The value stored in the preference file. 
         */
        static GetInt(key: string, defaultValue: number): number
        /** Returns the value corresponding to key in the preference file if it exists.
         * @param key Name of key to read integer from.
         * @param defaultValue Integer value to return if the key is not in the storage.
         * @returns The value stored in the preference file. 
         */
        static GetInt(key: string): number
        /** Sets the float value of the preference identified by key.
         * @param key Name of key to write float into.
         * @param value Float value to write into the storage.
         */
        static SetFloat(key: string, value: number): void
        /** Returns the float value corresponding to key if it exists in the preference file.
         * @param key Name of key to read float from.
         * @param defaultValue Float value to return if the key is not in the storage.
         * @returns The float value stored in the preference file or the defaultValue id the
        requested float does not exist. 
         */
        static GetFloat(key: string, defaultValue: number): number
        /** Returns the float value corresponding to key if it exists in the preference file.
         * @param key Name of key to read float from.
         * @param defaultValue Float value to return if the key is not in the storage.
         * @returns The float value stored in the preference file or the defaultValue id the
        requested float does not exist. 
         */
        static GetFloat(key: string): number
        /** Sets the value of the preference identified by key. Note that EditorPrefs does not support null strings and will store an empty string instead.
         */
        static SetString(key: string, value: string): void
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetString(key: string, defaultValue: string): string
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetString(key: string): string
        /** Sets the value of the preference identified by key.
         */
        static SetBool(key: string, value: boolean): void
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetBool(key: string, defaultValue: boolean): boolean
        /** Returns the value corresponding to key in the preference file if it exists.
         */
        static GetBool(key: string): boolean
        /** Returns true if key exists in the preferences file.
         * @param key Name of key to check for.
         * @returns The existence or not of the key. 
         */
        static HasKey(key: string): boolean
        /** Removes key and its corresponding value from the preferences.
         */
        static DeleteKey(key: string): void
        static DeleteAll(): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { Color, Camera, Matrix4x4, Vector3, Quaternion, EventType, Vector2, Transform, Texture2D, Rect, GUIStyle, GUIContent, Texture, Gradient } from "UnityEngine";
    /** Custom 3D GUI controls and drawing in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Handles extends Object {
        /** Draw a line going through the list of points.
         */
        static DrawPolyLine(...points: Vector3[]): void
        /** Draws a line from p1 to p2.
         * @param p1 The position of the first line's end point in world space.
         * @param p2 The position of the second line's end point in world space.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawLine(p1: Vector3, p2: Vector3, thickness: number): void
        /** Draws a line from p1 to p2.
         * @param p1 The position of the first line's end point in world space.
         * @param p2 The position of the second line's end point in world space.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawLine(p1: Vector3, p2: Vector3): void
        /** Draw a list of indexed line segments.
         * @param points A list of points.
         * @param segmentIndices A list of pairs of indices to the start and end points of the line segments.
         */
        static DrawLines(points: Array<Vector3>, segmentIndices: Array<number>): void
        /** Draw a list of line segments.
         * @param lineSegments A list of pairs of points that represent the start and end of line segments.
         */
        static DrawLines(lineSegments: Array<Vector3>): void
        /** Draw a dotted line from p1 to p2.
         * @param p1 The start point.
         * @param p2 The end point.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLine(p1: Vector3, p2: Vector3, screenSpaceSize: number): void
        /** Draw a list of indexed dotted line segments.
         * @param points A list of points.
         * @param segmentIndices A list of pairs of indices to the start and end points of the line segments.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLines(points: Array<Vector3>, segmentIndices: Array<number>, screenSpaceSize: number): void
        /** Draw a list of dotted line segments.
         * @param lineSegments A list of pairs of points that represent the start and end of line segments.
         * @param screenSpaceSize The size in pixels for the lengths of the line segments and the gaps between them.
         */
        static DrawDottedLines(lineSegments: Array<Vector3>, screenSpaceSize: number): void
        /** Draw a wireframe box with center and size.
         */
        static DrawWireCube(center: Vector3, size: Vector3): void
        static ShouldRenderGizmos(): boolean
        static DrawGizmos(camera: Camera): void
        /** Make a 3D disc that can be dragged with the mouse.
         * @param id Control id of the handle.
         * @param rotation The rotation of the disc.
         * @param position The center of the disc.
         * @param axis The axis to rotate around.
         * @param size The size of the disc in world space.
         * @param cutoffPlane If true, only the front-facing half of the circle is draw / draggable. This is useful when you have many overlapping rotation axes (like in the default rotate tool) to avoid clutter.
         * @param snap The grid size to snap to.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static Disc(id: number, rotation: Quaternion, position: Vector3, axis: Vector3, size: number, cutoffPlane: boolean, snap: number): Quaternion
        /** Make a 3D disc that can be dragged with the mouse.
         * @param id Control id of the handle.
         * @param rotation The rotation of the disc.
         * @param position The center of the disc.
         * @param axis The axis to rotate around.
         * @param size The size of the disc in world space.
         * @param cutoffPlane If true, only the front-facing half of the circle is draw / draggable. This is useful when you have many overlapping rotation axes (like in the default rotate tool) to avoid clutter.
         * @param snap The grid size to snap to.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static Disc(rotation: Quaternion, position: Vector3, axis: Vector3, size: number, cutoffPlane: boolean, snap: number): Quaternion
        /** Make an unconstrained rotation handle.
         * @param id Control id of the handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param size The size of the handle.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static FreeRotateHandle(id: number, rotation: Quaternion, position: Vector3, size: number): Quaternion
        /** Make an unconstrained rotation handle.
         * @param id Control id of the handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param size The size of the handle.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static FreeRotateHandle(rotation: Quaternion, position: Vector3, size: number): Quaternion
        static Slider(controlID: number, position: Vector3, offset: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        static Slider(controlID: number, position: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        static Slider(position: Vector3, direction: Vector3, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        /** Make a 3D slider that moves along one axis.
         * @param position The position of the current point in the space of Handles.matrix.
         * @param direction The direction axis of the slider in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param snap The snap increment. See Handles.SnapValue.
         * @param capFunction The function to call for doing the actual drawing. By default it is Handles.ArrowHandleCap, but any function that has the same signature can be used.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the position value passed into the function. 
         */
        static Slider(position: Vector3, direction: Vector3): Vector3
        static FreeMoveHandle(controlID: number, position: Vector3, rotation: Quaternion, size: number, snap: Vector3, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): Vector3
        static FreeMoveHandle(position: Vector3, rotation: Quaternion, size: number, snap: Vector3, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): Vector3
        static ScaleValueHandle(controlID: number, value: number, position: Vector3, rotation: Quaternion, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): number
        static ScaleValueHandle(value: number, position: Vector3, rotation: Quaternion, size: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): number
        static Button(position: Vector3, direction: Quaternion, size: number, pickSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): boolean
        /** Draw a cube handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CubeHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a sphere handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         */
        static SphereHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a cone handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static ConeHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a cylinder handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CylinderHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a rectangle handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static RectangleHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a dot handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static DotHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw a circle handle. Pass this into handle functions.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static CircleHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Draw an arrow like those used by the move tool.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static ArrowHandleCap(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Creates a square at a position and rotation with a specified size.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen space size.
         * @param controlID The control ID for the handle.
         * @param eventType The type of event for the handle to act on. You can only use this function with EventType.Repaint.
         */
        static DrawSelectionFrame(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** Make a position handle.
         * @param position Center of the handle in 3D space.
         * @param rotation Orientation of the handle in 3D space.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static PositionHandle(position: Vector3, rotation: Quaternion): Vector3
        /** Make a Scene view rotation handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @returns The new rotation value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static RotationHandle(rotation: Quaternion, position: Vector3): Quaternion
        /** Make a Scene view scale handle.
         * @param scale Scale to modify.
         * @param position The position of the handle.
         * @param rotation The rotation of the handle.
         * @param size Allows you to scale the size of the handle on-screen.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static ScaleHandle(scale: Vector3, position: Vector3, rotation: Quaternion, size: number): Vector3
        static ScaleHandle(scale: Vector3, position: Vector3, rotation: Quaternion): Vector3
        /** Make a Scene view radius handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param radius Radius to modify.
         * @param handlesOnly Whether to omit the circular outline of the radius and only draw the point handles.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles. 
         */
        static RadiusHandle(rotation: Quaternion, position: Vector3, radius: number, handlesOnly: boolean): number
        /** Make a Scene view radius handle.
         * @param rotation Orientation of the handle.
         * @param position Center of the handle in 3D space.
         * @param radius Radius to modify.
         * @param handlesOnly Whether to omit the circular outline of the radius and only draw the point handles.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles. 
         */
        static RadiusHandle(rotation: Quaternion, position: Vector3, radius: number): number
        static Slider2D(id: number, handlePos: Vector3, offset: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(id: number, handlePos: Vector3, offset: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(id: number, handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2, drawHelper: boolean): Vector3
        static Slider2D(id: number, handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number, drawHelper: boolean): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: Vector2): Vector3
        static Slider2D(handlePos: Vector3, handleDir: Vector3, slideDir1: Vector3, slideDir2: Vector3, handleSize: number, capFunction: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void, snap: number): Vector3
        /** Make a directional scale slider.
         * @param scale The value the user can modify.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param direction The direction of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param snap The snap increment. See Handles.SnapValue.
         * @returns The new value modified by the user's interaction with the handle. If the user has not moved the handle, it will return the same value as you passed into the function. 
         */
        static ScaleSlider(scale: number, position: Vector3, direction: Vector3, rotation: Quaternion, size: number, snap: number): number
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: number, snap: number): number
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: Vector2, snap: Vector2): Vector2
        /** Rounds value to the closest multiple of snap if snapping is active. Note that snap can only be positive.
         * @param value The value to snap.
         * @param snap The increment to snap to.
         * @returns If snapping is active, rounds value to the closest multiple of snap (snap can only be positive). 
         */
        static SnapValue(value: Vector3, snap: Vector3): Vector3
        /** Rounds each Transform.position to the closest multiple of EditorSnap.move.
         * @param transforms The transforms to snap.
         * @param axis The axes on which to apply snapping.
         */
        static SnapToGrid(transforms: Array<Transform>, axis: any): void
        static SelectionFrame(controlID: number, position: Vector3, rotation: Quaternion, size: number): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         * @param colors The colors to apply to each point. Must match the length of the points array or actualNumberOfPoints, whichever is lower and greater than zero.
         * @param actualNumberOfPoints The total number of vertices to draw of the points array. Use this to keep a reusable buffer of point values without the need to resize frequently.
         */
        static DrawAAPolyLine(width: number, actualNumberOfPoints: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         * @param colors The colors to apply to each point. Must match the length of the points array or actualNumberOfPoints, whichever is lower and greater than zero.
         * @param actualNumberOfPoints The total number of vertices to draw of the points array. Use this to keep a reusable buffer of point values without the need to resize frequently.
         */
        static DrawAAPolyLine(lineTex: Texture2D, width: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         * @param colors The colors to apply to each point. Must match the length of the points array or actualNumberOfPoints, whichever is lower and greater than zero.
         * @param actualNumberOfPoints The total number of vertices to draw of the points array. Use this to keep a reusable buffer of point values without the need to resize frequently.
         */
        static DrawAAPolyLine(width: number, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         * @param colors The colors to apply to each point. Must match the length of the points array or actualNumberOfPoints, whichever is lower and greater than zero.
         * @param actualNumberOfPoints The total number of vertices to draw of the points array. Use this to keep a reusable buffer of point values without the need to resize frequently.
         */
        static DrawAAPolyLine(lineTex: Texture2D, ...points: Vector3[]): void
        /** Draw anti-aliased line specified with point array and width.
         * @param lineTex The AA texture used for rendering.
         * @param width The width of the line.
         * @param points List of points to build the line from.
         * @param colors The colors to apply to each point. Must match the length of the points array or actualNumberOfPoints, whichever is lower and greater than zero.
         * @param actualNumberOfPoints The total number of vertices to draw of the points array. Use this to keep a reusable buffer of point values without the need to resize frequently.
         */
        static DrawAAPolyLine(...points: Vector3[]): void
        /** Draw anti-aliased convex polygon specified with point array.
         * @param points List of points describing the convex polygon.
         */
        static DrawAAConvexPolygon(...points: Vector3[]): void
        /** Draw textured bezier line through start and end points with the given tangents.
         * @param startPosition The start point of the bezier line.
         * @param endPosition The end point of the bezier line.
         * @param startTangent The start tangent of the bezier line.
         * @param endTangent The end tangent of the bezier line.
         * @param color The color to use for the bezier line.
         * @param texture The texture to use for drawing the bezier line.
         * @param width The width of the bezier line.
         */
        static DrawBezier(startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3, color: Color, texture: Texture2D, width: number): void
        /** Draws the outline of a flat disc in 3D space.
         * @param center The center of the disc in world space.
         * @param normal The normal of the disc in world space.
         * @param radius The radius of the disc in world space units.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawWireDisc(center: Vector3, normal: Vector3, radius: number, thickness: number): void
        /** Draws the outline of a flat disc in 3D space.
         * @param center The center of the disc in world space.
         * @param normal The normal of the disc in world space.
         * @param radius The radius of the disc in world space units.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawWireDisc(center: Vector3, normal: Vector3, radius: number): void
        /** Draws a circular arc in 3D space.
         * @param center The center of the circle in world space.
         * @param normal The normal of the circle in world space.
         * @param from The direction of the point on the circle circumference, relative to the center, where the arc begins.
         * @param angle The angle of the arc, in degrees.
         * @param radius The radius of the circle in world space units.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawWireArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number, thickness: number): void
        /** Draws a circular arc in 3D space.
         * @param center The center of the circle in world space.
         * @param normal The normal of the circle in world space.
         * @param from The direction of the point on the circle circumference, relative to the center, where the arc begins.
         * @param angle The angle of the arc, in degrees.
         * @param radius The radius of the circle in world space units.
         * @param thickness Line thickness in UI points (zero thickness draws single-pixel line).
         */
        static DrawWireArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): void
        static DrawSolidRectangleWithOutline(rectangle: Rect, faceColor: Color, outlineColor: Color): void
        /** Draw a solid outlined rectangle in 3D space.
         * @param verts The 4 vertices of the rectangle in world coordinates.
         * @param faceColor The color of the rectangle's face.
         * @param outlineColor The outline color of the rectangle.
         */
        static DrawSolidRectangleWithOutline(verts: Array<Vector3>, faceColor: Color, outlineColor: Color): void
        /** Draw a solid flat disc in 3D space.
         * @param center The center of the disc.
         * @param normal The normal of the disc.
         * @param radius The radius of the disc.

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static DrawSolidDisc(center: Vector3, normal: Vector3, radius: number): void
        /** Draw a circular sector (pie piece) in 3D space.
         * @param center The center of the circle.
         * @param normal The normal of the circle.
         * @param from The direction of the point on the circumference, relative to the center, where the sector begins.
         * @param angle The angle of the sector, in degrees.
         * @param radius The radius of the circle

Note: Use HandleUtility.GetHandleSize where you might want to have constant screen-sized handles.
         */
        static DrawSolidArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Vector3, text: string, style: GUIStyle): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Vector3, content: GUIContent, style: GUIStyle): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Vector3, text: string): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Vector3, image: Texture): void
        /** Make a text label positioned in 3D space.
         * @param position Position in 3D space as seen from the current handle camera.
         * @param text Text to display on the label.
         * @param image Texture to display on the label.
         * @param content Text, image and tooltip for this label.
         * @param style The style to use. If left out, the label style from the current GUISkin is used.
         */
        static Label(position: Vector3, content: GUIContent): void
        static GetMainGameViewSize(): Vector2
        /** Clears the camera.
         * @param position Where in the Scene to clear.
         * @param camera The camera to clear.
         */
        static ClearCamera(position: Rect, camera: Camera): void
        static DrawCamera(position: Rect, camera: Camera, drawMode: DrawCameraMode, drawGizmos: boolean): void
        /** Draws a camera inside a rectangle.
         * @param position The area to draw the camera within in GUI coordinates.
         * @param camera The camera to draw.
         * @param drawMode How the camera is drawn (textured, wireframe, etc.).
         */
        static DrawCamera(position: Rect, camera: Camera, drawMode: DrawCameraMode): void
        /** Draws a camera inside a rectangle.
         * @param position The area to draw the camera within in GUI coordinates.
         * @param camera The camera to draw.
         * @param drawMode How the camera is drawn (textured, wireframe, etc.).
         */
        static DrawCamera(position: Rect, camera: Camera): void
        /** Set the current camera so all Handles and Gizmos are draw with its settings.
         */
        static SetCamera(position: Rect, camera: Camera): void
        /** Set the current camera so all Handles and Gizmos are draw with its settings.
         */
        static SetCamera(camera: Camera): void
        static BeginGUI(): void
        static EndGUI(): void
        /** Retuns an array of points to representing the bezier curve.
         */
        static MakeBezierPoints(startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3, division: number): Array<Vector3>
        /** Draws a 3D texture using Signed Distance Field rendering mode in 3D space.
         * @param texture The volumetric texture to draw.
         * @param stepScale The number by which to multiply the ray step size. The ray step size is the distance between 2 neighboring pixels. The default value is 1.
         * @param surfaceOffset The intensity of the pixels at which the surface is rendered. When this value is positive, Unity will expand the rendered surface. When this value is negative, Unity will render empty space as a surface, and a surface as empty space. The default value is 0.
         * @param customColorRamp The custom gradient that Unity uses as a color ramp. If this is not specified, Unity uses <a href="https:ai.googleblog.com201908turbo-improved-rainbow-colormap-for.html">Google Turbo color ramp<a>.
         */
        static DrawTexture3DSDF(texture: Texture, stepScale: number, surfaceOffset: number, customColorRamp: Gradient): void
        /** Draws a 3D texture using Slice rendering mode in 3D space.
         * @param texture The volumetric texture to draw.
         * @param slicePositions The positions of the texture sampling planes.
         * @param filterMode Sets the texture filtering mode to use.
         * @param useColorRamp Enables color ramp visualization.
         * @param customColorRamp The custom gradient that Unity uses as a color ramp. If this is not specified, Unity uses <a href="https:ai.googleblog.com201908turbo-improved-rainbow-colormap-for.html">Google Turbo color ramp<a>.
         */
        static DrawTexture3DSlice(texture: Texture, slicePositions: Vector3, filterMode: any, useColorRamp: boolean, customColorRamp: Gradient): void
        /** Draws a 3D texture using Volume rendering mode in 3D space.
         * @param texture The volumetric texture to draw.
         * @param opacity The non-linear volume opacity modifier. Use this to control the opacity of the visualization. Valid values are 0-1, inclusive. A value of 1 is fully opaque and a value of 0 is fully transparent. The default value is 1.
         * @param qualityModifier Sets the sample per texture pixel count. Higher values result in a higher quality render. The default value is 1.
         * @param filterMode Sets the texture filtering mode to use.
         * @param useColorRamp Enables color ramp visualization.
         * @param customColorRamp The custom gradient that Unity uses as a color ramp. If this is not specified, Unity uses <a href="https:ai.googleblog.com201908turbo-improved-rainbow-colormap-for.html">Google Turbo color ramp<a>.
         */
        static DrawTexture3DVolume(texture: Texture, opacity: number, qualityModifier: number, filterMode: any, useColorRamp: boolean, customColorRamp: Gradient): void
        static DoRotationHandle(rotation: Quaternion, position: Vector3): Quaternion
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>, scale: jsb.Ref<Vector3>): void
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: Quaternion, scale: jsb.Ref<Vector3>): void
        static TransformHandle(position: Vector3, rotation: jsb.Ref<Quaternion>, scale: jsb.Ref<Vector3>): void
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>, uniformScale: jsb.Ref<number>): void
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: Quaternion, uniformScale: jsb.Ref<number>): void
        static TransformHandle(position: Vector3, rotation: jsb.Ref<Quaternion>, uniformScale: jsb.Ref<number>): void
        /** Creates a transform handle.
         * @param position Position of the handle.
         * @param rotation Orientation of the handle.
         * @param scale Scale value to modify.
         * @param uniformScale Uniform scale value to modify.
         */
        static TransformHandle(position: jsb.Ref<Vector3>, rotation: jsb.Ref<Quaternion>): void
        static DoScaleHandle(scale: Vector3, position: Vector3, rotation: Quaternion, size: number): Vector3
        static DoPositionHandle(position: Vector3, rotation: Quaternion): Vector3
        protected constructor()
        /** Color to use for handles that manipulates the X coordinate of something.
         */
        static readonly xAxisColor: Color
        /** Color to use for handles that manipulates the Y coordinate of something.
         */
        static readonly yAxisColor: Color
        /** Color to use for handles that manipulates the Z coordinate of something.
         */
        static readonly zAxisColor: Color
        /** Color to use for handles that represent the center of something.
         */
        static readonly centerColor: Color
        /** Color to use for the currently active handle.
         */
        static readonly selectedColor: Color
        /** Color to use to highlight an unselected handle currently under the mouse pointer.
         */
        static readonly preselectionColor: Color
        /** Soft color to use for for general things.
         */
        static readonly secondaryColor: Color
        /** Color to use for the Unity UI's padding visualization.
         */
        static readonly UIColliderHandleColor: Color
        /** Retrieves the user preference setting that controls the thickness of tool handle lines. (Read Only)
         */
        static readonly lineThickness: number
        /** Gets or sets the camera that is currently rendering.
         */
        currentCamera: Camera
        /** Are handles lit?
         */
        static lighting: boolean
        /** Sets the color of handles. Color is a persistent state and affects any handles drawn after it is set. Use Handles.DrawingScope to set the color for a block of handles without affecting the color of other handles.
         */
        static color: Color
        /** zTest of the handles.
         */
        static zTest: any
        /** Matrix for all handle operations. This is used by functions in HandleUtility and Handles to transform controls.
         */
        static matrix: Matrix4x4
        /** The inverse of the matrix for all handle operations.
         */
        static readonly inverseMatrix: Matrix4x4
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Material, GameObject, Camera, Vector2, Vector3, Quaternion, Ray, Rect, GUIContent, GUIStyle, Transform } from "UnityEngine";
    /** Helper functions for Scene View style 3D GUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class HandleUtility extends Object {
        /** Map a mouse drag onto a movement along a line in 3D space.
         * @param src The source point of the drag.
         * @param dest The destination point of the drag.
         * @param srcPosition The 3D position the dragged object had at src ray.
         * @param constraintDir Normalized 3D direction of constrained movement.
         * @returns The distance travelled along constraintDir. 
         */
        static CalcLineTranslation(src: Vector2, dest: Vector2, srcPosition: Vector3, constraintDir: Vector3): number
        /** Returns the parameter for the projection of the point on the given line.
         */
        static PointOnLineParameter(point: Vector3, linePoint: Vector3, lineDirection: Vector3): number
        /** Project point onto a line.
         */
        static ProjectPointLine(point: Vector3, lineStart: Vector3, lineEnd: Vector3): Vector3
        /** Calculate distance between a point and a line.
         */
        static DistancePointLine(point: Vector3, lineStart: Vector3, lineEnd: Vector3): number
        /** Returns the distance in pixels from the mouse pointer to a line.
         */
        static DistanceToLine(p1: Vector3, p2: Vector3): number
        static DistanceToCircle(projection: CameraProjectionCache, position: Vector3, radius: number): number
        /** Returns the distance in pixels from the mouse pointer to a camera facing circle.
         */
        static DistanceToCircle(position: Vector3, radius: number): number
        /** Returns the distance in pixels from the mouse pointer to a cone.
         * @param position Position of the cone.
         * @param rotation Rotation of the cone.
         * @param size Size of the cone.
         * @returns Distance from mouse to cone in pixels. 
         */
        static DistanceToCone(position: Vector3, rotation: Quaternion, size: number): number
        /** Returns the distance in pixels from the mouse pointer to a cube.
         * @param position Position of the cube.
         * @param rotation Rotation of the cube.
         * @param size Size of the cube.
         * @returns Distance from mouse to cube in pixels. 
         */
        static DistanceToCube(position: Vector3, rotation: Quaternion, size: number): number
        /** Returns the distance in pixels from the mouse pointer to a rectangle on screen.
         */
        static DistanceToRectangle(position: Vector3, rotation: Quaternion, size: number): number
        /** Distance from a point p in 2d to a line defined by two points a and b.
         */
        static DistancePointToLine(p: Vector2, a: Vector2, b: Vector2): number
        /** Distance from a point p in 2d to a line segment defined by two points a and b.
         */
        static DistancePointToLineSegment(p: Vector2, a: Vector2, b: Vector2): number
        /** Returns the distance in pixels from the mouse pointer to a 3D disc.
         */
        static DistanceToDisc(center: Vector3, normal: Vector3, radius: number): number
        /** Get the point on an disc (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToDisc(center: Vector3, normal: Vector3, radius: number): Vector3
        /** Returns the distance in pixels from the mouse pointer to a 3D section of a disc.
         */
        static DistanceToArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): number
        /** Get the point on an arc (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToArc(center: Vector3, normal: Vector3, from: Vector3, angle: number, radius: number): Vector3
        /** Returns the distance in pixels from the mouse pointer to a polyline.
         */
        static DistanceToPolyLine(...points: Vector3[]): number
        /** Get the point on a polyline (in 3D space) which is closest to the current mouse position.
         */
        static ClosestPointToPolyLine(...vertices: Vector3[]): Vector3
        /** Record a distance measurement from a handle.
         * @param controlId The ID that is recorded as the nearest control if the mouse cursor is near the handle.
         * @param distance The distance from the mouse cursor to the handle.
         */
        static AddControl(controlId: number, distance: number): void
        /** Add the ID for a default control. This will be picked if nothing else is.
         */
        static AddDefaultControl(controlId: number): void
        /** Get world space size of a manipulator handle at given position.
         * @param position The position of the handle in 3d space.
         * @returns A constant screen-size for the handle, based on the distance between from the supplied handle's position to the camera. 
         */
        static GetHandleSize(position: Vector3): number
        /** Convert a world space point to a 2D GUI position.
         * @param world Point in world space.
         */
        static WorldToGUIPoint(world: Vector3): Vector2
        static WorldToGUIPointWithDepth(camera: Camera, world: Vector3): Vector3
        /** Convert a world space point to a 2D GUI position.
         * @param world Point in world space.
         * @returns A Vector3 where the x and y values relate to the 2D GUI position. The z value is the distance in world units from the camera. 
         */
        static WorldToGUIPointWithDepth(world: Vector3): Vector3
        /** Converts a 2D GUI position to screen pixel coordinates.
         */
        static GUIPointToScreenPixelCoordinate(guiPoint: Vector2): Vector2
        /** Convert 2D GUI position to a world space ray.
         */
        static GUIPointToWorldRay(position: Vector2): Ray
        /** Calculate a rectangle to display a 2D GUI element near a projected point in 3D space.
         * @param position The world-space position to use.
         * @param content The content to make room for.
         * @param style The style to use. The style's alignment.
         */
        static WorldPointToSizedRect(position: Vector3, content: GUIContent, style: GUIStyle): Rect
        static PickRectObjects(rect: Rect, selectPrefabRootsOnly: boolean): Array<GameObject>
        /** Pick GameObjects that lie within a specified screen rectangle.
         * @param rect A screen rectangle specified with pixel coordinates.
         */
        static PickRectObjects(rect: Rect): Array<GameObject>
        /** Returns the nearest vertex to a guiPoint within a maximum radius of 50 pixels.
         * @param guiPoint A point in GUI space.
         * @param vertex The nearest vertex position to guiPoint, or a default value if no vertex is within the minimum picking distance.
         * @param objectsToSearch An array of Transform to consider when picking the nearest vertex. If null, all active objects in open scenes are considered.
         * @param objectsToIgnore An array of Transform to exclude from consideration when picking nearest vertex.
         * @returns Returns true if a vertex within 50 pixels of the guiPoint was found, false if no vertex found within the minimum picking radius. 
         */
        static FindNearestVertex(guiPoint: Vector2, objectsToSearch: Array<Transform>, objectsToIgnore: Array<Transform>, vertex: jsb.Out<Vector3>): boolean
        /** Returns the nearest vertex to a guiPoint within a maximum radius of 50 pixels.
         * @param guiPoint A point in GUI space.
         * @param vertex The nearest vertex position to guiPoint, or a default value if no vertex is within the minimum picking distance.
         * @param objectsToSearch An array of Transform to consider when picking the nearest vertex. If null, all active objects in open scenes are considered.
         * @param objectsToIgnore An array of Transform to exclude from consideration when picking nearest vertex.
         * @returns Returns true if a vertex within 50 pixels of the guiPoint was found, false if no vertex found within the minimum picking radius. 
         */
        static FindNearestVertex(guiPoint: Vector2, objectsToSearch: Array<Transform>, vertex: jsb.Out<Vector3>): boolean
        /** Returns the nearest vertex to a guiPoint within a maximum radius of 50 pixels.
         * @param guiPoint A point in GUI space.
         * @param vertex The nearest vertex position to guiPoint, or a default value if no vertex is within the minimum picking distance.
         * @param objectsToSearch An array of Transform to consider when picking the nearest vertex. If null, all active objects in open scenes are considered.
         * @param objectsToIgnore An array of Transform to exclude from consideration when picking nearest vertex.
         * @returns Returns true if a vertex within 50 pixels of the guiPoint was found, false if no vertex found within the minimum picking radius. 
         */
        static FindNearestVertex(guiPoint: Vector2, vertex: jsb.Out<Vector3>): boolean
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean, ignore: Array<GameObject>, filter: Array<GameObject>, materialIndex: jsb.Out<number>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, ignore: Array<GameObject>, selection: Array<GameObject>, materialIndex: jsb.Out<number>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean, ignore: Array<GameObject>, filter: Array<GameObject>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, ignore: Array<GameObject>, materialIndex: jsb.Out<number>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean, ignore: Array<GameObject>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, materialIndex: jsb.Out<number>): GameObject
        /** Pick game object closest to specified position.
         * @param selectPrefabRoot Select Prefab.
         * @param materialIndex Returns index into material array of the Renderer component that is closest to specified position.
         * @param position A position in screen coordinates. The top-left of the window is (0,0), and the bottom-right is (Screen.width, Screen.height).
         * @param ignore An array of GameObjects that will not be considered when selecting the nearest GameObject.
         * @param filter An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @param selection An array of GameObjects to be exclusively considered for selection. If null, all GameObjects in open scenes are eligible for selection.
         * @returns The GameObject that is under the requested position. 
         */
        static PickGameObject(position: Vector2, selectPrefabRoot: boolean): GameObject
        /** Store all camera settings.
         */
        static PushCamera(camera: Camera): void
        /** Retrieve all camera settings.
         */
        static PopCamera(camera: Camera): void
        /** Casts ray against the Scene and reports whether an object lies in its path.
         * @returns A boxed RaycastHit, null if nothing hit it. 
         */
        static RaySnap(ray: Ray): Object
        /** Casts a ray against the loaded scenes and returns the nearest intersected point on a collider.
         * @param guiPosition The GUI position in the SceneView. You can pass Event.current.mousePosition to this parameter in most cases.
         * @param position Returns the nearest intersected point to a ray cast from the mouse position into the scene.
         * @param normal Returns the normal of the nearest intersected point to a ray cast from the mouse position into the scene.
         * @returns Returns true if the raycast intersected something in the scene; otherwise, false. 
         */
        static PlaceObject(guiPosition: Vector2, position: jsb.Out<Vector3>, normal: jsb.Out<Vector3>): boolean
        static Repaint(): void
        /** Calculate distance between a point and a Bezier curve.
         */
        static DistancePointBezier(point: Vector3, startPosition: Vector3, endPosition: Vector3, startTangent: Vector3, endTangent: Vector3): number
        protected constructor()
        /** Get standard acceleration for dragging values (Read Only).
         */
        static readonly acceleration: number
        /** Get nice mouse delta to use for dragging a float value (Read Only).
         */
        static readonly niceMouseDelta: number
        /** Get nice mouse delta to use for zooming (Read Only).
         */
        static readonly niceMouseDeltaZoom: number
        /** The controlID of the nearest Handle to the mouse cursor.
         */
        static nearestControl: number
        static readonly handleMaterial: Material
        static pickGameObjectCustomPasses(op: "add" | "remove", fn: (cam: Camera, layers: number, position: Vector2, ignore: Array<GameObject>, filter: Array<GameObject>, materialIndex: jsb.Out<number>) => GameObject): void
        static placeObjectCustomPasses(op: "add" | "remove", fn: (guiPosition: Vector2, position: jsb.Out<Vector3>, normal: jsb.Out<Vector3>) => boolean): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ISupportsOverlays } from "UnityEditor.Overlays";
    import { Color, Quaternion, Camera, Vector3, Object as Object1, Transform, Bounds } from "UnityEngine";
    import { Object, Array } from "System";
    /** Use this class to manage SceneView settings, change the SceneView camera properties, subscribe to events, call SceneView methods, and render open scenes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneView extends SearchableEditorWindow implements IHasCustomMenu, ISupportsOverlays {
        ResetCameraSettings(): void
        /** Sets a replacement shader for rendering this Scene view.
         * @param shader The replacement shader.
         * @param replaceString The replacement shader tag.
         */
        SetSceneViewShaderReplace(shader: any, replaceString: string): void
        OnEnable(): void
        OnDisable(): void
        OnDestroy(): void
        AddItemsToMenu(menu: GenericMenu): void
        IsCameraDrawModeSupported(mode: SceneView.CameraMode): boolean
        IsCameraDrawModeEnabled(mode: SceneView.CameraMode): boolean
        FixNegativeSize(): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number, ortho: boolean, instant: boolean): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number, ortho: boolean): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion, newSize: number): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3, direction: Quaternion): void
        /** Moves the Scene view to focus on a target.
         * @param point The position in world space to frame.
         * @param direction The direction that the Scene view should view the target point from.
         * @param newSize The amount of camera zoom. Sets size.
         * @param ortho Whether the camera focus is in orthographic mode (true) or perspective mode (false).
         * @param instant Apply the movement immediately (true) or animate the transition (false).
         */
        LookAt(point: Vector3): void
        /** .LookAt without animating the scene movement.
         * @param point The position in world space to frame.
         * @param direction The direction from which the Scene view should view the point.
         * @param newSize The amount of camera zoom. Sets size.
         */
        LookAtDirect(point: Vector3, direction: Quaternion, newSize: number): void
        /** .LookAt without animating the scene movement.
         * @param point The position in world space to frame.
         * @param direction The direction from which the Scene view should view the point.
         * @param newSize The amount of camera zoom. Sets size.
         */
        LookAtDirect(point: Vector3, direction: Quaternion): void
        /** Moves the Scene view to frame a transform.
         * @param t The transform to frame in the Scene view.
         */
        AlignViewToObject(t: Transform): void
        AlignWithView(): void
        /** Transforms all selected object to the scene pivot.
         * @param target A transform to place at the scene pivot.
         */
        MoveToView(target: Transform): void
        MoveToView(): void
        FrameSelected(lockView: boolean, instant: boolean): boolean
        /** Frame the object selection in the Scene view.
         * @param lockView Whether the view should be locked to the selection.
         * @returns Returns true if the current selection fits in the Scene view. Returns false otherwise. 
         */
        FrameSelected(lockView: boolean): boolean
        FrameSelected(): boolean
        /** Frames the given bounds in the Scene view.
         * @param bounds The bounds to frame in the Scene view.
         * @param instant Set to true to immediately frame the camera. Set to false to animate the action.
         * @returns Returns true if the given bounds can be encompassed in the Scene view. Returns false otherwise. 
         */
        Frame(bounds: Bounds, instant: boolean): boolean
        static FrameLastActiveSceneView(): boolean
        static FrameLastActiveSceneViewWithLock(): boolean
        static GetAllSceneCameras(): Array<Camera>
        static RepaintAll(): void
        /** Add a custom camera mode to the Scene view camera mode list.
         * @param name The name for the new mode.
         * @param section The section in which the new mode will be added. This can be an existing or new section.
         * @returns A CameraMode with the provided name and section. 
         */
        static AddCameraMode(name: string, section: string): SceneView.CameraMode
        static ClearUserDefinedCameraModes(): void
        /** Gets the built-in CameraMode that matches the specified DrawCameraMode.
         * @param mode The DrawCameraMode to match.
         * @returns Returns a built-in CameraMode. 
         */
        static GetBuiltinCameraMode(mode: DrawCameraMode): SceneView.CameraMode
        protected constructor()
        /** The SceneView that was most recently in focus.
         */
        static readonly lastActiveSceneView: SceneView
        /** The SceneView that is being drawn.
         */
        static readonly currentDrawingSceneView: SceneView
        /** Gets the Color of selected outline.
         */
        static readonly selectedOutlineColor: Color
        /** Whether this SceneView is using scene filtering.
         */
        readonly isUsingSceneFiltering: boolean
        /** Sets the visibility of all Gizmos in the Scene view.
         */
        drawGizmos: boolean
        /** Whether lighting is enabled or disabled in the Scene view.
         */
        sceneLighting: boolean
        /** Whether the SceneView is in 2D mode.
         */
        in2DMode: boolean
        /** Whether the Scene view camera can be rotated.
         */
        isRotationLocked: boolean
        /** Enables or disables Scene view audio effects.
         */
        audioPlay: boolean
        /** The current DrawCameraMode for the Scene view camera.
         */
        cameraMode: SceneView.CameraMode
        /** Whether the albedo is black for materials with an average specular color above 0.45.
         */
        validateTrueMetals: boolean
        /** Use SceneViewState to set the debug options for the Scene view.
         */
        sceneViewState: SceneView.SceneViewState
        /** Gets or sets whether to enable the grid for an instance of the SceneView.
         */
        showGrid: boolean
        /** Use CameraSettings to set the properties for the SceneView Camera.
         */
        cameraSettings: SceneView.CameraSettings
        /** When the Scene view is in 2D mode, this property contains the last camera rotation.
         */
        lastSceneViewRotation: Quaternion
        /** The distance from camera to pivot.
         */
        readonly cameraDistance: number
        /** The list of all open Scene view windows.
         */
        static readonly sceneViews: any
        /** The Camera that is rendering this SceneView.
         */
        readonly camera: Camera
        /** The central point that the camera orbits within the Scene view.
         */
        pivot: Vector3
        /** The direction of the camera to the pivot of the SceneView.
         */
        rotation: Quaternion
        /** The size of the Scene view measured diagonally.
         */
        size: number
        /** Whether the Scene view camera is set to orthographic mode.
         */
        orthographic: boolean
        onValidateCameraMode(op: "add" | "remove", fn: (arg: SceneView.CameraMode) => boolean): void
        onCameraModeChanged(op: "add" | "remove", fn: (obj: SceneView.CameraMode) => void): void
        gridVisibilityChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        static beforeSceneGui(op: "add" | "remove", fn: (obj: SceneView) => void): void
        static duringSceneGui(op: "add" | "remove", fn: (obj: SceneView) => void): void
        static lastActiveSceneViewChanged(op: "get"): (arg1: SceneView, arg2: SceneView) => void
        static lastActiveSceneViewChanged(op: "add" | "remove" | "set", fn?: (arg1: SceneView, arg2: SceneView) => void): void
        static lastActiveSceneViewChanged(op: "add" | "remove" | "set" | "get", fn?: (arg1: SceneView, arg2: SceneView) => void): (arg1: SceneView, arg2: SceneView) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, Vector2 } from "UnityEngine";
    /** Various utilities for mesh manipulation.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MeshUtility extends Object {
        /** Optimizes the Mesh data to improve rendering performance.
         */
        static Optimize(mesh: any): void
        /** Change the mesh compression setting for a mesh.
         * @param mesh The mesh to set the compression mode for.
         * @param compression The compression mode to set.
         */
        static SetMeshCompression(mesh: any, compression: ModelImporterMeshCompression): void
        /** Returns the mesh compression setting for a Mesh.
         * @param mesh The mesh to get information on.
         */
        static GetMeshCompression(mesh: any): ModelImporterMeshCompression
        /** Will insert per-triangle uv2 in mesh and handle vertex splitting etc.
         */
        static SetPerTriangleUV2(src: any, triUV: Array<Vector2>): void
        /** Gets a snapshot of Mesh data for read-only access in the Unity Editor.
         * @param mesh The input mesh.
         * @param meshes The input meshes.
         * @returns Returns a read-only snapshot of Mesh data. See Mesh.MeshDataArray and Mesh.MeshData. 
         */
        static AcquireReadOnlyMeshData(mesh: any): any
        /** Gets a snapshot of Mesh data for read-only access in the Unity Editor.
         * @param mesh The input mesh.
         * @param meshes The input meshes.
         * @returns Returns a read-only snapshot of Mesh data. See Mesh.MeshDataArray and Mesh.MeshData. 
         */
        static AcquireReadOnlyMeshData(meshes: Array<any>): any
        static AcquireReadOnlyMeshData(meshes: any): any
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { GameObject, Object as Object1, Component, Texture2D, Transform } from "UnityEngine";
    /** Utility class for any Prefab related operations.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PrefabUtility extends Object {
        /** Retrieves the PrefabInstance object for the outermost Prefab instance the provided object is part of.
         * @param instanceComponentOrGameObject An object from the Prefab instance.
         * @returns The Prefab instance handle. 
         */
        static GetPrefabInstanceHandle(instanceComponentOrGameObject: Object1): Object1
        /** Determines whether the object Prefab asset contains any MonoBehaviours with missing SerializeReference types.
         * @param componentOrGameObject An object which is part of a Prefab asset.
         * @returns Returns true if there are missing SerializeReference types directly within a Prefab asset excluding nested Prefab. 
         */
        static HasManagedReferencesWithMissingTypes(assetComponentOrGameObject: Object1): boolean
        /** Extracts all modifications that are applied to the Prefab instance compared to the parent Prefab.
         */
        static GetPropertyModifications(targetPrefab: Object1): Array<PropertyModification>
        /** Assigns all modifications that are applied to the Prefab instance compared to the parent Prefab.
         */
        static SetPropertyModifications(targetPrefab: Object1, modifications: Array<PropertyModification>): void
        /** Returns true if the given Prefab instance has any overrides.
         * @param instanceRoot The root GameObject of the Prefab instance to check.
         * @param includeDefaultOverrides Set to true to consider default overrides as overrides too.
         * @returns Returns true if there are any overrides. 
         */
        static HasPrefabInstanceAnyOverrides(instanceRoot: GameObject, includeDefaultOverrides: boolean): boolean
        /** Causes modifications made to the Prefab instance to be recorded.
         * @param targetObject Object to process.
         */
        static RecordPrefabInstancePropertyModifications(targetObject: Object1): void
        /** This function will unpack the given Prefab instance using the behaviour specified by unpackMode.
         * @param instanceRoot Root GameObject of the Prefab instance.
         * @param unpackMode The unpack mode to use.
         * @returns Array of GameObjects representing roots of unpacked Prefab instances. 
         */
        static UnpackPrefabInstanceAndReturnNewOutermostRoots(instanceRoot: GameObject, unpackMode: PrefabUnpackMode): Array<GameObject>
        /** Loads a Prefab Asset at a given path into a given preview Scene and returns the root GameObject of the Prefab.
         * @param scene The Scene to load the contents into.
         * @param prefabPath The path of the Prefab Asset to load the contents of.
         */
        static LoadPrefabContentsIntoPreviewScene(prefabPath: string, scene: any): void
        /** Is this component added to a Prefab instance as an override?
         * @param component The component to check.
         * @returns True if the component is an added component. 
         */
        static IsAddedComponentOverride(component: Object1): boolean
        /** Returns true if the given object is part of any kind of Prefab.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object s part of a Prefab. 
         */
        static IsPartOfAnyPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab Asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True is the object is part of a Prefab Asset. 
         */
        static IsPartOfPrefabAsset(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab instance. 
         */
        static IsPartOfPrefabInstance(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance and not part of an asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab instance that's not inside a Prefab Asset. 
         */
        static IsPartOfNonAssetPrefabInstance(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a regular Prefab instance or Prefab Asset.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a regular Prefab instance or Prefab Asset. 
         */
        static IsPartOfRegularPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Model Prefab Asset or Model Prefab instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Model Prefab. 
         */
        static IsPartOfModelPrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab Variant Asset or Prefab Variant instance.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Prefab Variant. 
         */
        static IsPartOfVariantPrefab(componentOrGameObject: Object1): boolean
        /** Is this object part of a Prefab that cannot be edited?
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab that cannot be edited. 
         */
        static IsPartOfImmutablePrefab(componentOrGameObject: Object1): boolean
        /** Returns true if the given object is part of a Prefab instance but the source asset is missing.
         * @param instanceComponentOrGameObject The object to check. Must be a component or GameObject.
         * @returns True if the given object is part of a Prefab instance but the source asset is missing. 
         */
        static IsPrefabAssetMissing(instanceComponentOrGameObject: Object1): boolean
        /** Retrieves the GameObject that is the root of the outermost Prefab instance the object is part of.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns The outermost Prefab instance root. 
         */
        static GetOutermostPrefabInstanceRoot(componentOrGameObject: Object1): GameObject
        /** Retrieves the GameObject that is the root of the nearest Prefab instance the object is part of.
         * @param componentOrGameObject The object to check. Must be a component or GameObject.
         * @returns The nearest Prefab instance root. 
         */
        static GetNearestPrefabInstanceRoot(componentOrGameObject: Object1): GameObject
        /** Returns true if the given modification is considered a PrefabUtility.IsDefaultOverride|default override.
         * @param modification The modification for the property in question.
         * @returns True if the property is a default override. 
         */
        static IsDefaultOverride(modification: PropertyModification): boolean
        /** Retrieves the root GameObjects for all instances of the Prefab asset with root prefabRoot found in all currently loaded scenes. If prefabRoot is not a valid Prefab asset root GameObject, an ArgumentException is thrown.
         * @param prefabRoot The root GameObject of a Prefab asset.
         * @param scene The scene to search for Prefab instances. The scene you specify must be valid and loaded.
         * @returns The root GameObjects for all instances of the Prefab asset with root prefabRoot. 
         */
        static FindAllInstancesOfPrefab(prefabRoot: GameObject, scene: any): Array<GameObject>
        /** Retrieves the root GameObjects for all instances of the Prefab asset with root prefabRoot found in all currently loaded scenes. If prefabRoot is not a valid Prefab asset root GameObject, an ArgumentException is thrown.
         * @param prefabRoot The root GameObject of a Prefab asset.
         * @param scene The scene to search for Prefab instances. The scene you specify must be valid and loaded.
         * @returns The root GameObjects for all instances of the Prefab asset with root prefabRoot. 
         */
        static FindAllInstancesOfPrefab(prefabRoot: GameObject): Array<GameObject>
        /** Forces a Prefab instance to merge with changes from the Prefab Asset.
         * @param instanceRoot Root of Prefab instance to update.
         */
        static MergePrefabInstance(instanceRoot: GameObject): void
        /** Reverts all overrides on a Prefab instance.
         * @param instanceRoot The root of the Prefab instance.
         * @param action The interaction mode for this action.
         */
        static RevertPrefabInstance(instanceRoot: GameObject, action: InteractionMode): void
        /** Applies all overrides on a Prefab instance to its Prefab Asset.
         * @param instanceRoot The root of the given Prefab instance.
         * @param action The interaction mode for this action.
         */
        static ApplyPrefabInstance(instanceRoot: GameObject, action: InteractionMode): void
        /** Applies a single overridden property on a Prefab instance to the Prefab Asset at the given asset path.
         * @param instanceProperty The SerializedProperty representing the property to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyPropertyOverride(instanceProperty: SerializedProperty, assetPath: string, action: InteractionMode): void
        /** Revert a single property override on a Prefab instance.
         * @param action The interaction mode for this action.
         * @param instanceProperty The SerializedProperty representing the property to revert.
         */
        static RevertPropertyOverride(instanceProperty: SerializedProperty, action: InteractionMode): void
        /** Applies all overridden properties on a Prefab instance component or GameObject to the Prefab Asset at the given asset path.
         * @param instanceComponentOrGameObject The object on the Prefab instance to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyObjectOverride(instanceComponentOrGameObject: Object1, assetPath: string, action: InteractionMode): void
        /** Reverts all overridden properties on a Prefab instance component or GameObject.
         * @param action The interaction mode for this action.
         * @param instanceComponentOrGameObject The object on the Prefab instance to revert.
         */
        static RevertObjectOverride(instanceComponentOrGameObject: Object1, action: InteractionMode): void
        /** Applies the added component to the Prefab Asset at the given asset path.
         * @param action The interaction mode for this action.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param component The added component on the Prefab instance to apply.
         */
        static ApplyAddedComponent(component: Component, assetPath: string, action: InteractionMode): void
        /** Removes this added component on a Prefab instance.
         * @param component The added component on the Prefab instance to revert.
         * @param action The interaction mode for this action.
         */
        static RevertAddedComponent(component: Component, action: InteractionMode): void
        /** Removes the component from the Prefab Asset which has the component on it.
         * @param instanceGameObject The GameObject on the Prefab instance which the component has been removed from.
         * @param assetComponent The component on the Prefab Asset corresponding to the removed component on the instance.
         * @param action The interaction mode for this action.
         */
        static ApplyRemovedComponent(instanceGameObject: GameObject, assetComponent: Component, action: InteractionMode): void
        /** Adds this removed component back on the Prefab instance.
         * @param assetComponent The removed component on the Prefab instance to revert.
         * @param action The interaction mode for this action.
         * @param instanceGameObject The GameObject on the Prefab instance which the component has been removed from.
         */
        static RevertRemovedComponent(instanceGameObject: GameObject, assetComponent: Component, action: InteractionMode): void
        /** Applies the added GameObject to the Prefab Asset at the given asset path.
         * @param gameObject The added GameObject on the Prefab instance to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyAddedGameObject(gameObject: GameObject, assetPath: string, action: InteractionMode): void
        /** Applies the added GameObjects to the Prefab Asset at the given asset path.
         * @param gameObjects The added GameObjects on the Prefab instance to apply.
         * @param assetPath The path of the Prefab Asset to apply to.
         * @param action The interaction mode for this action.
         */
        static ApplyAddedGameObjects(gameObjects: Array<GameObject>, assetPath: string, action: InteractionMode): void
        /** Removes this added GameObject from a Prefab instance.
         * @param action The interaction mode for this action.
         * @param gameObject The added GameObject on the Prefab instance to revert.
         */
        static RevertAddedGameObject(gameObject: GameObject, action: InteractionMode): void
        /** Retrieves a list of objects with information about object overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @param includeDefaultOverrides If true, components will also be included even if they only contain overrides that are PrefabUtility.IsDefaultOverride|default overrides. False by default.
         * @returns List of objects with information about object overrides. 
         */
        static GetObjectOverrides(prefabInstance: GameObject, includeDefaultOverrides: boolean): any
        /** Retrieves a list of PrefabUtility.AddedComponent objects which contain information about added component overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about added components. 
         */
        static GetAddedComponents(prefabInstance: GameObject): any
        /** Returns a list of objects with information about removed component overrides on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about removed components. 
         */
        static GetRemovedComponents(prefabInstance: GameObject): any
        /** Retrieves a list of PrefabUtility.AddedGameObject objects which contain information about added GameObjects on the Prefab instance.
         * @param prefabInstance The Prefab instance to get information about.
         * @returns List of objects with information about added GameObjects. 
         */
        static GetAddedGameObjects(prefabInstance: GameObject): any
        /** Is the GameObject the root of any Prefab instance?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is the root GameObject of any Prefab instance. 
         */
        static IsAnyPrefabInstanceRoot(gameObject: GameObject): boolean
        /** Is the GameObject the root of a Prefab instance, excluding nested Prefabs?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is an outermost Prefab instance root. 
         */
        static IsOutermostPrefabInstanceRoot(gameObject: GameObject): boolean
        /** Retrieves the asset path of the nearest Prefab instance root the specified object is part of.
         * @param instanceComponentOrGameObject An object in the Prefab instance to get the asset path of.
         * @returns The asset path. 
         */
        static GetPrefabAssetPathOfNearestInstanceRoot(instanceComponentOrGameObject: Object1): string
        /** Retrieves the icon for the given GameObject.
         * @param gameObject The GameObject to get an icon for.
         * @returns The icon for the GameObject. 
         */
        static GetIconForGameObject(gameObject: GameObject): Texture2D
        /** Use this function to save the version of an existing Prefab Asset that exists in memory back to disk.
         * @param asset Any GameObject that is part of the Prefab Asset to save.
         * @param savedSuccessfully The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset. 
         */
        static SavePrefabAsset(asset: GameObject, savedSuccessfully: jsb.Out<boolean>): GameObject
        /** Use this function to save the version of an existing Prefab Asset that exists in memory back to disk.
         * @param asset Any GameObject that is part of the Prefab Asset to save.
         * @param savedSuccessfully The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset. 
         */
        static SavePrefabAsset(asset: GameObject): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any childen in the Scene without modifying the input objects.
         * @param instanceRoot The GameObject to save as a Prefab Asset.
         * @param assetPath The path to save the Prefab at.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAsset(instanceRoot: GameObject, assetPath: string, success: jsb.Out<boolean>): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any childen in the Scene without modifying the input objects.
         * @param instanceRoot The GameObject to save as a Prefab Asset.
         * @param assetPath The path to save the Prefab at.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAsset(instanceRoot: GameObject, assetPath: string): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any children in the Scene and at the same time make the given GameObject into an instance of the new Prefab.
         * @param instanceRoot The GameObject to save as a Prefab and make into a Prefab instance.
         * @param assetPath The path to save the Prefab at.
         * @param action The interaction mode to use for this action.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAssetAndConnect(instanceRoot: GameObject, assetPath: string, action: InteractionMode, success: jsb.Out<boolean>): GameObject
        /** Use this function to create a Prefab Asset at the given path from the given GameObject, including any children in the Scene and at the same time make the given GameObject into an instance of the new Prefab.
         * @param instanceRoot The GameObject to save as a Prefab and make into a Prefab instance.
         * @param assetPath The path to save the Prefab at.
         * @param action The interaction mode to use for this action.
         * @param success The result of the save action, either successful or unsuccessful. Use this together with the console log to get more insight into the save process.
         * @returns The root GameObject of the saved Prefab Asset, if available. 
         */
        static SaveAsPrefabAssetAndConnect(instanceRoot: GameObject, assetPath: string, action: InteractionMode): GameObject
        /** Instantiates the given Prefab in a given Scene.
         * @param target Prefab Asset to instantiate.
         * @param destinationScene Scene to instantiate the Prefab in.
         * @returns The GameObject at the root of the Prefab. 
         */
        static InstantiatePrefab(assetComponentOrGameObject: Object1, destinationScene: any): Object1
        static InstantiatePrefab(assetComponentOrGameObject: Object1, parent: Transform): Object1
        /** Instantiates the given Prefab in a given Scene.
         * @param target Prefab Asset to instantiate.
         * @param destinationScene Scene to instantiate the Prefab in.
         * @returns The GameObject at the root of the Prefab. 
         */
        static InstantiatePrefab(assetComponentOrGameObject: Object1): Object1
        /** Is this GameObject added as a child to a Prefab instance as an override?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is an added GameObject. 
         */
        static IsAddedGameObjectOverride(gameObject: GameObject): boolean
        /** Unpacks a given Prefab instance so that it is replaced with the contents of the Prefab Asset while retaining all override values.
         * @param instanceRoot The root of the Prefab instance to unpack.
         * @param unpackMode Whether to unpack the outermost root or unpack completely.
         * @param action The interaction mode to use for this action.
         */
        static UnpackPrefabInstance(instanceRoot: GameObject, unpackMode: PrefabUnpackMode, action: InteractionMode): void
        /** Unpacks all instances of a given Prefab Asset root GameObject in all open scenes so that all instances are replaced with the contents of the Prefab Asset while retaining all override values.
         * @param prefabRoot The root GameObject of a Prefab Asset used to find all Prefab instances in open scenes that should be unpacked.
         * @param unpackMode Whether to unpack the outermost root or unpack completely.
         * @param action The interaction mode to use for this action.
         */
        static UnpackAllInstancesOfPrefab(prefabRoot: GameObject, unpackMode: PrefabUnpackMode, action: InteractionMode): void
        /** Is this object part of a Prefab that cannot be applied to?
         * @param gameObjectOrComponent The object to check. Must be a component or GameObject.
         * @returns True if the object is part of a Prefab that cannot be applied to. 
         */
        static IsPartOfPrefabThatCanBeAppliedTo(gameObjectOrComponent: Object1): boolean
        /** Determines whether a Prefab instance is properly connected to its asset.
         * @param componentOrGameObject An object that is part of a Prefab instance.
         * @returns The status of the Prefab instance. 
         */
        static GetPrefabInstanceStatus(componentOrGameObject: Object1): PrefabInstanceStatus
        /** Retrieves an enum value indicating the type of Prefab Asset, such as Regular Prefab, Model Prefab and Prefab Variant.
         * @param componentOrGameObject An object that is part of a Prefab Asset or Prefab instance.
         * @returns The type of Prefab. 
         */
        static GetPrefabAssetType(componentOrGameObject: Object1): PrefabAssetType
        /** Loads a Prefab Asset at a given path into an isolated Scene and returns the root GameObject of the Prefab.
         * @param assetPath The path of the Prefab Asset to load the contents of.
         * @returns The root of the loaded contents. 
         */
        static LoadPrefabContents(assetPath: string): GameObject
        /** Releases the content from a Prefab previously loaded with LoadPrefabContents from memory.
         * @param contentsRoot The root of the loaded Prefab contents.
         */
        static UnloadPrefabContents(contentsRoot: GameObject): void
        protected constructor()
        static prefabInstanceUpdated(op: "get"): (instance: GameObject) => void
        static prefabInstanceUpdated(op: "add" | "remove" | "set", fn?: (instance: GameObject) => void): void
        static prefabInstanceUpdated(op: "add" | "remove" | "set" | "get", fn?: (instance: GameObject) => void): (instance: GameObject) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Lets you do move, copy, delete operations over files or directories.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class FileUtil extends Object {
        /** Deletes a file or a directory given a path.
         */
        static DeleteFileOrDirectory(path: string): boolean
        /** Copies a file or a directory.
         */
        static CopyFileOrDirectory(source: string, dest: string): void
        /** Copies the file or directory.
         */
        static CopyFileOrDirectoryFollowSymlinks(source: string, dest: string): void
        /** Moves a file or a directory from a given path to another path.
         */
        static MoveFileOrDirectory(source: string, dest: string): void
        static GetUniqueTempPathInProject(): string
        static GetProjectRelativePath(path: string): string
        /** Converts a physical path to a logical path.
         * @param path Physical path.
         * @returns Logical path. 
         */
        static GetLogicalPath(path: string): string
        /** Converts a logical path to a physical path.
         * @param path Logical path.
         * @returns Physical path. 
         */
        static GetPhysicalPath(path: string): string
        /** Replaces a file.
         */
        static ReplaceFile(src: string, dst: string): void
        /** Replaces a directory.
         */
        static ReplaceDirectory(src: string, dst: string): void
        protected constructor()
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Array } from "System";
    /** The BuildReport API gives you information about the Unity build process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildReport extends Object {
        protected constructor()
        /** An array of all the files output by the build process.
         */
        readonly files: Array<BuildFile>
        /** An array of all the BuildSteps that took place during the build process.
         */
        readonly steps: Array<BuildStep>
        /** A BuildSummary containing overall statistics and data about the build process.
         */
        readonly summary: BuildSummary
        /** The StrippingInfo object for the build.
         */
        readonly strippingInfo: StrippingInfo
        /** An array of all the PackedAssets generated by the build process.
         */
        readonly packedAssets: Array<PackedAssets>
        /** An optional array of ScenesUsingAssets generated by the build process if BuildOptions.DetailedBuildReport was used during the build.
         */
        readonly scenesUsingAssets: Array<ScenesUsingAssets>
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** Manifest for all the AssetBundles in the build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetBundleManifest extends Object {
        GetAllAssetBundles(): Array<string>
        GetAllAssetBundlesWithVariant(): Array<string>
        /** Get the hash for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         * @returns The 128-bit hash for the asset bundle. 
         */
        GetAssetBundleHash(assetBundleName: string): Hash128
        /** Get the direct dependent AssetBundles for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         * @returns Array of asset bundle names this asset bundle depends on. 
         */
        GetDirectDependencies(assetBundleName: string): Array<string>
        /** Get all the dependent AssetBundles for the given AssetBundle.
         * @param assetBundleName Name of the asset bundle.
         */
        GetAllDependencies(assetBundleName: string): Array<string>
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    import { AssetBundleManifest, Hash128 } from "UnityEngine";
    /** Lets you programmatically build players or AssetBundles which can be loaded from the web.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPipeline extends Object {
        static GetBuildTargetGroup(platform: BuildTarget): BuildTargetGroup
        /** Given a BuildTarget will return the well known string representation for the build target platform.
         * @param targetPlatform An instance of the BuildTarget enum.
         * @returns Target platform name represented by the passed in BuildTarget. 
         */
        static GetBuildTargetName(targetPlatform: BuildTarget): string
        /** Checks if Unity can append the build.
         * @param target The BuildTarget to build.
         * @param location The path where Unity builds the application.
         * @returns Returns a UnityEditor.CanAppendBuild enum that indicates whether Unity can append the build. 
         */
        static BuildCanBeAppended(target: BuildTarget, location: string): CanAppendBuild
        /** Builds a player. These overloads are still supported, but will be replaced. Please use BuildPlayer (BuildPlayerOptions buildPlayerOptions)  instead.
         * @param scenes The Scenes to include in the build. If empty, the build only includes the currently open Scene. Paths are relative to the project folder (AssetsMyLevelsMyScene.unity).
         * @param locationPathName The path where the application will be built.
         * @param target The BuildTarget to build.
         * @param options Additional BuildOptions, like whether to run the built player.
         * @returns An error message if an error occurred. 
         */
        static BuildPlayer(levels: Array<EditorBuildSettingsScene>, locationPathName: string, target: BuildTarget, options: BuildOptions): BuildReport
        /** Builds a player. These overloads are still supported, but will be replaced. Please use BuildPlayer (BuildPlayerOptions buildPlayerOptions)  instead.
         * @param scenes The Scenes to include in the build. If empty, the build only includes the currently open Scene. Paths are relative to the project folder (AssetsMyLevelsMyScene.unity).
         * @param locationPathName The path where the application will be built.
         * @param target The BuildTarget to build.
         * @param options Additional BuildOptions, like whether to run the built player.
         * @returns An error message if an error occurred. 
         */
        static BuildPlayer(levels: Array<string>, locationPathName: string, target: BuildTarget, options: BuildOptions): BuildReport
        /** Builds a player.
         * @param buildPlayerOptions Provide various options to control the behavior of BuildPipeline.BuildPlayer.
         * @returns A BuildReport giving build process information. 
         */
        static BuildPlayer(buildPlayerOptions: BuildPlayerOptions): BuildReport
        /** Writes out a "boot.config" file that contains configuration information for the very early stages of engine startup.
         * @param outputFile The location to write the file to.
         * @param target The platform to target for this build.
         * @param options Options for this build.
         */
        static WriteBootConfig(outputFile: string, target: BuildTarget, options: BuildOptions): void
        /** Build AssetBundles from a building map.
         * @param outputPath Output path for the AssetBundles.
         * @param builds AssetBundle building map.
         * @param assetBundleOptions AssetBundle building options.
         * @param targetPlatform Target build platform.
         * @returns The manifest listing all AssetBundles included in this build. 
         */
        static BuildAssetBundles(outputPath: string, builds: Array<AssetBundleBuild>, assetBundleOptions: BuildAssetBundleOptions, targetPlatform: BuildTarget): AssetBundleManifest
        /** Build all AssetBundles specified in the editor.
         * @param outputPath Output path for the AssetBundles.
         * @param assetBundleOptions AssetBundle building options.
         * @param targetPlatform Chosen target build platform.
         * @returns The manifest listing all AssetBundles included in this build. 
         */
        static BuildAssetBundles(outputPath: string, assetBundleOptions: BuildAssetBundleOptions, targetPlatform: BuildTarget): AssetBundleManifest
        /** Extract the crc checksum for the given AssetBundle.
         */
        static GetCRCForAssetBundle(targetPath: string, crc: jsb.Out<number>): boolean
        /** Extract the hash for the given AssetBundle.
         */
        static GetHashForAssetBundle(targetPath: string, hash: jsb.Out<Hash128>): boolean
        /** Returns true if the specified build target is currently available in the Editor.
         * @param buildTargetGroup build target group
         * @param target build target
         */
        static IsBuildTargetSupported(buildTargetGroup: BuildTargetGroup, target: BuildTarget): boolean
        static GetPlaybackEngineDirectory(buildTargetGroup: BuildTargetGroup, target: BuildTarget, options: BuildOptions, assertUnsupportedPlatforms: boolean): string
        static GetPlaybackEngineDirectory(target: BuildTarget, options: BuildOptions, assertUnsupportedPlatforms: boolean): string
        /** Returns the path of a player directory. For ex., Editor\Data\PlaybackEngines\AndroidPlayer.

In some cases the player directory path can be affected by BuildOptions.Development.
         * @param target Build target.
         * @param options Build options.
         * @param buildTargetGroup Build target group.
         */
        static GetPlaybackEngineDirectory(buildTargetGroup: BuildTargetGroup, target: BuildTarget, options: BuildOptions): string
        /** Returns the path of a player directory. For ex., Editor\Data\PlaybackEngines\AndroidPlayer.

In some cases the player directory path can be affected by BuildOptions.Development.
         * @param target Build target.
         * @param options Build options.
         * @param buildTargetGroup Build target group.
         */
        static GetPlaybackEngineDirectory(target: BuildTarget, options: BuildOptions): string
        /** Returns the mode currently used by players to initiate a connect to the host.
         */
        static GetPlayerConnectionInitiateMode(targetPlatform: BuildTarget, buildOptions: BuildOptions): PlayerConnectionInitiateMode
        protected constructor()
        /** Is a player currently being built?
         */
        static readonly isBuildingPlayer: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, Hash128, Texture } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    /** An Interface for accessing assets and performing operations on assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetDatabase extends Object {
        static CanOpenForEdit(assetOrMetaFilePaths: Array<string>, outNotEditablePaths: any, statusQueryOptions: StatusQueryOptions): void
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetObject: Object1, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetObject: Object1, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetOrMetaFilePath: string, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetObject: Object1, message: jsb.Out<string>): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetObject: Object1): boolean
        /** Query whether an Asset file can be opened for editing in version control and is not exclusively locked by another user or otherwise unavailable.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being available for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered available for edit by the selected version control system. 
         */
        static CanOpenForEdit(assetOrMetaFilePath: string): boolean
        static IsOpenForEdit(assetOrMetaFilePaths: Array<string>, outNotEditablePaths: any, statusQueryOptions: StatusQueryOptions): void
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, statusOptions: StatusQueryOptions): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1, message: jsb.Out<string>): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string, message: jsb.Out<string>): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetObject: Object1): boolean
        /** Query whether an Asset file is open for editing in version control.
         * @param assetObject Object representing the asset whose status you wish to query.
         * @param assetOrMetaFilePath Path to the asset file or its .meta file on disk, relative to project folder.
         * @param message Returns a reason for the asset not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset is considered open for edit by the selected version control system. 
         */
        static IsOpenForEdit(assetOrMetaFilePath: string): boolean
        static MakeEditable(paths: Array<string>, prompt: string, outNotEditablePaths: any): boolean
        /** Makes a file open for editing in version control.
         * @param path Specifies the path to a file relative to the project root.
         * @returns true if Unity successfully made the file editable in the version control system. Otherwise, returns false. 
         */
        static MakeEditable(path: string): boolean
        /** Search the asset database using the search filter string.
         * @param filter The filter string can contain search data.  See below for details about this string.
         * @param searchInFolders The folders where the search will start.
         * @returns Array of matching asset. Note that GUIDs will be returned. If no matching assets were found, returns empty array. 
         */
        static FindAssets(filter: string, searchInFolders: Array<string>): Array<string>
        /** Search the asset database using the search filter string.
         * @param filter The filter string can contain search data.  See below for details about this string.
         * @param searchInFolders The folders where the search will start.
         * @returns Array of matching asset. Note that GUIDs will be returned. If no matching assets were found, returns empty array. 
         */
        static FindAssets(filter: string): Array<string>
        /** Is object an asset?
         */
        static Contains(obj: Object1): boolean
        /** Is object an asset?
         */
        static Contains(instanceID: number): boolean
        /** Creates a new folder, in the specified parent folder.

The parent folder string must start with the "Assets" folder, and all folders within the parent folder string must already exist. For example, when specifying "AssetsParentFolder1Parentfolder2/", the new folder will be created in "ParentFolder2" only if ParentFolder1 and ParentFolder2 already exist.
         * @param parentFolder The path to the parent folder. Must start with "Assets/".
         * @param newFolderName The name of the new folder.
         * @returns The GUID of the newly created folder, if the folder was created successfully. Otherwise returns an empty string. 
         */
        static CreateFolder(parentFolder: string, newFolderName: string): string
        /** Is asset a main asset in the project window?
         */
        static IsMainAsset(obj: Object1): boolean
        /** Is asset a main asset in the project window?
         */
        static IsMainAsset(instanceID: number): boolean
        /** Does the asset form part of another asset?
         * @param obj The asset Object to query.
         * @param instanceID Instance ID of the asset Object to query.
         */
        static IsSubAsset(obj: Object1): boolean
        /** Does the asset form part of another asset?
         * @param obj The asset Object to query.
         * @param instanceID Instance ID of the asset Object to query.
         */
        static IsSubAsset(instanceID: number): boolean
        /** Determines whether the Asset is a foreign Asset.
         */
        static IsForeignAsset(obj: Object1): boolean
        /** Determines whether the Asset is a foreign Asset.
         */
        static IsForeignAsset(instanceID: number): boolean
        /** Determines whether the Asset is a native Asset.
         */
        static IsNativeAsset(obj: Object1): boolean
        /** Determines whether the Asset is a native Asset.
         */
        static IsNativeAsset(instanceID: number): boolean
        static GetCurrentCacheServerIp(): string
        /** Creates a new unique path for an asset.
         */
        static GenerateUniqueAssetPath(path: string): string
        static StartAssetEditing(): void
        static StopAssetEditing(): void
        static ReleaseCachedFileHandles(): void
        /** Checks if an asset file can be moved from one folder to another. (Without actually moving the file).
         * @param oldPath The path where the asset currently resides.
         * @param newPath The path which the asset should be moved to.
         * @returns An empty string if the asset can be moved, otherwise an error message. 
         */
        static ValidateMoveAsset(oldPath: string, newPath: string): string
        /** Move an asset file (or folder) from one folder to another.
         * @param oldPath The path where the asset currently resides.
         * @param newPath The path which the asset should be moved to.
         * @returns An empty string if the asset has been successfully moved, otherwise an error message. 
         */
        static MoveAsset(oldPath: string, newPath: string): string
        /** Creates an external Asset from an object (such as a Material) by extracting it from within an imported asset (such as an FBX file).
         * @param asset The sub-asset to extract.
         * @param newPath The file path of the new Asset.
         * @returns An empty string if Unity has successfully extracted the Asset, or an error message if not. 
         */
        static ExtractAsset(asset: Object1, newPath: string): string
        /** Rename an asset file.
         * @param pathName The path where the asset currently resides.
         * @param newName The new name which should be given to the asset.
         * @returns An empty string, if the asset has been successfully renamed, otherwise an error message. 
         */
        static RenameAsset(pathName: string, newName: string): string
        /** Moves the specified asset  or folder to the OS trash.
         * @param path Project relative path of the asset or folder to be deleted.
         * @returns Returns true if the asset has been successfully removed, false if it doesn't exist or couldn't be removed. 
         */
        static MoveAssetToTrash(path: string): boolean
        static MoveAssetsToTrash(paths: Array<string>, outFailedPaths: any): boolean
        /** Deletes the specified asset or folder.
         * @param path Project relative path of the asset or folder to be deleted.
         * @returns Returns true if the asset has been successfully removed, false if it doesn't exist or couldn't be removed. 
         */
        static DeleteAsset(path: string): boolean
        static DeleteAssets(paths: Array<string>, outFailedPaths: any): boolean
        /** Import asset at path.
         */
        static ImportAsset(path: string, options: ImportAssetOptions): void
        /** Import asset at path.
         */
        static ImportAsset(path: string): void
        /** Duplicates the asset at path and stores it at newPath.
         * @param path Filesystem path of the source asset.
         * @param newPath Filesystem path of the new asset to create.
         * @returns Returns true if the copy operation is successful or false if part of the process fails. 
         */
        static CopyAsset(path: string, newPath: string): boolean
        /** Writes the import settings to disk.
         */
        static WriteImportSettingsIfDirty(path: string): boolean
        /** Given a path to a directory in the Assets folder, relative to the project folder, this method will return an array of all its subdirectories.
         */
        static GetSubFolders(path: string): Array<string>
        /** Given a path to a folder, returns true if it exists, false otherwise.
         * @param path The path to the folder.
         * @returns Returns true if the folder exists. 
         */
        static IsValidFolder(path: string): boolean
        /** Creates a new native Unity asset.
         * @param asset Object to use in creating the asset.
         * @param path Filesystem path for the new asset.
         */
        static CreateAsset(asset: Object1, path: string): void
        /** Adds objectToAdd to an existing asset at path.
         * @param objectToAdd Object to add to the existing asset.
         * @param path Filesystem path to the asset.
         */
        static AddObjectToAsset(objectToAdd: Object1, path: string): void
        /** Adds objectToAdd to an existing asset identified by assetObject.
         */
        static AddObjectToAsset(objectToAdd: Object1, assetObject: Object1): void
        /** Specifies which object in the asset file should become the main object after the next import.
         * @param mainObject The object to become the main object.
         * @param assetPath Path to the asset file.
         */
        static SetMainObject(mainObject: Object1, assetPath: string): void
        /** Returns the path name relative to the project folder where the asset is stored.
         * @param instanceID The instance ID of the asset.
         * @param assetObject A reference to the asset.
         * @returns The asset path name, or null, or an empty string if the asset does not exist. 
         */
        static GetAssetPath(assetObject: Object1): string
        /** Returns the path name relative to the project folder where the asset is stored.
         * @param instanceID The instance ID of the asset.
         * @param assetObject A reference to the asset.
         * @returns The asset path name, or null, or an empty string if the asset does not exist. 
         */
        static GetAssetPath(instanceID: number): string
        /** Returns the path name relative to the project folder where the asset is stored.
         */
        static GetAssetOrScenePath(assetObject: Object1): string
        /** Gets the path to the text .meta file associated with an asset.
         * @param path The path to the asset.
         * @returns The path to the .meta text file or an empty string if the file does not exist. 
         */
        static GetTextMetaFilePathFromAssetPath(path: string): string
        /** Gets the path to the asset file associated with a text .meta file.
         */
        static GetAssetPathFromTextMetaFilePath(path: string): string
        /** Returns the first asset object of type type at given path assetPath.
         * @param assetPath Path of the asset to load.
         * @param type Data type of the asset.
         * @returns The asset matching the parameters. 
         */
        static LoadAssetAtPath(assetPath: string, type: any): Object1
        /** Returns the main asset object at assetPath.

The "main" Asset is the Asset at the root of a hierarchy (such as a Maya file which may contain multiples meshes and GameObjects).
         * @param assetPath Filesystem path of the asset to load.
         */
        static LoadMainAssetAtPath(assetPath: string): Object1
        /** Returns the type of the main asset object at assetPath.
         * @param assetPath Filesystem path of the asset to load.
         */
        static GetMainAssetTypeAtPath(assetPath: string): any
        /** Gets an object's type from an Asset path and a local file identifier.
         * @param assetPath The Asset's path.
         * @param localIdentifierInFile The object's local file identifier.
         * @returns The object's type. 
         */
        static GetTypeFromPathAndFileID(assetPath: string, localIdentifierInFile: number): any
        /** Returns true if the main asset object at assetPath is loaded in memory.
         * @param assetPath Filesystem path of the asset to load.
         */
        static IsMainAssetAtPathLoaded(assetPath: string): boolean
        /** Returns all sub Assets at assetPath.
         */
        static LoadAllAssetRepresentationsAtPath(assetPath: string): Array<Object1>
        /** Returns an array of all Assets at assetPath.
         * @param assetPath Filesystem path to the asset.
         */
        static LoadAllAssetsAtPath(assetPath: string): Array<Object1>
        static GetAllAssetPaths(): Array<string>
        /** Import any changed assets.
         */
        static Refresh(options: ImportAssetOptions): void
        /** Import any changed assets.
         */
        static Refresh(): void
        /** Checks if Unity can open an asset in the Editor.
         * @param instanceID The instance ID of the asset.
         * @returns Returns true if Unity can successfully open the asset in the Editor, otherwise returns false. 
         */
        static CanOpenAssetInEditor(instanceID: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number, lineNumber: number, columnNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1, lineNumber: number, columnNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number, lineNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1, lineNumber: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(instanceID: number): boolean
        /** Opens the asset with associated application.
         */
        static OpenAsset(target: Object1): boolean
        /** Opens the asset(s) with associated application(s).
         */
        static OpenAsset(objects: Array<Object1>): boolean
        /** Gets the corresponding asset path for the supplied GUID, or an empty string if the GUID can't be found.
         * @param guid The GUID of an asset.
         * @returns Path of the asset relative to the project folder. 
         */
        static GUIDToAssetPath(guid: string): string
        /** Gets the corresponding asset path for the supplied GUID, or an empty string if the GUID can't be found.
         * @param guid The GUID of an asset.
         * @returns Path of the asset relative to the project folder. 
         */
        static GUIDToAssetPath(guid: GUID): string
        /** Get the GUID for the asset at path.
         * @param path Filesystem path for the asset. All paths are relative to the project folder.
         * @returns The GUID of the asset. An all-zero GUID denotes an invalid asset path. 
         */
        static GUIDFromAssetPath(path: string): GUID
        /** Get the GUID for the asset at path.
         * @param path Filesystem path for the asset.
         * @param options Specifies whether this method should return a GUID for recently deleted assets. The default value is AssetPathToGUIDOptions.IncludeRecentlyDeletedAssets.
         * @returns GUID. 
         */
        static AssetPathToGUID(path: string, options: AssetPathToGUIDOptions): string
        /** Get the GUID for the asset at path.
         * @param path Filesystem path for the asset.
         * @param options Specifies whether this method should return a GUID for recently deleted assets. The default value is AssetPathToGUIDOptions.IncludeRecentlyDeletedAssets.
         * @returns GUID. 
         */
        static AssetPathToGUID(path: string): string
        /** Returns the hash of all the dependencies of an asset.
         * @param path Path to the asset.
         * @param guid GUID of the asset.
         * @returns Aggregate hash. 
         */
        static GetAssetDependencyHash(guid: GUID): Hash128
        /** Returns the hash of all the dependencies of an asset.
         * @param path Path to the asset.
         * @param guid GUID of the asset.
         * @returns Aggregate hash. 
         */
        static GetAssetDependencyHash(path: string): Hash128
        static SaveAssets(): void
        /** Writes all unsaved changes to the specified asset to disk.
         * @param obj The asset object to be saved, if dirty.
         * @param guid The guid of the asset to be saved, if dirty.
         */
        static SaveAssetIfDirty(guid: GUID): void
        /** Writes all unsaved changes to the specified asset to disk.
         * @param obj The asset object to be saved, if dirty.
         * @param guid The guid of the asset to be saved, if dirty.
         */
        static SaveAssetIfDirty(obj: Object1): void
        /** Retrieves an icon for the asset at the given asset path.
         */
        static GetCachedIcon(path: string): Texture
        /** Replaces that list of labels on an asset.
         */
        static SetLabels(obj: Object1, labels: Array<string>): void
        static GetLabels(guid: GUID): Array<string>
        /** Returns all labels attached to a given asset.
         */
        static GetLabels(obj: Object1): Array<string>
        /** Removes all labels attached to an asset.
         */
        static ClearLabels(obj: Object1): void
        static GetAllAssetBundleNames(): Array<string>
        static GetUnusedAssetBundleNames(): Array<string>
        /** Remove the assetBundle name from the asset database. The forceRemove flag is used to indicate if you want to remove it even it's in use.
         * @param assetBundleName The assetBundle name you want to remove.
         * @param forceRemove Flag to indicate if you want to remove the assetBundle name even it's in use.
         */
        static RemoveAssetBundleName(assetBundleName: string, forceRemove: boolean): boolean
        static RemoveUnusedAssetBundleNames(): void
        /** Returns an array containing the paths of all assets marked with the specified Asset Bundle name.
         */
        static GetAssetPathsFromAssetBundle(assetBundleName: string): Array<string>
        /** Get the Asset paths for all Assets tagged with assetBundleName and
                named assetName.
         */
        static GetAssetPathsFromAssetBundleAndAssetName(assetBundleName: string, assetName: string): Array<string>
        /** Returns the name of the AssetBundle that a given asset belongs to.
         * @param assetPath The asset's path.
         * @returns Returns the name of the AssetBundle that a given asset belongs to. See the method description for more details. 
         */
        static GetImplicitAssetBundleName(assetPath: string): string
        /** Returns the name of the AssetBundle Variant that a given asset belongs to.
         * @param assetPath The asset's path.
         * @returns Returns the name of the AssetBundle Variant that a given asset belongs to. See the method description for more details. 
         */
        static GetImplicitAssetBundleVariantName(assetPath: string): string
        /** Given an assetBundleName, returns the list of AssetBundles that it depends on.
         * @param assetBundleName The name of the AssetBundle for which dependencies are required.
         * @param recursive If false, returns only AssetBundles which are direct dependencies of the input; if true, includes all indirect dependencies of the input.
         * @returns The names of all AssetBundles that the input depends on. 
         */
        static GetAssetBundleDependencies(assetBundleName: string, recursive: boolean): Array<string>
        /** Returns an array of all the assets that are dependencies of the asset at the specified pathName.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathName The path to the asset for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathName: string, recursive: boolean): Array<string>
        /** Returns an array of the paths of assets that are dependencies of all the assets in the list of pathNames that you provide.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathNames The path to the assets for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathNames: Array<string>, recursive: boolean): Array<string>
        /** Returns an array of all the assets that are dependencies of the asset at the specified pathName.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathName The path to the asset for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathName: string): Array<string>
        /** Returns an array of the paths of assets that are dependencies of all the assets in the list of pathNames that you provide.

Note: GetDependencies() gets the Assets that are referenced by other Assets. For example, a Scene could contain many GameObjects with a Material attached to them. In this case,  GetDependencies() will return the path to the Material Assets, but not the GameObjects as those are not Assets on your disk.
         * @param pathNames The path to the assets for which dependencies are required.
         * @param recursive Controls whether this method recursively checks and returns all dependencies including indirect dependencies (when set to true), or whether it only returns direct dependencies (when set to false).
         * @returns The paths of all assets that the input depends on. 
         */
        static GetDependencies(pathNames: Array<string>): Array<string>
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathName: string, fileName: string, flags: ExportPackageOptions): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathNames: Array<string>, fileName: string, flags: ExportPackageOptions): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathName: string, fileName: string): void
        /** Exports the assets identified by assetPathNames to a unitypackage file in fileName.
         */
        static ExportPackage(assetPathNames: Array<string>, fileName: string): void
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, message: jsb.Out<string>, statusOptions: StatusQueryOptions): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, statusOptions: StatusQueryOptions): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1, message: jsb.Out<string>): boolean
        /** Query whether an asset's metadata (.meta) file is open for edit in version control.
         * @param assetObject Object representing the asset whose metadata status you wish to query.
         * @param message Returns a reason for the asset metadata not being open for edit.
         * @param statusOptions Options for how the version control system should be queried. These options can effect the speed and accuracy of the query. Default is StatusQueryOptions.UseCachedIfPossible.
         * @returns True if the asset's metadata is considered open for edit by the selected version control system. 
         */
        static IsMetaFileOpenForEdit(assetObject: Object1): boolean
        static GetBuiltinExtraResource(type: any, path: string): Object1
        static ForceReserializeAssets(assetPaths: IEnumerable<string>, options: ForceReserializeAssetsOptions): void
        static ForceReserializeAssets(): void
        /** Get the GUID and local file id from an object instance id.
         * @param instanceID InstanceID of the object to retrieve information for.
         * @param obj The object to retrieve GUID and File Id for.
         * @param assetRef The asset reference to retrieve GUID and File Id for.
         * @param guid The GUID of an asset.
         * @param localId The local file identifier of this asset.
         * @returns True if the guid and file id were successfully found, false if not. 
         */
        static TryGetGUIDAndLocalFileIdentifier(obj: Object1, guid: jsb.Out<string>, localId: jsb.Out<number>): boolean
        /** Get the GUID and local file id from an object instance id.
         * @param instanceID InstanceID of the object to retrieve information for.
         * @param obj The object to retrieve GUID and File Id for.
         * @param assetRef The asset reference to retrieve GUID and File Id for.
         * @param guid The GUID of an asset.
         * @param localId The local file identifier of this asset.
         * @returns True if the guid and file id were successfully found, false if not. 
         */
        static TryGetGUIDAndLocalFileIdentifier(instanceID: number, guid: jsb.Out<string>, localId: jsb.Out<number>): boolean
        /** Removes object from its asset (Additional resources: AssetDatabase.AddObjectToAsset).
         */
        static RemoveObjectFromAsset(objectToRemove: Object1): void
        /** Imports package at packagePath into the current project.
         */
        static ImportPackage(packagePath: string, interactive: boolean): void
        static DisallowAutoRefresh(): void
        static AllowAutoRefresh(): void
        /** Clears the importer override for the asset.
         * @param path Asset path.
         */
        static ClearImporterOverride(path: string): void
        static IsCacheServerEnabled(): boolean
        /** Returns the type of the override importer.
         * @param path Asset path.
         * @returns Importer type. 
         */
        static GetImporterOverride(path: string): any
        /** Gets the importer types associated with a given Asset type.
         * @param path The Asset path.
         * @returns Returns an array of importer types that can handle the specified Asset. 
         */
        static GetAvailableImporterTypes(path: string): Array<any>
        /** Checks the availability of the Cache Server.
         * @param ip The IP address of the Cache Server.
         * @param port The Port number of the Cache Server.
         * @returns Returns true when Editor can connect to the Cache Server. Returns false otherwise. 
         */
        static CanConnectToCacheServer(ip: string, port: number): boolean
        static RefreshSettings(): void
        static IsConnectedToCacheServer(): boolean
        static ResetCacheServerReconnectTimer(): void
        static CloseCacheServerConnection(): void
        static GetCacheServerAddress(): string
        static GetCacheServerPort(): number
        static GetCacheServerNamespacePrefix(): string
        static GetCacheServerEnableDownload(): boolean
        static GetCacheServerEnableUpload(): boolean
        static IsDirectoryMonitoringEnabled(): boolean
        /** Allows you to register a custom dependency that Assets can be dependent on. If you register a custom dependency, and specify that an Asset is dependent on it, then the Asset will get re-imported if the custom dependency changes.
         * @param dependency Name of dependency. You can use any name you like, but because these names are global across all your Assets, it can be useful to use a naming convention (eg a path-based naming system) to avoid clashes with other custom dependency names.
         * @param hashOfValue A Hash128 value of the dependency.
         */
        static RegisterCustomDependency(dependency: string, hashOfValue: Hash128): void
        /** Removes custom dependencies that match the prefixFilter.
         * @param prefixFilter Prefix filter for the custom dependencies to unregister.
         * @returns Number of custom dependencies removed. 
         */
        static UnregisterCustomDependencyPrefixFilter(prefixFilter: string): number
        static IsAssetImportWorkerProcess(): boolean
        static ForceToDesiredWorkerCount(): void
        protected constructor()
        /** Changes during Refresh if anything has changed that can invalidate any artifact.
         */
        static readonly GlobalArtifactDependencyVersion: number
        /** Changes whenever a new artifact is added to the artifact database.
         */
        static readonly GlobalArtifactProcessedVersion: number
        /** Gets the refresh import mode currently in use by the asset database.
         */
        static ActiveRefreshImportMode: AssetDatabase.RefreshImportMode
        /** The desired number of processes to use when importing assets, during an asset database refresh.
         */
        static DesiredWorkerCount: number
        static importPackageStarted(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageCompleted(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageCancelled(op: "add" | "remove", fn: (packageName: string) => void): void
        static importPackageFailed(op: "add" | "remove", fn: (packageName: string, errorMessage: string) => void): void
        static cacheServerConnectionChanged(op: "add" | "remove", fn: (obj: CacheServerConnectionChangedParameters) => void): void
        static onImportPackageItemsCompleted(op: "get"): (obj: Array<string>) => void
        static onImportPackageItemsCompleted(op: "add" | "remove" | "set", fn?: (obj: Array<string>) => void): void
        static onImportPackageItemsCompleted(op: "add" | "remove" | "set" | "get", fn?: (obj: Array<string>) => void): (obj: Array<string>) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum, ValueType } from "System";
    import { Object as Object1, Material } from "UnityEngine";
    /** Utility functions to assist with working with shaders from the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderUtil extends Object {
        /** Determines whether the specified Shader contains a valid Procedural Instancing variant.
         * @param s The Shader to check.
         * @returns Returns true if the Shader has a valid Procedural Instancing variant. Returns false otherwise. 
         */
        static HasProceduralInstancing(s: any): boolean
        /** Returns the number of errors and warnings generated by the Unity Shader Compiler for the given Shader.
         * @param s The Shader instance to check for messages.
         * @returns The number of errors and warnings generated by the Unity Shader Compiler. 
         */
        static GetShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Unity Shader Compiler for the given Shader.
         * @param s The Shader instance to check for messages.
         * @param platform The ShaderCompilerPlatform to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetShaderMessages(s: any, platform: any): Array<ShaderMessage>
        /** Returns each error and warning generated by the Unity Shader Compiler for the given Shader.
         * @param s The Shader instance to check for messages.
         * @param platform The ShaderCompilerPlatform to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetShaderMessages(s: any): Array<ShaderMessage>
        /** Clear compile time messages for the given shader.
         */
        static ClearShaderMessages(s: any): void
        /** Returns the number of errors and warnings generated by the Unity Shader Compiler for the given ComputeShader.
         * @param s The ComputeShader instance to check for messages.
         * @returns The number of errors and warnings generated by the Unity Shader Compiler. 
         */
        static GetComputeShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Unity Shader Compiler for the given ComputeShader.
         * @param s The ComputeShader instance to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetComputeShaderMessages(s: any): Array<ShaderMessage>
        /** Returns the number of errors and warnings generated by the Shader Compiler for the given RayTracingShader.
         * @param s The RayTracingShader instance to check for messages.
         * @returns The number of errors and warnings generated by the Shader Compiler. 
         */
        static GetRayTracingShaderMessageCount(s: any): number
        /** Returns each error and warning generated by the Shader Compiler for the given RayTracingShader.
         * @param s The RayTracingShader instance to check for messages.
         * @returns An array of ShaderMessage structs containing the generated messages. 
         */
        static GetRayTracingShaderMessages(s: any): Array<ShaderMessage>
        /** Returns the number of ray generation Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of ray generation Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetRayGenerationShaderCount(s: any): number
        /** Returns the name of a user-defined ray generation Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The ray generation Shader index for which to retrieve the name. The ray generation Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the ray generation Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetRayGenerationShaderName(s: any, shaderIndex: number): string
        /** Returns the number of miss Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of miss Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetMissShaderCount(s: any): number
        /** Returns the name of a user-defined miss Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The miss Shader index for which to retrieve the name. The miss Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the miss Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetMissShaderName(s: any, shaderIndex: number): string
        /** Returns the ray payload size of a user-defined miss Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The miss Shader index for which to retrieve the ray payload size.
         * @returns The ray payload size in bytes. 
         */
        static GetMissShaderRayPayloadSize(s: any, shaderIndex: number): number
        /** Returns the number of callable Shaders defined whitin a given RayTracingShader.
         * @param s The RayTracingShader instance.
         * @returns The number of callable Shaders defined in the RayTracingShader instance passed as argument. 
         */
        static GetCallableShaderCount(s: any): number
        /** Returns the name of a user-defined callable Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The callable Shader index for which to retrieve the name. The callable Shaders defined in a RayTracingShader are sorted alphabetically by the Shader compiler.
         * @returns The name of the callable Shader at the index passed using the "shaderIndex" argument. 
         */
        static GetCallableShaderName(s: any, shaderIndex: number): string
        /** Returns the parameter size of a user-defined callable Shader from within a RayTracingShader.
         * @param s The RayTracingShader instance.
         * @param shaderIndex The callable Shader index for which to retrieve the parameter size.
         * @returns The parameter size in bytes. 
         */
        static GetCallableShaderParamSize(s: any, shaderIndex: number): number
        /** Clears all internally-cached data that was generated for the given shader, such as errors and compilation info.
         */
        static ClearCachedData(s: any): void
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(context: any, source: string, compileInitialShaderVariants: boolean): any
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(source: string, compileInitialShaderVariants: boolean): any
        /** Creates a new Shader object from the provided source code string. You can use this method alongside the ScriptedImporter to create custom shader generation tools in the Editor.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         */
        static CreateShaderAsset(source: string): any
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(context: any, shader: any, source: string, compileInitialShaderVariants: boolean): void
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(shader: any, source: string, compileInitialShaderVariants: boolean): void
        /** Replaces the existing source code in the specified shader with the source code in the supplied string.
         * @param context A context object that the asset system needs to register shader dependencies properly.
         * @param source A string that contains a shader written in code.
         * @param compileInitialShaderVariants Set to true to compile the code contained in the source string; otherwise false.
         * @param shader The Shader to update.
         */
        static UpdateShaderAsset(shader: any, source: string): void
        /** Register a user created shader.
         */
        static RegisterShader(shader: any): void
        static GetAllShaderInfo(): Array<ShaderInfo>
        /** Gets ShaderInfo for the given shader.
         * @param shader The shader to get information about.
         * @returns Returns an instance of ShaderInfo for the given shader. 
         */
        static GetShaderInfo(shader: any): ShaderInfo
        /** Adds shader compilation mode command in the CommandBuffer.
         * @param cmd Target CommandBuffer.
         * @param allow Is async Shader compilation allowed or not.
         */
        static SetAsyncCompilation(cmd: any, allow: boolean): void
        /** Restores the previous Shader compilation mode in this CommandBuffer scope.
         * @param cmd Target CommandBuffer.
         */
        static RestoreAsyncCompilation(cmd: any): void
        /** Checks if the Shader variant for the given pass in the Material has already been compiled.
         * @param material The Material to check against.
         * @param pass The index of the Shader pass to check.
         */
        static IsPassCompiled(material: Material, pass: number): boolean
        /** Request the Editor to compile the Shader Variant needed for the specific pass of the given Material.
         * @param material Target Material.
         * @param pass Index of the target Shader pass.
         * @param forceSync Forces the script execution to wait until the compilation has finished. Optional.
         */
        static CompilePass(material: Material, pass: number, forceSync: boolean): void
        /** Gets the shader's custom editor class name for a specific render pipeline asset type.
         * @param renderPipelineType The render pipeline asset type.
         * @param shader The shader to check against.
         * @returns Returns the full class name of the custom editor. 
         */
        static GetCustomEditorForRenderPipeline(shader: any, renderPipelineType: string): string
        /** Gets the shader's custom editor class name for a specific render pipeline asset type.
         * @param renderPipelineType The render pipeline asset type.
         * @param shader The shader to check against.
         * @returns Returns the full class name of the custom editor. 
         */
        static GetCustomEditorForRenderPipeline(shader: any, renderPipelineType: any): string
        /** Gets the current custom editor for the shader you pass in.

Depending on the render pipeline asset assigned in your Graphics Settings, the custom editor can change if the shader has a different custom editor for one or multiple render pipeline assets.
         * @param shader The shader to check against.
         * @returns The current custom editor full class name. 
         */
        static GetCurrentCustomEditor(shader: any): string
        /** Gets the platform keywords for a shader, given a shader compiler platform, build target, and optional graphics tier. These platform keywords are necessary to properly compile a shader for a given target.
         * @param shaderCompilerPlatform The shader compiler platform.
         * @param buildTarget The build target.
         * @param tier An optional graphics tier.
         * @returns Returns an array of built-in shader defines needed to compile a shader for the given target. 
         */
        static GetShaderPlatformKeywordsForBuildTarget(shaderCompilerPlatform: any, buildTarget: BuildTarget, tier: any): Array<any>
        /** Gets the platform keywords for a shader, given a shader compiler platform, build target, and optional graphics tier. These platform keywords are necessary to properly compile a shader for a given target.
         * @param shaderCompilerPlatform The shader compiler platform.
         * @param buildTarget The build target.
         * @param tier An optional graphics tier.
         * @returns Returns an array of built-in shader defines needed to compile a shader for the given target. 
         */
        static GetShaderPlatformKeywordsForBuildTarget(shaderCompilerPlatform: any, buildTarget: BuildTarget): Array<any>
        static GetPassKeywords(s: any, passIdentifier: jsb.Ref<any>, shaderType: any, shaderCompilerPlatform: any): Array<any>
        static GetPassKeywords(s: any, passIdentifier: jsb.Ref<any>, shaderType: any): Array<any>
        static GetPassKeywords(s: any, passIdentifier: jsb.Ref<any>): Array<any>
        static PassHasKeyword(s: any, passIdentifier: jsb.Ref<any>, keyword: jsb.Ref<any>, shaderType: any, shaderCompilerPlatform: any): boolean
        static PassHasKeyword(s: any, passIdentifier: jsb.Ref<any>, keyword: jsb.Ref<any>, shaderType: any): boolean
        static PassHasKeyword(s: any, passIdentifier: jsb.Ref<any>, keyword: jsb.Ref<any>): boolean
        /** Get the number of properties in Shader s.
         * @param s The shader to check against.
         */
        static GetPropertyCount(s: any): number
        /** Get the name of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetPropertyName(s: any, propertyIdx: number): string
        /** Get the ShaderProperyType of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetPropertyType(s: any, propertyIdx: number): any
        /** Get the description of the shader propery at index propertyIdx of Shader s.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         * @returns Returns the description of the given shader property. 
         */
        static GetPropertyDescription(s: any, propertyIdx: number): string
        /** Get Limits for a range property at index propertyIdx of Shader s.
         * @param defminmax Which value to get: 0 = default, 1 = min, 2 = max.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static GetRangeLimits(s: any, propertyIdx: number, defminmax: number): number
        /** Gets texture dimension of a shader property.
         * @param s The shader to get the property from.
         * @param propertyIdx The property index to use.
         * @returns Texture dimension. 
         */
        static GetTexDim(s: any, propertyIdx: number): any
        /** Returns true if the shader propery at index propertyIdx is hidden with the [HideInInspector] attribute in the shader code.
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static IsShaderPropertyHidden(s: any, propertyIdx: number): boolean
        /** Is the shader propery at index propertyIdx of Shader s a NonModifiableTextureProperty?
         * @param s The shader to check against.
         * @param propertyIdx The property index to use.
         */
        static IsShaderPropertyNonModifiableTexureProperty(s: any, propertyIdx: number): boolean
        /** Get the shader data for a specific shader.
         * @param shader The shader to get data from.
         * @returns The shader data for the provided shader. 
         */
        static GetShaderData(shader: any): ShaderData
        /** Checks if a shader has any compilation errors. Ignores warnings.
         * @param shader The shader to check for compilation errors.
         * @returns Returns true if the shader has any compilation errors. Otherwise, returns false. 
         */
        static ShaderHasError(shader: any): boolean
        /** Checks if a shader has any compilation warnings. Ignores errors.
         * @param shader The shader to check for compilation warnings.
         * @returns Returns true if the shader has any compilation warnings. Otherwise, returns false. 
         */
        static ShaderHasWarnings(shader: any): boolean
        protected constructor()
        /** Does the current hardware support render textues.
         */
        static readonly hardwareSupportsRectRenderTexture: boolean
        /** When true, the Editor is compiling some Shaders asynchronously at the point of query.
         */
        static readonly anythingCompiling: boolean
        /** When true, asynchronous Shader compilation is allowed at the current call site.
         */
        static allowAsyncCompilation: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum, ValueType } from "System";
    import { Object as Object1, Texture2D, Texture, Renderer, Camera, Rect, GUIContent, GameObject } from "UnityEngine";
    /** Editor utility functions.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorUtility extends Object {
        /** Displays the "open file" dialog and returns the selected path name.
         * @param title The text to display in the toolbar of the dialog window. 
         * @param directory The default file directory that this dialog opens. This parameter is relative to the project directory. For example, "Assets" displays the Assets directory when this dialog opens.
         * @param extension The file extensions to filter in this dialog. Do not precede file extension names with a period. Enter an empty string to include all file types. Separate multiple file extensions with a comma.
         */
        static OpenFilePanel(title: string, directory: string, extension: string): string
        /** Displays the "open file" dialog and returns the selected path name.
         * @param title Title for dialog.
         * @param directory Default directory.
         * @param filters File extensions in form { "Image files", "png,jpg,jpeg", "All files", "*" }.
         */
        static OpenFilePanelWithFilters(title: string, directory: string, filters: Array<string>): string
        static RevealInFinder(path: string): void
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user clicks the ok button, or previously opted out. Returns false if the user cancels or closes the dialog without making a decision. 
         */
        static DisplayDialog(title: string, message: string, ok: string, cancel: string, dialogOptOutDecisionType: DialogOptOutDecisionType, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user clicks the ok button, or previously opted out. Returns false if the user cancels or closes the dialog without making a decision. 
         */
        static DisplayDialog(title: string, message: string, ok: string, dialogOptOutDecisionType: DialogOptOutDecisionType, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @returns Returns true if the user clicks the OK button. Returns false otherwise. 
         */
        static DisplayDialog(title: string, message: string, ok: string, cancel: string): boolean
        /** This method displays a modal dialog.
         * @param title The title of the message box.
         * @param message The text of the message.
         * @param ok Label displayed on the OK dialog button.
         * @param cancel Label displayed on the Cancel dialog button.
         * @returns Returns true if the user clicks the OK button. Returns false otherwise. 
         */
        static DisplayDialog(title: string, message: string, ok: string): boolean
        /** Displays a modal dialog with three buttons.
         * @param title Title for dialog.
         * @param message Purpose for the dialog.
         * @param ok Dialog function chosen.
         * @param cancel Close dialog with no operation.
         * @param alt Choose alternative dialog purpose.
         * @returns Returns the ID of a button. IDs are 0, 1, or 2 and they correspond to the ok, cancel and alt buttons respectively. An ID of 1, which corresponds to cancel, returns if the dialog is closed or the user presses the Escape key. 
         */
        static DisplayDialogComplex(title: string, message: string, ok: string, cancel: string, alt: string): number
        /** Displays the "open folder" dialog and returns the selected path name.
         */
        static OpenFolderPanel(title: string, folder: string, defaultName: string): string
        /** Displays the "save folder" dialog and returns the selected path name.
         */
        static SaveFolderPanel(title: string, folder: string, defaultName: string): string
        static WarnPrefab(target: Object1, title: string, warning: string, okButton: string): boolean
        /** Determines if an object is stored on disk.
         */
        static IsPersistent(target: Object1): boolean
        /** Displays the "save file" dialog and returns the selected path name.
         */
        static SaveFilePanel(title: string, directory: string, defaultName: string, extension: string): string
        /** Human-like sorting.
         */
        static NaturalCompare(a: string, b: string): number
        /** Translates an instance ID to a reference to an object.
         */
        static InstanceIDToObject(instanceID: number): Object1
        /** Compress a texture.
         */
        static CompressTexture(texture: Texture2D, format: any, quality: number): void
        /** Compress a texture.
         */
        static CompressTexture(texture: Texture2D, format: any, quality: TextureCompressionQuality): void
        /** Compress a cubemap texture.
         */
        static CompressCubemapTexture(texture: any, format: any, quality: number): void
        /** Compress a cubemap texture.
         */
        static CompressCubemapTexture(texture: any, format: any, quality: TextureCompressionQuality): void
        /** Marks target object as dirty.
         * @param target The object to mark as dirty.
         */
        static SetDirty(target: Object1): void
        /** Clear target's dirty flag.
         */
        static ClearDirty(target: Object1): void
        static InvokeDiffTool(leftTitle: string, leftFile: string, rightTitle: string, rightFile: string, ancestorTitle: string, ancestorFile: string): string
        /** Copy all settings of a Unity Object.
         */
        static CopySerialized(source: Object1, dest: Object1): void
        /** Copies the serializable fields from one managed object to another.
         * @param source The object to copy data from.
         * @param dest The object to copy data to.
         */
        static CopySerializedManagedFieldsOnly(source: Object, dest: Object): void
        /** Calculates and returns a list of all assets the assets listed in roots depend on.
         */
        static CollectDependencies(roots: Array<Object1>): Array<Object1>
        /** Collect all objects in the hierarchy rooted at each of the given objects.
         * @param roots Array of objects where the search will start.
         * @returns Array of objects heirarchically attached to the search array. 
         */
        static CollectDeepHierarchy(roots: Array<Object1>): Array<Object1>
        static FormatBytes(bytes: number): string
        /** Returns a text for a number of bytes.
         */
        static FormatBytes(bytes: number): string
        /** Displays or updates a progress bar.
         */
        static DisplayProgressBar(title: string, info: string, progress: number): void
        /** Displays or updates a progress bar that has a cancel button.
         */
        static DisplayCancelableProgressBar(title: string, info: string, progress: number): boolean
        static ClearProgressBar(): void
        /** Is the object enabled (0 disabled, 1 enabled, -1 has no enabled button).
         */
        static GetObjectEnabled(target: Object1): number
        /** Set the enabled state of the object.
         */
        static SetObjectEnabled(target: Object1, enabled: boolean): void
        /** Set the Scene View selected display mode for this Renderer.
         */
        static SetSelectedRenderState(renderer: Renderer, renderState: EditorSelectedRenderState): void
        static OpenWithDefaultApp(fileName: string): void
        /** Sets this camera to allow animation of materials in the Editor.
         */
        static SetCameraAnimateMaterials(camera: Camera, animate: boolean): void
        /** Sets the global time for this camera to use when rendering.
         */
        static SetCameraAnimateMaterialsTime(camera: Camera, time: number): void
        /** Updates the global shader properties to use when rendering.
         * @param time Time to use. -1 to disable.
         */
        static UpdateGlobalShaderProperties(time: number): void
        /** Returns an integer that indicates the number of times the specified object's serialized properties have changed.
         * @param instanceID The object's instance ID.
         * @param target The object.
         */
        static GetDirtyCount(instanceID: number): number
        /** Returns an integer that indicates the number of times the specified object's serialized properties have changed.
         * @param instanceID The object's instance ID.
         * @param target The object.
         */
        static GetDirtyCount(target: Object1): number
        /** Gets a boolean value that indicates whether the specified object has changed since the last time it was saved.
         * @param instanceID The object's instance ID.
         * @param target The object.
         * @returns True if the object has changed; otherwise false. 
         */
        static IsDirty(instanceID: number): boolean
        /** Gets a boolean value that indicates whether the specified object has changed since the last time it was saved.
         * @param instanceID The object's instance ID.
         * @param target The object.
         * @returns True if the object has changed; otherwise false. 
         */
        static IsDirty(target: Object1): boolean
        static FocusProjectWindow(): void
        static RequestScriptReload(): void
        static IsRunningUnderCPUEmulation(): boolean
        static LoadWindowLayout(path: string): boolean
        static SaveFilePanelInProject(title: string, defaultName: string, extension: string, message: string, path: string): string
        /** Displays the "save file" dialog in the Assets folder of the project and returns the selected path name.
         */
        static SaveFilePanelInProject(title: string, defaultName: string, extension: string, message: string): string
        /** Copy all settings of a Unity Object to a second Object if they differ.
         */
        static CopySerializedIfDifferent(source: Object1, dest: Object1): void
        /** Unloads assets that are not used.
         * @param includeMonoReferencesAsRoots When true, this method does not unload assets referenced by script properties and static variables.
         */
        static UnloadUnusedAssetsImmediate(includeMonoReferencesAsRoots: boolean): void
        static UnloadUnusedAssetsImmediate(): void
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @returns true if the user previously opted out of seeing the dialog associated with dialogOptOutDecisionStorageKey. Returns false if the user did not yet opt out. 
         */
        static GetDialogOptOutDecision(dialogOptOutDecisionType: DialogOptOutDecisionType, dialogOptOutDecisionStorageKey: string): boolean
        /** This method displays a modal dialog that lets the user opt-out of being shown the current dialog box again.
         * @param dialogOptOutDecisionType The type of opt-out decision a user can make.
         * @param dialogOptOutDecisionStorageKey The unique key setting to store the decision under.
         * @param optOutDecision The unique key setting to store the decision under.
         */
        static SetDialogOptOutDecision(dialogOptOutDecisionType: DialogOptOutDecisionType, dialogOptOutDecisionStorageKey: string, optOutDecision: boolean): void
        /** Displays a popup menu.
         */
        static DisplayPopupMenu(position: Rect, menuItemPath: string, command: MenuCommand): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, checkEnabled: (arg: number) => boolean, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object, showHotkey: boolean): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object, showHotkey: boolean): void
        static DisplayCustomMenu(position: Rect, options: Array<GUIContent>, selected: number, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object): void
        /** Creates a game object with HideFlags and specified components.
         */
        static CreateGameObjectWithHideFlags(name: string, flags: any, ...components: any[]): GameObject
        static DisplayCustomMenuWithSeparators(position: Rect, options: Array<string>, enabled: Array<boolean>, separator: Array<boolean>, selected: Array<number>, callback: (userData: Object, options: Array<string>, selected: number) => void, userData: Object): void
        /** Set custom diff tool settings.
         * @param path Diff tool path.
         * @param twoWayDiff Two - way diff command line.
         * @param threeWayDiff Three - way diff command line.
         * @param mergeCommand Merge command line.
         * @param forceEnableCustomTool Sets Custom Tool as current active Revision Control Diff/Merge tool.
         */
        static SetCustomDiffTool(path: string, twoWayDiff: string, threeWayDiff: string, mergeCommand: string, forceEnableCustomTool: boolean): void
        /** Sets the default parent object for the active Scene.
         * @param defaultParentObject The GameObject to set as the default parent object.
         */
        static SetDefaultParentObject(defaultParentObject: GameObject): void
        /** Clears the default parent GameObject from either a specific Scene or the active Scene.
         * @param scene Specify a Scene to clear the default parent object for a specific Scene. If a Scene is not specified, this method clears the default parent object for the active Scene.
         */
        static ClearDefaultParentObject(scene: any): void
        static ClearDefaultParentObject(): void
        /** Open properties editor for an Object.
         * @param obj The object to open in the properties editor.
         */
        static OpenPropertyEditor(obj: Object1): void
        protected constructor()
        static audioMasterMute: boolean
        /** True if there are any compilation error messages in the log.
         */
        static readonly scriptCompilationFailed: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { Rect, GUIStyle, GUIContent, Object as Object1, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, RectInt, Bounds, BoundsInt, Color, AnimationCurve, FocusType, Texture, ScaleMode, Material, Gradient } from "UnityEngine";
    /** These work pretty much like the normal GUI functions - and also have matching implementations in EditorGUILayout.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUI extends Object {
        /** Move keyboard focus to a named text field and begin editing of the content.
         * @param name Name set using GUI.SetNextControlName.
         */
        static FocusTextInControl(name: string): void
        /** Create a group of controls that can be disabled.
         * @param disabled Boolean specifying if the controls inside the group should be disabled.
         */
        static BeginDisabledGroup(disabled: boolean): void
        static EndDisabledGroup(): void
        static BeginChangeCheck(): void
        static EndChangeCheck(): boolean
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, text: string, style: GUIStyle): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, content: GUIContent, style: GUIStyle): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, text: string): void
        /** Draws a label with a drop shadow.
         * @param position Where to show the label.
         * @param content Text to show
@style style to use.
         */
        static DropShadowLabel(position: Rect, content: GUIContent): void
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: string, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: GUIContent, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: string, value: boolean): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, value: boolean, style: GUIStyle): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, label: GUIContent, value: boolean): boolean
        /** Makes a toggle.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @returns The selected state of the toggle. 
         */
        static Toggle(position: Rect, value: boolean): boolean
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, label: string, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, label: GUIContent, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: string): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static Slider(position: Rect, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static Slider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number): void
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, label: string, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, label: GUIContent, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: string): void
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent): void
        /** Makes a slider the user can drag to change an integer value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(position: Rect, value: number, leftValue: number, rightValue: number): number
        /** Makes a slider the user can drag to change a value between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         */
        static IntSlider(position: Rect, property: SerializedProperty, leftValue: number, rightValue: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, label: string, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, label: GUIContent, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Makes a special slider the user can use to specify a range between a min and a max.
         * @param position Rectangle on the screen to use for the slider.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         */
        static MinMaxSlider(position: Rect, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number): void
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum, includeObsolete: boolean, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: string, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, enumValue: Enum, style: GUIStyle): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: string, enumValue: Enum): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, label: GUIContent, enumValue: Enum): Enum
        /** Displays a menu with an option for every value of the enum type when clicked. An option for the value 0 with name "Nothing" and an option for the value ~0 (that is, all bits set) with the name "Everything" are always displayed at the top of the menu. The names for the values 0 and ~0 can be overriden by defining these values in the enum type.
         * @param position Rectangle on the screen to use for the enum flags field.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value (Only supports enum values for enum types with int as the underlying type).
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(position: Rect, enumValue: Enum): Enum
        static ObjectField(position: Rect, label: string, obj: Object1, objType: any, targetBeingEdited: Object1): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, label: string, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        static ObjectField(position: Rect, label: GUIContent, obj: Object1, objType: any, targetBeingEdited: Object1): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, label: GUIContent, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, objType: any, label: GUIContent): void
        static ObjectField(position: Rect, obj: Object1, objType: any, targetBeingEdited: Object1): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(position: Rect, obj: Object1, objType: any, allowSceneObjects: boolean): Object1
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, label: GUIContent): void
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty, objType: any): void
        /** Makes an object field. You can assign objects either by drag and drop objects or by selecting an object using the Object Picker.
         * @param position Rectangle on the screen to use for the field.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label to display in front of the field. Pass GUIContent.none to hide the label.
         */
        static ObjectField(position: Rect, property: SerializedProperty): void
        static IndentedRect(source: Rect): Rect
        /** Makes an X and Y field for entering a Vector2.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2Field(position: Rect, label: string, value: Vector2): Vector2
        /** Makes an X and Y field for entering a Vector2.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2Field(position: Rect, label: GUIContent, value: Vector2): Vector2
        /** Makes an X, Y, and Z field for entering a Vector3.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3Field(position: Rect, label: string, value: Vector3): Vector3
        /** Makes an X, Y, and Z field for entering a Vector3.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3Field(position: Rect, label: GUIContent, value: Vector3): Vector3
        /** Makes an X, Y, Z, and W field for entering a Vector4.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector4Field(position: Rect, label: string, value: Vector4): Vector4
        static Vector4Field(position: Rect, label: GUIContent, value: Vector4): Vector4
        /** Makes an X and Y integer field for entering a Vector2Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(position: Rect, label: string, value: Vector2Int): Vector2Int
        /** Makes an X and Y integer field for entering a Vector2Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(position: Rect, label: GUIContent, value: Vector2Int): Vector2Int
        /** Makes an X, Y, and Z integer field for entering a Vector3Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(position: Rect, label: string, value: Vector3Int): Vector3Int
        /** Makes an X, Y, and Z integer field for entering a Vector3Int.
         * @param position Rectangle on the screen to use for the field.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(position: Rect, label: GUIContent, value: Vector3Int): Vector3Int
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, label: string, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, label: GUIContent, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a Rect.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectField(position: Rect, value: Rect): Rect
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, label: string, value: RectInt): RectInt
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, label: GUIContent, value: RectInt): RectInt
        /** Makes an X, Y, W, and H field for entering a RectInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static RectIntField(position: Rect, value: RectInt): RectInt
        static BoundsField(position: Rect, label: string, value: Bounds): Bounds
        /** Makes Center and Extents field for entering a Bounds.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsField(position: Rect, label: GUIContent, value: Bounds): Bounds
        /** Makes Center and Extents field for entering a Bounds.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsField(position: Rect, value: Bounds): Bounds
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, label: string, value: BoundsInt): BoundsInt
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, label: GUIContent, value: BoundsInt): BoundsInt
        /** Makes Position and Size field for entering a BoundsInt.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display above the field.
         * @param value The value to edit.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(position: Rect, value: BoundsInt): BoundsInt
        /** Makes a multi-control with text fields for entering multiple floats in the same line.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiFloatField(position: Rect, label: GUIContent, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with text fields for entering multiple floats in the same line.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiFloatField(position: Rect, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with text fields for entering multiple integers in the same line.
         * @param position Rectangle on the screen to use for the integer field.
         * @param subLabels Array with small labels to show in front of each int field. There is room for one letter per field only.
         * @param values Array with the values to edit.
         */
        static MultiIntField(position: Rect, subLabels: Array<GUIContent>, values: Array<number>): void
        /** Makes a multi-control with several property fields in the same line.
         * @param position Rectangle on the screen to use for the multi-property field.
         * @param valuesIterator The SerializedProperty of the first property to make a control for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         */
        static MultiPropertyField(position: Rect, subLabels: Array<GUIContent>, valuesIterator: SerializedProperty, label: GUIContent): void
        /** Makes a multi-control with several property fields in the same line.
         * @param position Rectangle on the screen to use for the multi-property field.
         * @param valuesIterator The SerializedProperty of the first property to make a control for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param subLabels Array with small labels to show in front of each float field. There is room for one letter per field only.
         */
        static MultiPropertyField(position: Rect, subLabels: Array<GUIContent>, valuesIterator: SerializedProperty): void
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: GUIContent, value: Color, showEyedropper: boolean, showAlpha: boolean, hdr: boolean): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: string, value: Color): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, label: GUIContent, value: Color): Color
        /** Makes a field for selecting a Color.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @returns The color selected by the user. 
         */
        static ColorField(position: Rect, value: Color): Color
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: string, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: GUIContent, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(position: Rect, property: SerializedProperty, color: Color, ranges: Rect, label: GUIContent): void
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, value: AnimationCurve, color: Color, ranges: Rect): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(position: Rect, property: SerializedProperty, color: Color, ranges: Rect): void
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: string, value: AnimationCurve): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, label: GUIContent, value: AnimationCurve): AnimationCurve
        /** Makes a field for editing an AnimationCurve.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @returns The curve edited by the user. 
         */
        static CurveField(position: Rect, value: AnimationCurve): AnimationCurve
        /** Makes an inspector-window-like titlebar.
         * @param position Rectangle on the screen to use for the titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) that the titlebar is for.
         * @param targetObjs The objects that the titlebar is for.
         * @param expandable Whether this editor should display a foldout arrow in order to toggle the display of its properties.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(position: Rect, foldout: boolean, targetObj: Object1, expandable: boolean): boolean
        /** Makes an inspector-window-like titlebar.
         * @param position Rectangle on the screen to use for the titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) that the titlebar is for.
         * @param targetObjs The objects that the titlebar is for.
         * @param expandable Whether this editor should display a foldout arrow in order to toggle the display of its properties.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(position: Rect, foldout: boolean, targetObjs: Array<Object1>, expandable: boolean): boolean
        static InspectorTitlebar(position: Rect, foldout: boolean, editor: Editor): boolean
        static InspectorTitlebar(position: Rect, targetObjs: Array<Object1>): void
        /** Makes a progress bar.
         * @param totalPosition Rectangle on the screen to use in total for both the control.
         * @param value Value that is shown.
         */
        static ProgressBar(position: Rect, value: number, text: string): void
        /** Makes a help box with a message to the user.
         * @param position Rectangle on the screen to draw the help box within.
         * @param message The message text.
         * @param type The type of message.
         */
        static HelpBox(position: Rect, message: string, type: MessageType): void
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, id: number, label: GUIContent, style: GUIStyle): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, label: GUIContent, style: GUIStyle): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, id: number, label: GUIContent): Rect
        /** Makes a label in front of some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param label Label to show in front of the control.
         * @param style Style to use for the label.
         * @returns Rectangle on the screen to use just for the control itself. 
         */
        static PrefixLabel(totalPosition: Rect, label: GUIContent): Rect
        /** Create a Property wrapper, useful for making regular GUI controls work with SerializedProperty.
         * @param totalPosition Rectangle on the screen to use for the control, including label if applicable.
         * @param label Optional label in front of the slider. Use null to use the name from the SerializedProperty. Use GUIContent.none to not display a label.
         * @param property The SerializedProperty to use for the control.
         * @returns The actual label to use for the control. 
         */
        static BeginProperty(totalPosition: Rect, label: GUIContent, property: SerializedProperty): GUIContent
        static EndProperty(): void
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, label: GUIContent, includeChildren: boolean): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(type: SerializedPropertyType, label: GUIContent): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, includeChildren: boolean): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty, label: GUIContent): number
        /** Get the height needed for a PropertyField control.
         * @param property Height of the property area.
         * @param label Descriptive text or image.
         * @param includeChildren Should the returned height include the height of child properties?
         */
        static GetPropertyHeight(property: SerializedProperty): number
        /** Get whether a SerializedProperty's inspector GUI can be cached.
         * @param property The SerializedProperty in question.
         * @returns Whether the property's inspector GUI can be cached. 
         */
        static CanCacheInspectorGUI(property: SerializedProperty): boolean
        /** Makes a button that reacts to mouse down, for displaying your own dropdown content.
         * @param position Rectangle on the screen to use for the button.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(position: Rect, content: GUIContent, focusType: FocusType, style: GUIStyle): boolean
        /** Makes a button that reacts to mouse down, for displaying your own dropdown content.
         * @param position Rectangle on the screen to use for the button.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(position: Rect, content: GUIContent, focusType: FocusType): boolean
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture, scaleMode: ScaleMode): void
        /** Draws the alpha channel of a texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel What mip-level to sample. If negative, texture will be sampled normally.
It sets material _Mip property.
         */
        static DrawTextureAlpha(position: Rect, image: Texture): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any, exposure: number): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode, imageAspect: number): void
        static DrawTextureTransparent(position: Rect, image: Texture, scaleMode: ScaleMode): void
        static DrawTextureTransparent(position: Rect, image: Texture): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any, exposure: number): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number, mipLevel: number, colorWriteMask: any): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number, mipLevel: number): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode, imageAspect: number): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material, scaleMode: ScaleMode): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture, mat: Material): void
        /** Draws the texture within a rectangle.
         * @param position Rectangle on the screen to draw the texture within.
         * @param image Texture to display.
         * @param mat Material to be used when drawing the texture.
         * @param scaleMode How to scale the image when the aspect ratio of it doesn't fit the aspect ratio to be drawn within.
         * @param imageAspect Aspect ratio to use for the source image. If 0 (the default), the aspect ratio from the image is used.
         * @param mipLevel The mip-level to sample. If negative, the texture is sampled normally.
Sets material's _Mip property.
         * @param colorWriteMask Specifies which color components of image will get written. Sets material's _ColorMask property.
         * @param exposure Specifies the exposure for the texture. Sets material's _Exposure property.
         */
        static DrawPreviewTexture(position: Rect, image: Texture): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, label2: string, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, label2: GUIContent, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, style: GUIStyle): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string, label2: string): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent, label2: GUIContent): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: string): void
        /** Makes a label field. (Useful for showing read-only info.)
         * @param position Rectangle on the screen to use for the label field.
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param style Style information (color, etc) for displaying the label.
         */
        static LabelField(position: Rect, label: GUIContent): void
        /** Make a clickable link label.
         * @param position Rectangle on the screen to use for the control. The underline is done with the bottom border so set the size accordingly.
         * @param label Label of the link.
         * @returns true when the user clicks the link. 
         */
        static LinkButton(position: Rect, label: string): boolean
        /** Make a clickable link label.
         * @param position Rectangle on the screen to use for the control. The underline is done with the bottom border so set the size accordingly.
         * @param label Label of the link.
         * @returns true when the user clicks the link. 
         */
        static LinkButton(position: Rect, label: GUIContent): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: string, value: boolean, labelStyle: GUIStyle): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: GUIContent, value: boolean, labelStyle: GUIStyle): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: string, value: boolean): boolean
        /** Makes a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param position Rectangle on the screen to use for the toggle.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @returns The value set by the user. 
         */
        static ToggleLeft(position: Rect, label: GUIContent, value: boolean): boolean
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: string, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: GUIContent, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, text: string, style: GUIStyle): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: string, text: string): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, label: GUIContent, text: string): string
        /** Makes a text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextField(position: Rect, text: string): string
        static DelayedTextField(position: Rect, label: GUIContent, controlId: number, text: string, style: GUIStyle): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, label: string, text: string, style: GUIStyle): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, label: GUIContent, text: string, style: GUIStyle): string
        static DelayedTextField(position: Rect, label: GUIContent, controlId: number, text: string): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param label Optional label to display in front of the int field.
         * @param text The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(position: Rect, text: string, style: GUIStyle): string
        static DelayedTextField(position: Rect, label: string, text: string): string
        static DelayedTextField(position: Rect, label: GUIContent, text: string): string
        /** Makes a delayed text field.
         * @param position Rectangle on the screen to use for the text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         */
        static DelayedTextField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedTextField(position: Rect, text: string): string
        static DelayedTextField(position: Rect, property: SerializedProperty): void
        /** Makes a text area.
         * @param position Rectangle on the screen to use for the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextArea(position: Rect, text: string, style: GUIStyle): string
        /** Makes a text area.
         * @param position Rectangle on the screen to use for the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @returns The text entered by the user. 
         */
        static TextArea(position: Rect, text: string): string
        /** Makes a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param position Rectangle on the screen to use for the label.
         * @param text The text to show.
         * @param style Optional GUIStyle.
         */
        static SelectableLabel(position: Rect, text: string, style: GUIStyle): void
        /** Makes a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param position Rectangle on the screen to use for the label.
         * @param text The text to show.
         * @param style Optional GUIStyle.
         */
        static SelectableLabel(position: Rect, text: string): void
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: string, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: GUIContent, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, password: string, style: GUIStyle): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: string, password: string): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, label: GUIContent, password: string): string
        /** Makes a text field where the user can enter a password.
         * @param position Rectangle on the screen to use for the password field.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @returns The password entered by the user. 
         */
        static PasswordField(position: Rect, password: string): string
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static FloatField(position: Rect, value: number, style: GUIStyle): number
        static FloatField(position: Rect, label: string, value: number): number
        static FloatField(position: Rect, label: GUIContent, value: number): number
        static FloatField(position: Rect, value: number): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(position: Rect, value: number, style: GUIStyle): number
        static DelayedFloatField(position: Rect, label: string, value: number): number
        static DelayedFloatField(position: Rect, label: GUIContent, value: number): number
        /** Makes a delayed text field for entering floats.
         * @param position Rectangle on the screen to use for the float field.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         */
        static DelayedFloatField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedFloatField(position: Rect, value: number): number
        static DelayedFloatField(position: Rect, property: SerializedProperty): void
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static DoubleField(position: Rect, value: number, style: GUIStyle): number
        static DoubleField(position: Rect, label: string, value: number): number
        static DoubleField(position: Rect, label: GUIContent, value: number): number
        static DoubleField(position: Rect, value: number): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering doubles.
         * @param position Rectangle on the screen to use for the double field.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(position: Rect, value: number, style: GUIStyle): number
        static DelayedDoubleField(position: Rect, label: string, value: number): number
        static DelayedDoubleField(position: Rect, label: GUIContent, value: number): number
        static DelayedDoubleField(position: Rect, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, value: number, style: GUIStyle): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: string, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, label: GUIContent, value: number): number
        /** Makes a text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static IntField(position: Rect, value: number): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        /** Makes a delayed text field for entering integers.
         * @param position Rectangle on the screen to use for the int field.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(position: Rect, value: number, style: GUIStyle): number
        static DelayedIntField(position: Rect, label: string, value: number): number
        static DelayedIntField(position: Rect, label: GUIContent, value: number): number
        /** The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field.
         * @param position Rectangle on the screen to use for the int field.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         */
        static DelayedIntField(position: Rect, property: SerializedProperty, label: GUIContent): void
        static DelayedIntField(position: Rect, value: number): number
        static DelayedIntField(position: Rect, property: SerializedProperty): void
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: string, value: number, style: GUIStyle): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: GUIContent, value: number, style: GUIStyle): number
        static LongField(position: Rect, value: number, style: GUIStyle): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: string, value: number): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, label: GUIContent, value: number): number
        /** Makes a text field for entering long integers.
         * @param position Rectangle on the screen to use for the long field.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @returns The value entered by the user. 
         */
        static LongField(position: Rect, value: number): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: string, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: string, selectedIndex: number, displayedOptions: Array<string>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<string>): number
        /** Makes a generic popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup.
         * @param style Optional GUIStyle.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(position: Rect, selectedIndex: number, displayedOptions: Array<GUIContent>): number
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: string, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, selected: Enum, style: GUIStyle): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: string, selected: Enum): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, label: GUIContent, selected: Enum): Enum
        /** Makes an enum popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(position: Rect, selected: Enum): Enum
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>): number
        /**
         * @param position Rectangle on the screen to use for the field.
         * @param property The SerializedProperty to use for the control.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct   mapping of selectedValue to displayedOptions is assumed.
         * @param label Optional label in front of the field.
         */
        static IntPopup(position: Rect, property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, label: GUIContent): void
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>): number
        /** Makes an integer popup selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct mapping of selectedValue to displayedOptions is assumed.
         * @param style Optional GUIStyle.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(position: Rect, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>): number
        /**
         * @param position Rectangle on the screen to use for the field.
         * @param property The SerializedProperty to use for the control.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option. If optionValues a direct   mapping of selectedValue to displayedOptions is assumed.
         * @param label Optional label in front of the field.
         */
        static IntPopup(position: Rect, property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>): void
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: string, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: GUIContent, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, tag: string, style: GUIStyle): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: string, tag: string): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, label: GUIContent, tag: string): string
        /** Makes a tag selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @returns The tag selected by the user. 
         */
        static TagField(position: Rect, tag: string): string
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: string, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: GUIContent, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, layer: number, style: GUIStyle): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: string, layer: number): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, label: GUIContent, layer: number): number
        /** Makes a layer selection field.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @returns The layer selected by the user. 
         */
        static LayerField(position: Rect, layer: number): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: GUIContent, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: string, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: GUIContent, mask: number, displayedOptions: Array<string>): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, label: string, mask: number, displayedOptions: Array<string>): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, mask: number, displayedOptions: Array<string>, style: GUIStyle): number
        /** Makes a field for masks.
         * @param position Rectangle on the screen to use for this control.
         * @param label Label for the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param style Optional GUIStyle.
         * @param displayedOptions A string array containing the labels for each flag.
         * @returns The value modified by the user. 
         */
        static MaskField(position: Rect, mask: number, displayedOptions: Array<string>): number
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string, toggleOnLabelClick: boolean): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, style: GUIStyle): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: string): boolean
        /** Makes a label with a foldout arrow to the left of it.
         * @param position Rectangle on the screen to use for the arrow and label.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Should the label be a clickable part of the control?
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(position: Rect, foldout: boolean, content: GUIContent): boolean
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent, id: number, style: GUIStyle): void
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent, id: number): void
        /** Makes a label for some control.
         * @param totalPosition Rectangle on the screen to use in total for both the label and the control.
         * @param labelPosition Rectangle on the screen to use for the label.
         * @param label Label to show for the control.
         * @param id The unique ID of the control. If none specified, the ID of the following control is used.
         * @param style Optional GUIStyle to use for the label.
         */
        static HandlePrefixLabel(totalPosition: Rect, labelPosition: Rect, label: GUIContent): void
        /** Use this to make a field for a SerializedProperty in the Editor.
         * @param position Rectangle on the screen to use for the property field.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(position: Rect, property: SerializedProperty, label: GUIContent, includeChildren: boolean): boolean
        /** Use this to make a field for a SerializedProperty in the Editor.
         * @param position Rectangle on the screen to use for the property field.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @returns True if the property has children and is expanded and includeChildren was set to false; otherwise false. 
         */
        static PropertyField(position: Rect, property: SerializedProperty, includeChildren: boolean): boolean
        static PropertyField(position: Rect, property: SerializedProperty, label: GUIContent): boolean
        static PropertyField(position: Rect, property: SerializedProperty): boolean
        static BeginFoldoutHeaderGroup(position: Rect, foldout: boolean, content: string, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static BeginFoldoutHeaderGroup(position: Rect, foldout: boolean, content: GUIContent, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static EndFoldoutHeaderGroup(): void
        /** Draws a filled rectangle of color at the specified position and size within the current editor window.
         * @param rect The position and size of the rectangle to draw.
         * @param color The color of the rectange.
         */
        static DrawRect(rect: Rect, color: Color): void
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @param colorSpace Display the gradient and Gradient Editor in this color space.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: GUIContent, gradient: Gradient, hdr: boolean, colorSpace: any): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @param colorSpace Display the gradient and Gradient Editor in this color space.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: GUIContent, gradient: Gradient, hdr: boolean): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @param colorSpace Display the gradient and Gradient Editor in this color space.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: string, gradient: Gradient): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @param colorSpace Display the gradient and Gradient Editor in this color space.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, label: GUIContent, gradient: Gradient): Gradient
        /** Makes a field for editing a Gradient.
         * @param position Rectangle on the screen to use for the field.
         * @param label Optional label to display in front of the field.
         * @param gradient The gradient to edit.
         * @param hdr Display the HDR Gradient Editor.
         * @param colorSpace Display the gradient and Gradient Editor in this color space.
         * @returns The gradient edited by the user. 
         */
        static GradientField(position: Rect, gradient: Gradient): Gradient
        protected constructor()
        /** Makes the following controls give the appearance of editing multiple different values.
         */
        static showMixedValue: boolean
        /** Is the platform-dependent "action" modifier key held down? (Read Only)
         */
        static readonly actionKey: boolean
        /** The indent level of the field labels.
         */
        static indentLevel: number
        static hyperLinkClicked(op: "add" | "remove", fn: (arg1: EditorWindow, arg2: HyperLinkClickedEventArgs) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUIUtility, Texture2D, Vector2, Event, Object, Rect, GUIStyle, GUIContent, Texture, GUISkin, Color, AnimationCurve } from "UnityEngine";
    import { Object as Object1, Array } from "System";
    /** Miscellaneous helper stuff for EditorGUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUIUtility extends GUIUtility {
        static SerializeMainMenuToString(): string
        static SetMenuLocalizationTestMode(onoff: boolean): void
        /** Set icons rendered as part of GUIContent to be rendered at a specific size.
         */
        static SetIconSize(size: Vector2): void
        static SetWantsMouseJumping(wantz: number): void
        /** Check if any enabled camera can render to a particular display.
         * @param displayIndex Display index.
         * @returns True if a camera will render to the display. 
         */
        static IsDisplayReferencedByCameras(displayIndex: number): boolean
        /** Send an input event into the game.
         */
        static QueueGameViewInputEvent(evt: Event): void
        /** Sets a custom icon to associate with a GameObject or MonoScript. The custom icon is displayed in the Scene view and the Inspector.
         * @param obj The GameObject or MonoScript to associate the icon with.
         * @param icon The custom icon to associate with the GameObject or MonoScript. When this value is null, the default icon is restored.
         */
        static SetIconForObject(obj: Object, icon: Texture2D): void
        /** Gets the custom icon associated with an object. Only GameObjects and MonoScripts have associated custom icons.
         * @param obj The GameObject or MonoScript to query
         * @returns Returns the custom icon associated with the object. If there is no custom icon associated with the object, returns null. 
         */
        static GetIconForObject(obj: Object): Texture2D
        static GetMainWindowPosition(): Rect
        /** Sets position of Unity Editor's main window.
         */
        static SetMainWindowPosition(position: Rect): void
        /** Converts a position from point to pixel space.
         * @param rect A GUI position in point space.
         * @returns The same position in pixel space. 
         */
        static PointsToPixels(rect: Rect): Rect
        /** Convert a Rect from point space to pixel space.
         * @param position A GUI rect measured in points.
         * @returns A rect representing the same area in pixels. 
         */
        static PointsToPixels(position: Vector2): Vector2
        /** Convert a Rect from pixel space to point space.
         * @param rect A GUI rect measured in pixels.
         * @returns A rect representing the same area in points. 
         */
        static PixelsToPoints(rect: Rect): Rect
        /** Convert a position from pixel to point space.
         * @param position A GUI position in pixel space.
         * @returns A vector representing the same position in point space. 
         */
        static PixelsToPoints(position: Vector2): Vector2
        static GetFlowLayoutedRects(rect: Rect, style: GUIStyle, horizontalSpacing: number, verticalSpacing: number, items: any): any
        /** Get a texture from its source filename.
         */
        static FindTexture(name: string): Texture2D
        /** Gets the GUIContent from the Unity built-in resources with the given key or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param key The key of the existing GUIContent.
         * @param text The text associated with the GUIContent.text.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         * @param iconName The name of the icon.
         */
        static TrTextContent(key: string, text: string, tooltip: string, icon: Texture): GUIContent
        /** Gets the GUIContent from the Unity built-in resources with the given key or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param key The key of the existing GUIContent.
         * @param text The text associated with the GUIContent.text.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         * @param iconName The name of the icon.
         */
        static TrTextContent(text: string, tooltip: string, icon: Texture): GUIContent
        /** Gets the GUIContent from the Unity built-in resources with the given key or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param key The key of the existing GUIContent.
         * @param text The text associated with the GUIContent.text.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         * @param iconName The name of the icon.
         */
        static TrTextContent(text: string, tooltip: string, iconName: string): GUIContent
        /** Gets the GUIContent from the Unity built-in resources with the given key or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param key The key of the existing GUIContent.
         * @param text The text associated with the GUIContent.text.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         * @param iconName The name of the icon.
         */
        static TrTextContent(text: string, icon: Texture): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, tooltip: string, iconName: string): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, tooltip: string, icon: Texture): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, tooltip: string, messageType: MessageType): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, icon: Texture): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, iconName: string): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The text and the tooltip are localized and loaded with an icon.

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.

If a message type is specified instead of an icon or an icon name, the GUIContent.image is the icon associated with that message type.
         * @param text The text associated with the GUIContent.text.
         * @param icon The icon associated with the GUIContent.image.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param messageType The type of the message to fetch the icon for.
         */
        static TrTextContentWithIcon(text: string, messageType: MessageType): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The icon is loaded with a localized tooltip. 

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         */
        static TrIconContent(iconName: string, tooltip: string): GUIContent
        /** Gets the GUIContent from Unity built-in resources with the given information or creates a GUIContent for a GUI element.

The icon is loaded with a localized tooltip. 

Typically, the icon from `AssetsEditor Default ResourcesIcons` is fetched using the icon name. Only the name of the icon, without the .png extension is needed.
         * @param iconName The name of the icon.
         * @param tooltip The tooltip to display when the cursor hovers over the icon.
         * @param icon The icon to associate with the GUIContent.image.
         */
        static TrIconContent(icon: Texture, tooltip: string): GUIContent
        static TrTempContent(texts: Array<string>, tooltips: Array<string>): Array<GUIContent>
        static TrTempContent(t: string): GUIContent
        static TrTempContent(texts: Array<string>): Array<GUIContent>
        /** Fetch the GUIContent from the Unity builtin resources with the given name.
         * @param name Name of the desired icon.
         * @param text Tooltip for hovering over the icon.
         */
        static IconContent(name: string, text: string): GUIContent
        /** Fetch the GUIContent from the Unity builtin resources with the given name.
         * @param name Name of the desired icon.
         * @param text Tooltip for hovering over the icon.
         */
        static IconContent(name: string): GUIContent
        /** Return a GUIContent object with the name and icon of an Object.
         */
        static ObjectContent(obj: Object, type: any): GUIContent
        /** Does a given class have per-object thumbnails?
         */
        static HasObjectThumbnail(objType: any): boolean
        static GetIconSize(): Vector2
        /** Get one of the built-in GUI skins, which can be the game view, inspector or Scene view skin as chosen by the parameter.
         */
        static GetBuiltinSkin(skin: EditorSkin): GUISkin
        /** Load a required built-in resource.
         */
        static LoadRequired(path: string): Object
        /** Load a built-in resource.
         */
        static Load(path: string): Object
        /** Ping an object in the Scene like clicking it in an inspector.
         * @param obj The object to be pinged.
         */
        static PingObject(obj: Object): void
        /** Ping an object in the Scene like clicking it in an inspector.
         * @param obj The object to be pinged.
         */
        static PingObject(targetInstanceID: number): void
        /** Creates an event that can be sent to another window.
         * @param commandName The command to be sent.
         */
        static CommandEvent(commandName: string): Event
        /** Draw a color swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param color The color to draw.
         */
        static DrawColorSwatch(position: Rect, color: Color): void
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, topFillColor: Color, bottomFillColor: Color, curveRanges: Rect): void
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, topFillColor: Color, bottomFillColor: Color): void
        /** Draw a curve swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param curve The curve to draw.
         * @param property The curve to draw as a SerializedProperty.
         * @param color The color to draw the curve with.
         * @param bgColor The color to draw the background with.
         * @param curveRanges Optional parameter to specify the range of the curve which should be included in swatch.
         */
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Draw a curve swatch.
         * @param position The rectangle to draw the color swatch within.
         * @param curve The curve to draw.
         * @param property The curve to draw as a SerializedProperty.
         * @param color The color to draw the curve with.
         * @param bgColor The color to draw the background with.
         * @param curveRanges Optional parameter to specify the range of the curve which should be included in swatch.
         */
        static DrawCurveSwatch(position: Rect, curve: AnimationCurve, property: SerializedProperty, color: Color, bgColor: Color): void
        /** Draw swatch with a filled region between two SerializedProperty curves.
         */
        static DrawRegionSwatch(position: Rect, property: SerializedProperty, property2: SerializedProperty, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Draw swatch with a filled region between two curves.
         */
        static DrawRegionSwatch(position: Rect, curve: AnimationCurve, curve2: AnimationCurve, color: Color, bgColor: Color, curveRanges: Rect): void
        /** Add a custom mouse pointer to a control.
         * @param position The rectangle the control should be shown within.
         * @param mouse The mouse cursor to use.
         * @param controlID ID of a target control.
         */
        static AddCursorRect(position: Rect, mouse: MouseCursor, controlID: number): void
        /** Add a custom mouse pointer to a control.
         * @param position The rectangle the control should be shown within.
         * @param mouse The mouse cursor to use.
         * @param controlID ID of a target control.
         */
        static AddCursorRect(position: Rect, mouse: MouseCursor): void
        static GetObjectPickerObject(): Object
        static GetObjectPickerControlID(): number
        protected constructor()
        /** Get a white texture.
         */
        static readonly whiteTexture: Texture2D
        /** The system copy buffer.
         */
        static systemCopyBuffer: string
        /** The scale of GUI points relative to screen pixels for the current view

This value is the number of screen pixels per point of interface space. For instance, 2.0 on retina displays. Note that the value may differ from one view to the next if the views are on monitors with different UI scales.
         */
        static readonly pixelsPerPoint: number
        /** Get the height used for a single Editor control such as a one-line EditorGUI.TextField or EditorGUI.Popup.
         */
        static readonly singleLineHeight: number
        /** Get the height used by default for vertical spacing between controls.
         */
        static readonly standardVerticalSpacing: number
        /** Is the user currently using the pro skin? (Read Only)
         */
        static readonly isProSkin: boolean
        /** Is a text field currently editing text?
         */
        static editingTextField: boolean
        /** True if a text field currently has focused and the text in it is selected.
         */
        static readonly textFieldHasSelection: boolean
        /** Is the Editor GUI in hierarchy mode?
         */
        static hierarchyMode: boolean
        /** Is the Editor GUI currently in wide mode?
         */
        static wideMode: boolean
        /** The width of the GUI area for the current EditorWindow or other view. This Property should only be accessed within an OnGUI call.
         */
        static readonly currentViewWidth: number
        /** The width in pixels reserved for labels of Editor GUI controls.
         */
        static labelWidth: number
        /** The minimum width in pixels reserved for the fields of Editor GUI controls.
         */
        static fieldWidth: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { GUIStyle, GUIContent, GUILayoutOption, Object as Object1, Vector2, Vector3, Vector4, Vector2Int, Vector3Int, Rect, RectInt, Bounds, BoundsInt, Color, AnimationCurve, FocusType, Gradient } from "UnityEngine";
    import { EditorTool } from "UnityEditor.EditorTools";
    /** Auto laid out version of EditorGUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorGUILayout extends Object {
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string, style: GUIStyle): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent, style: GUIStyle): boolean
        static Foldout(foldout: boolean, content: string, toggleOnLabelClick: boolean): boolean
        static Foldout(foldout: boolean, content: GUIContent, toggleOnLabelClick: boolean): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: string): boolean
        /** Make a label with a foldout arrow to the left of it.
         * @param foldout The shown foldout state.
         * @param content The label to show.
         * @param style Optional GUIStyle.
         * @param toggleOnLabelClick Specifies whether clicking the label toggles the foldout state. The default value is false. Set to true to include the label in the clickable area.
         * @returns The foldout state selected by the user. If true, you should render sub-objects. 
         */
        static Foldout(foldout: boolean, content: GUIContent): boolean
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string, followingStyle: GUIStyle, labelStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent, followingStyle: GUIStyle, labelStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string, followingStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent, followingStyle: GUIStyle): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: string): void
        /** Make a label in front of some control.
         * @param label Label to show to the left of the control.
         */
        static PrefixLabel(label: GUIContent): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, label2: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, label2: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, label2: string, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, label2: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: string, ...options: GUILayoutOption[]): void
        /** Make a label field. (Useful for showing read-only info.)
         * @param label Label in front of the label field.
         * @param label2 The label to show to the right.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static LabelField(label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a clickable link label.
         * @param label Label of the link.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the link. 
         */
        static LinkButton(label: string, ...options: GUILayoutOption[]): boolean
        /** Make a clickable link label.
         * @param label Label of the link.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the link. 
         */
        static LinkButton(label: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: string, value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: GUIContent, value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: string, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(label: GUIContent, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(value: boolean, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle.
         * @param label Optional label in front of the toggle.
         * @param value The shown state of the toggle.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>

Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The selected state of the toggle. 
         */
        static Toggle(value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: string, value: boolean, labelStyle: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: GUIContent, value: boolean, labelStyle: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: string, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a toggle field where the toggle is to the left and the label immediately to the right of it.
         * @param label Label to display next to the toggle.
         * @param value The value to edit.
         * @param labelStyle Optional GUIStyle to use for the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ToggleLeft(label: GUIContent, value: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: string, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: GUIContent, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: string, text: string, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(label: GUIContent, text: string, ...options: GUILayoutOption[]): string
        /** Make a text field.
         * @param label Optional label to display in front of the text field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: string, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: GUIContent, text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: string, text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(label: GUIContent, text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedTextField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field.
         * @param label Optional label to display in front of the int field.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the text field. 
         */
        static DelayedTextField(text: string, ...options: GUILayoutOption[]): string
        /** Make a delayed text field.
         * @param property The text property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedTextField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text area.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextArea(text: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text area.
         * @param text The text to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The text entered by the user. 
         */
        static TextArea(text: string, ...options: GUILayoutOption[]): string
        /** Make a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param text The text to show.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static SelectableLabel(text: string, style: GUIStyle, ...options: GUILayoutOption[]): void
        /** Make a selectable label field. (Useful for showing read-only info that can be copy-pasted.)
         * @param text The text to show.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static SelectableLabel(text: string, ...options: GUILayoutOption[]): void
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: string, password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: GUIContent, password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(password: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: string, password: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(label: GUIContent, password: string, ...options: GUILayoutOption[]): string
        /** Make a text field where the user can enter a password.
         * @param label Optional label to display in front of the password field.
         * @param password The password to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The password entered by the user. 
         */
        static PasswordField(password: string, ...options: GUILayoutOption[]): string
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering float values.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static FloatField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedFloatField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field for entering floats.
         * @param label Optional label to display in front of the float field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the float field. 
         */
        static DelayedFloatField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering floats.
         * @param property The float property to edit.
         * @param label Optional label to display in front of the float field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedFloatField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering double values.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static DoubleField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering doubles.
         * @param label Optional label to display in front of the double field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options 
          An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
          Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
          GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
        
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the double field. 
         */
        static DelayedDoubleField(value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static IntField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedIntField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a delayed text field for entering integers.
         * @param label Optional label to display in front of the int field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. Note that the return value will not change until the user has pressed enter or focus is moved away from the int field. 
         */
        static DelayedIntField(value: number, ...options: GUILayoutOption[]): number
        /** Make a delayed text field for entering integers.
         * @param property The int property to edit.
         * @param label Optional label to display in front of the int field. Pass GUIContent.none to hide label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static DelayedIntField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: string, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: GUIContent, value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(value: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: string, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(label: GUIContent, value: number, ...options: GUILayoutOption[]): number
        /** Make a text field for entering long integers.
         * @param label Optional label to display in front of the long field.
         * @param value The value to edit.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static LongField(value: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(label: string, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(label: GUIContent, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, label: string, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static Slider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change a value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static Slider(property: SerializedProperty, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(label: string, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(label: GUIContent, value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, label: string, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param value The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value that has been set by the user. 
         */
        static IntSlider(value: number, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): number
        /** Make a slider the user can drag to change an integer value between a min and a max.
         * @param label Optional label in front of the slider.
         * @param property The value the slider shows. This determines the position of the draggable thumb.
         * @param leftValue The value at the left end of the slider.
         * @param rightValue The value at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntSlider(property: SerializedProperty, leftValue: number, rightValue: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(label: string, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(label: GUIContent, minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a special slider the user can use to specify a range between a min and a max.
         * @param label Optional label in front of the slider.
         * @param minValue The lower value of the range the slider shows, passed by reference.
         * @param maxValue The upper value at the range the slider shows, passed by reference.
         * @param minLimit The limit at the left end of the slider.
         * @param maxLimit The limit at the right end of the slider.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static MinMaxSlider(minValue: jsb.Ref<number>, maxValue: jsb.Ref<number>, minLimit: number, maxLimit: number, ...options: GUILayoutOption[]): void
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: string, selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<GUIContent>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: string, selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(label: GUIContent, selectedIndex: number, displayedOptions: Array<GUIContent>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a generic popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedIndex The index of the option the field shows.
         * @param displayedOptions An array with the options shown in the popup. Use a slash to separate sub-items (ex. Menu/SubMenu). Use null or an empty string to add a separator. "
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The index of the option that has been selected by the user. 
         */
        static Popup(selectedIndex: number, displayedOptions: Array<GUIContent>, ...options: GUILayoutOption[]): number
        static EnumPopup(label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        static EnumPopup(label: GUIContent, selected: Enum, checkEnabled: (arg: Enum) => boolean, includeObsolete: boolean, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: string, selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: GUIContent, selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(selected: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: string, selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(label: GUIContent, selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an enum popup selection field.
         * @param label Optional label in front of the field.
         * @param selected The enum option the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @param checkEnabled Method called for each Enum value displayed. The specified method should return true if the option can be selected, false otherwise.
         * @returns The enum option that has been selected by the user. 
         */
        static EnumPopup(selected: Enum, ...options: GUILayoutOption[]): Enum
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: string, selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(label: GUIContent, selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param property The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param label Optional label in front of the field.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntPopup(property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<string>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param label Optional label in front of the field.
         * @param selectedValue The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value of the option that has been selected by the user. 
         */
        static IntPopup(selectedValue: number, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): number
        /** Make an integer popup selection field.
         * @param property The value of the option the field shows.
         * @param displayedOptions An array with the displayed options the user can choose from.
         * @param optionValues An array with the values for each option.
         * @param label Optional label in front of the field.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static IntPopup(property: SerializedProperty, displayedOptions: Array<GUIContent>, optionValues: Array<number>, ...options: GUILayoutOption[]): void
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: string, tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: GUIContent, tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(tag: string, style: GUIStyle, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: string, tag: string, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(label: GUIContent, tag: string, ...options: GUILayoutOption[]): string
        /** Make a tag selection field.
         * @param label Optional label in front of the field.
         * @param tag The tag the field shows.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The tag selected by the user. 
         */
        static TagField(tag: string, ...options: GUILayoutOption[]): string
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: string, layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: GUIContent, layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(layer: number, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: string, layer: number, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(label: GUIContent, layer: number, ...options: GUILayoutOption[]): number
        /** Make a layer selection field.
         * @param label Optional label in front of the field.
         * @param layer The layer shown in the field.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The layer selected by the user. 
         */
        static LayerField(layer: number, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: GUIContent, mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: string, mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: GUIContent, mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(label: string, mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(mask: number, displayedOptions: Array<string>, style: GUIStyle, ...options: GUILayoutOption[]): number
        /** Make a field for masks.
         * @param label Prefix label of the field.
         * @param mask The current mask to display.
         * @param displayedOption A string array containing the labels for each flag.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value modified by the user. 
         */
        static MaskField(mask: number, displayedOptions: Array<string>, ...options: GUILayoutOption[]): number
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, includeObsolete: boolean, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: string, enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, includeObsolete: boolean, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(enumValue: Enum, style: GUIStyle, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: string, enumValue: Enum, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(label: GUIContent, enumValue: Enum, ...options: GUILayoutOption[]): Enum
        /** Displays a menu with an option for every value of the enum type when clicked.
         * @param label Optional label to display in front of the enum flags field.
         * @param enumValue Enum flags value.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param includeObsolete Set to true to include Enum values with ObsoleteAttribute. Set to false to exclude Enum values with ObsoleteAttribute.
         * @returns The enum flags value modified by the user. This is a selection BitMask where each bit represents an Enum value index. (Note this returned value is not itself an Enum). 
         */
        static EnumFlagsField(enumValue: Enum, ...options: GUILayoutOption[]): Enum
        static ObjectField(label: string, obj: Object1, objType: any, targetBeingEdited: Object1, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(label: string, obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        static ObjectField(label: GUIContent, obj: Object1, objType: any, targetBeingEdited: Object1, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(label: GUIContent, obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        static ObjectField(obj: Object1, objType: any, targetBeingEdited: Object1, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param label Optional label in front of the field.
         * @param obj The object the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param allowSceneObjects Allow assigning Scene objects. See Description for more info.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The object that has been set by the user. 
         */
        static ObjectField(obj: Object1, objType: any, allowSceneObjects: boolean, ...options: GUILayoutOption[]): Object1
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, objType: any, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, objType: any, ...options: GUILayoutOption[]): void
        /** Make a field to receive any object type.
         * @param property The object reference property the field shows.
         * @param objType The type of the objects that can be assigned.
         * @param label Optional label in front of the field. Pass GUIContent.none to hide the label.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static ObjectField(property: SerializedProperty, ...options: GUILayoutOption[]): void
        /** Make an X & Y field for entering a Vector2.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
         * @returns The value entered by the user. 
         */
        static Vector2Field(label: string, value: Vector2, ...options: GUILayoutOption[]): Vector2
        /** Make an X & Y field for entering a Vector2.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
         * @returns The value entered by the user. 
         */
        static Vector2Field(label: GUIContent, value: Vector2, ...options: GUILayoutOption[]): Vector2
        /** Make an X, Y & Z field for entering a Vector3.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3Field(label: string, value: Vector3, ...options: GUILayoutOption[]): Vector3
        /** Make an X, Y & Z field for entering a Vector3.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3Field(label: GUIContent, value: Vector3, ...options: GUILayoutOption[]): Vector3
        /** Make an X, Y, Z & W field for entering a Vector4.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector4Field(label: string, value: Vector4, ...options: GUILayoutOption[]): Vector4
        static Vector4Field(label: GUIContent, value: Vector4, ...options: GUILayoutOption[]): Vector4
        /** Make an X & Y integer field for entering a Vector2Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(label: string, value: Vector2Int, ...options: GUILayoutOption[]): Vector2Int
        /** Make an X & Y integer field for entering a Vector2Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector2IntField(label: GUIContent, value: Vector2Int, ...options: GUILayoutOption[]): Vector2Int
        /** Make an X, Y & Z integer field for entering a Vector3Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(label: string, value: Vector3Int, ...options: GUILayoutOption[]): Vector3Int
        /** Make an X, Y & Z integer field for entering a Vector3Int.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static Vector3IntField(label: GUIContent, value: Vector3Int, ...options: GUILayoutOption[]): Vector3Int
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(label: string, value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(label: GUIContent, value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a Rect.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectField(value: Rect, ...options: GUILayoutOption[]): Rect
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(label: string, value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(label: GUIContent, value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make an X, Y, W & H field for entering a RectInt.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static RectIntField(value: RectInt, ...options: GUILayoutOption[]): RectInt
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(label: string, value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(label: GUIContent, value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Center & Extents field for entering a Bounds.
         * @param label Label to display above the field.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsField(value: Bounds, ...options: GUILayoutOption[]): Bounds
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(label: string, value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(label: GUIContent, value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make Position & Size field for entering a BoundsInt.
         * @param label Make Position & Size field for entering a Bounds.
         * @param value The value to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The value entered by the user. 
         */
        static BoundsIntField(value: BoundsInt, ...options: GUILayoutOption[]): BoundsInt
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: GUIContent, value: Color, showEyedropper: boolean, showAlpha: boolean, hdr: boolean, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: string, value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(label: GUIContent, value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for selecting a Color.
         * @param label Optional label to display in front of the field.
         * @param value The color to edit.
         * @param showEyedropper If true, the color picker should show the eyedropper control. If false, don't show it.
         * @param showAlpha If true, allow the user to set an alpha value for the color. If false, hide the alpha component.
         * @param hdr If true, treat the color as an HDR value. If false, treat it as a standard LDR value.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The color selected by the user. 
         */
        static ColorField(value: Color, ...options: GUILayoutOption[]): Color
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: string, value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: GUIContent, value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(property: SerializedProperty, color: Color, ranges: Rect, label: GUIContent, ...options: GUILayoutOption[]): void
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(value: AnimationCurve, color: Color, ranges: Rect, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param property The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @param label Optional label to display in front of the field. Pass [[GUIContent.none] to hide the label.
         */
        static CurveField(property: SerializedProperty, color: Color, ranges: Rect, ...options: GUILayoutOption[]): void
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: string, value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(label: GUIContent, value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        /** Make a field for editing an AnimationCurve.
         * @param label Optional label to display in front of the field.
         * @param value The curve to edit.
         * @param color The color to show the curve with.
         * @param ranges Optional rectangle that the curve is restrained within.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The curve edited by the user. 
         */
        static CurveField(value: AnimationCurve, ...options: GUILayoutOption[]): AnimationCurve
        static InspectorTitlebar(foldout: boolean, targetObj: Object1, expandable: boolean): boolean
        static InspectorTitlebar(foldout: boolean, targetObjs: Array<Object1>, expandable: boolean): boolean
        /** Make an inspector-window-like titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) or objects that the titlebar is for.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(foldout: boolean, targetObj: Object1): boolean
        /** Make an inspector-window-like titlebar.
         * @param foldout The foldout state shown with the arrow.
         * @param targetObj The object (for example a component) or objects that the titlebar is for.
         * @returns The foldout state selected by the user. 
         */
        static InspectorTitlebar(foldout: boolean, targetObjs: Array<Object1>): boolean
        static InspectorTitlebar(foldout: boolean, editor: Editor): boolean
        static InspectorTitlebar(targetObjs: Array<Object1>): void
        /** Make a help box with a message to the user.
         * @param message The message text.
         * @param type The type of message.
         * @param wide If true, the box will cover the whole width of the window; otherwise it will cover the controls part only.
         */
        static HelpBox(message: string, type: MessageType, wide: boolean): void
        /** Make a help box with a message to the user.
         * @param message The message text.
         * @param type The type of message.
         * @param wide If true, the box will cover the whole width of the window; otherwise it will cover the controls part only.
         */
        static HelpBox(message: string, type: MessageType): void
        static HelpBox(content: GUIContent, wide: boolean): void
        /** Make a small space between the previous control and the following.
         * @param width The width of the empty space. Use this for horizontal layout.
         * @param expand Option passed to enable or disable horizontal expansion.
         */
        static Space(width: number, expand: boolean): void
        /** Make a small space between the previous control and the following.
         * @param width The width of the empty space. Use this for horizontal layout.
         * @param expand Option passed to enable or disable horizontal expansion.
         */
        static Space(width: number): void
        static Space(): void
        static Separator(): void
        /** Begin a vertical group with a toggle to enable or disable all the controls within at once.
         * @param label Label to show above the toggled controls.
         * @param toggle Enabled state of the toggle group.
         * @returns The enabled state selected by the user. 
         */
        static BeginToggleGroup(label: string, toggle: boolean): boolean
        /** Begin a vertical group with a toggle to enable or disable all the controls within at once.
         * @param label Label to show above the toggled controls.
         * @param toggle Enabled state of the toggle group.
         * @returns The enabled state selected by the user. 
         */
        static BeginToggleGroup(label: GUIContent, toggle: boolean): boolean
        static EndToggleGroup(): void
        /** Begin a horizontal group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Begin a horizontal group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout
        properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginHorizontal(...options: GUILayoutOption[]): Rect
        static EndHorizontal(): void
        /** Begin a vertical group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties.
        Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Begin a vertical group and get its rect back.
         * @param style Optional GUIStyle.
         * @param options An optional list of layout options that specify extra layout properties.
        Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static BeginVertical(...options: GUILayoutOption[]): Rect
        static EndVertical(): void
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param style Optional GUIStyle to use for the background.
         * @param background Optional GUIStyle to use for the background.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param style Optional GUIStyle to use for the background.
         * @param background Optional GUIStyle to use for the background.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param style Optional GUIStyle to use for the background.
         * @param background Optional GUIStyle to use for the background.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param style Optional GUIStyle to use for the background.
         * @param background Optional GUIStyle to use for the background.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, style: GUIStyle, ...options: GUILayoutOption[]): Vector2
        /** Begin an automatically laid out scrollview.
         * @param scrollPosition The position to use display.
         * @param style Optional GUIStyle to use for the background.
         * @param background Optional GUIStyle to use for the background.
         * @param alwayShowHorizontal Optional parameter to always show the horizontal scrollbar. If false or left out, it is only shown when the content inside the ScrollView is wider than the scrollview itself.
         * @param alwayShowVertical Optional parameter to always show the vertical scrollbar. If false or left out, it is only shown when content inside the ScrollView is taller than the scrollview itself.
         * @param horizontalScrollbar Optional GUIStyle to use for the horizontal scrollbar. If left out, the horizontalScrollbar style from the current GUISkin is used.
         * @param verticalScrollbar Optional GUIStyle to use for the vertical scrollbar. If left out, the verticalScrollbar style from the current GUISkin is used.
         * @returns The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example. 
         */
        static BeginScrollView(scrollPosition: Vector2, ...options: GUILayoutOption[]): Vector2
        static EndScrollView(): void
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children, is expanded, and includeChildren is set to false; otherwise false. You can use it to determine the isExpanded state of the property and customize the rendering of children if necessary. 
         */
        static PropertyField(property: SerializedProperty, label: GUIContent, includeChildren: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children, is expanded, and includeChildren is set to false; otherwise false. You can use it to determine the isExpanded state of the property and customize the rendering of children if necessary. 
         */
        static PropertyField(property: SerializedProperty, label: GUIContent, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children, is expanded, and includeChildren is set to false; otherwise false. You can use it to determine the isExpanded state of the property and customize the rendering of children if necessary. 
         */
        static PropertyField(property: SerializedProperty, includeChildren: boolean, ...options: GUILayoutOption[]): boolean
        /** Make a field for SerializedProperty.
         * @param property The SerializedProperty to make a field for.
         * @param label Optional label to use. If not specified the label of the property itself is used. Use GUIContent.none to not display a label at all.
         * @param includeChildren If true the property including children is drawn; otherwise only the control itself (such as only a foldout but nothing below it).
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns True if the property has children, is expanded, and includeChildren is set to false; otherwise false. You can use it to determine the isExpanded state of the property and customize the rendering of children if necessary. 
         */
        static PropertyField(property: SerializedProperty, ...options: GUILayoutOption[]): boolean
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, height: number, style: GUIStyle, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, height: number, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(hasLabel: boolean, ...options: GUILayoutOption[]): Rect
        /** Get a rect for an Editor control.
         * @param hasLabel Optional boolean to specify if the control has a label. Default is true.
         * @param height The height in pixels of the control. Default is EditorGUIUtility.singleLineHeight.
         * @param style Optional GUIStyle to use for the control.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         */
        static GetControlRect(...options: GUILayoutOption[]): Rect
        /** Begins a group that can be be hidden/shown and the transition will be animated.
         * @param value A value between 0 and 1, 0 being hidden, and 1 being fully visible.
         * @returns If the group is visible or not. 
         */
        static BeginFadeGroup(value: number): boolean
        static EndFadeGroup(): void
        static BeginBuildTargetSelectionGrouping(): BuildTargetGroup
        static EndBuildTargetSelectionGrouping(): void
        /** Make a button that reacts to mouse down, for displaying your own dropdown content.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(content: GUIContent, focusType: FocusType, style: GUIStyle, ...options: GUILayoutOption[]): boolean
        /** Make a button that reacts to mouse down, for displaying your own dropdown content.
         * @param content Text, image and tooltip for this button.
         * @param focusType Whether the button should be selectable by keyboard or not.
         * @param style Optional style to use.
         * @param options An optional list of layout options that specify extra layouting properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns true when the user clicks the button. 
         */
        static DropdownButton(content: GUIContent, focusType: FocusType, ...options: GUILayoutOption[]): boolean
        static BeginFoldoutHeaderGroup(foldout: boolean, content: string, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static BeginFoldoutHeaderGroup(foldout: boolean, content: GUIContent, style: GUIStyle, menuAction: (obj: Rect) => void, menuIcon: GUIStyle): boolean
        static EndFoldoutHeaderGroup(): void
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: GUIContent, value: Gradient, hdr: boolean, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: string, value: Gradient, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(label: GUIContent, value: Gradient, ...options: GUILayoutOption[]): Gradient
        /** Make a field for editing a Gradient.
         * @param label Optional label to display in front of the field.
         * @param value The gradient to edit.
         * @param options An optional list of layout options that specify extra layout properties. Any values passed in here will override settings defined by the style.<br>
Additional resources: GUILayout.Width, GUILayout.Height, GUILayout.MinWidth, GUILayout.MaxWidth, GUILayout.MinHeight,
GUILayout.MaxHeight, GUILayout.ExpandWidth, GUILayout.ExpandHeight.
         * @returns The gradient edited by the user. 
         */
        static GradientField(value: Gradient, ...options: GUILayoutOption[]): Gradient
        static Knob(knobSize: Vector2, value: number, minValue: number, maxValue: number, unit: string, backgroundColor: Color, activeColor: Color, showValue: boolean, ...options: GUILayoutOption[]): number
        /** Makes a toolbar populated with the collection of editor tools that match the EditorToolAttribute of the target object.
         * @param target The target object.
         * @param content An optional prefix label.
         */
        static EditorToolbarForTarget(content: GUIContent, target: Object1): void
        /** Makes a toolbar populated with the collection of editor tools that match the EditorToolAttribute of the target object.
         * @param target The target object.
         * @param content An optional prefix label.
         */
        static EditorToolbarForTarget(target: Object1): void
        /** Makes a toolbar populated with the collection of EditorToolContext that match the EditorToolContextAttribute.targetType of the target object.
         * @param content An optional prefix label. Pass null to omit the label.
         * @param target The target object. This may be either a Component or an Editor.
         */
        static ToolContextToolbarForTarget(content: GUIContent, target: Object1): void
        /** Makes a toolbar populated with the specified collection of editor tools.
         * @param tools The collection of editor tools for the toolbar.
         */
        static EditorToolbar(...tools: EditorTool[]): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    /** Main Application class.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorApplication extends Object {
        /** Open another project.
         * @param projectPath The path of a project to open.
         * @param args Arguments to pass to command line.
         */
        static OpenProject(projectPath: string, ...args: string[]): void
        static EnterPlaymode(): void
        static ExitPlaymode(): void
        static Step(): void
        static LockReloadAssemblies(): void
        static UnlockReloadAssemblies(): void
        /** Invokes the menu item in the specified path.
         */
        static ExecuteMenuItem(menuItemPath: string): boolean
        /** Sets the path that Unity should store the current temporary project at, when the project is closed.
         * @param path The path that the current temporary project should be relocated to when closing it.
         */
        static SetTemporaryProjectKeepPath(path: string): void
        /** Exit the Unity editor application.
         */
        static Exit(returnValue: number): void
        static QueuePlayerLoopUpdate(): void
        static Beep(): void
        static RepaintProjectWindow(): void
        static RepaintAnimationWindow(): void
        static RepaintHierarchyWindow(): void
        static DirtyHierarchyWindowSorting(): void
        protected constructor()
        /** Whether the Editor is in Play mode.
         */
        static isPlaying: boolean
        /** Whether the Editor is either currently in Play mode or about to switch to it. (Read Only)
         */
        static readonly isPlayingOrWillChangePlaymode: boolean
        /** Whether the Editor is paused.
         */
        static isPaused: boolean
        /** Is editor currently compiling scripts? (Read Only)
         */
        static readonly isCompiling: boolean
        /** True if the Editor is currently refreshing the AssetDatabase.
         */
        static readonly isUpdating: boolean
        /** Is editor currently connected to Unity Remote 4 client app.
         */
        static readonly isRemoteConnected: boolean
        /** Path to the Unity editor contents folder. (Read Only)
         */
        static readonly applicationContentsPath: string
        /** Gets the path to the Unity Editor application. (Read Only)
         */
        static readonly applicationPath: string
        /** Returns true if the current project was created as a temporary project.
         */
        static readonly isTemporaryProject: boolean
        /** The time since the editor was started. (Read Only)
         */
        static readonly timeSinceStartup: number
        static wantsToQuit(op: "add" | "remove", fn: () => boolean): void
        static quitting(op: "add" | "remove", fn: () => void): void
        static hierarchyChanged(op: "add" | "remove", fn: () => void): void
        static projectChanged(op: "add" | "remove", fn: () => void): void
        static pauseStateChanged(op: "add" | "remove", fn: (obj: PauseState) => void): void
        static playModeStateChanged(op: "add" | "remove", fn: (obj: PlayModeStateChange) => void): void
        static projectWindowItemOnGUI(op: "get"): (guid: string, selectionRect: Rect) => void
        static projectWindowItemOnGUI(op: "add" | "remove" | "set", fn?: (guid: string, selectionRect: Rect) => void): void
        static projectWindowItemOnGUI(op: "add" | "remove" | "set" | "get", fn?: (guid: string, selectionRect: Rect) => void): (guid: string, selectionRect: Rect) => void | void
        static hierarchyWindowItemOnGUI(op: "get"): (instanceID: number, selectionRect: Rect) => void
        static hierarchyWindowItemOnGUI(op: "add" | "remove" | "set", fn?: (instanceID: number, selectionRect: Rect) => void): void
        static hierarchyWindowItemOnGUI(op: "add" | "remove" | "set" | "get", fn?: (instanceID: number, selectionRect: Rect) => void): (instanceID: number, selectionRect: Rect) => void | void
        static update(op: "get"): () => void
        static update(op: "add" | "remove" | "set", fn?: () => void): void
        static update(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static delayCall(op: "get"): () => void
        static delayCall(op: "add" | "remove" | "set", fn?: () => void): void
        static delayCall(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static searchChanged(op: "get"): () => void
        static searchChanged(op: "add" | "remove" | "set", fn?: () => void): void
        static searchChanged(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static modifierKeysChanged(op: "get"): () => void
        static modifierKeysChanged(op: "add" | "remove" | "set", fn?: () => void): void
        static modifierKeysChanged(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static contextualPropertyMenu(op: "get"): (menu: GenericMenu, property: SerializedProperty) => void
        static contextualPropertyMenu(op: "add" | "remove" | "set", fn?: (menu: GenericMenu, property: SerializedProperty) => void): void
        static contextualPropertyMenu(op: "add" | "remove" | "set" | "get", fn?: (menu: GenericMenu, property: SerializedProperty) => void): (menu: GenericMenu, property: SerializedProperty) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Object, GUIContent, Texture2D, Rect, GUIStyle } from "UnityEngine";
    import { Array, Object as Object1 } from "System";
    /** Derive from this base class to create a custom inspector or editor for your custom object.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Editor extends ScriptableObject {
        constructor()
        DrawDefaultInspector(): boolean
        Repaint(): void
        OnInspectorGUI(): void
        CreateInspectorGUI(): any
        RequiresConstantRepaint(): boolean
        DrawHeader(): void
        HasPreviewGUI(): boolean
        GetPreviewTitle(): GUIContent
        /** Override this method if you want to render a static preview.
         * @param assetPath The asset to operate on.
         * @param subAssets An array of all Assets at assetPath.
         * @param width Width of the created texture.
         * @param height Height of the created texture.
         * @returns Generated texture or null. 
         */
        RenderStaticPreview(assetPath: string, subAssets: Array<Object>, width: number, height: number): Texture2D
        /** Creates a custom preview for the preview area of the Inspector, the headers of the primary Editor, and the object selector.

You must implement Editor.HasPreviewGUI for this method to be called.
         * @param r The rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnPreviewGUI(r: Rect, background: GUIStyle): void
        /** Implement to create your own interactive custom preview. Interactive custom previews are used in the preview area of the inspector and the object selector.
         * @param r Rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnInteractivePreviewGUI(r: Rect, background: GUIStyle): void
        OnPreviewSettings(): void
        GetInfoString(): string
        /** The first entry point for Preview Drawing.
         * @param previewArea The available area to draw the preview.
         */
        DrawPreview(previewArea: Rect): void
        ReloadPreviewInstances(): void
        UseDefaultMargins(): boolean
        Initialize(targets: Array<Object>): void
        Cleanup(): void
        MoveNextTarget(): boolean
        ResetTarget(): void
        /** Make a custom editor for targetObject or targetObjects with a context object.
         */
        static CreateEditorWithContext(targetObjects: Array<Object>, context: Object, editorType: any): Editor
        static CreateEditorWithContext(targetObjects: Array<Object>, context: Object): Editor
        /** Creates a cached editor using a context object.
         */
        static CreateCachedEditorWithContext(targetObject: Object, context: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** Creates a cached editor using a context object.
         */
        static CreateCachedEditorWithContext(targetObjects: Array<Object>, context: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** On return previousEditor is an editor for targetObject or targetObjects. The function either returns if the editor is already tracking the objects, or destroys the previous editor and creates a new one.
         * @param obj The object the editor is tracking.
         * @param editorType The requested editor type. Set to null for the default editor for the object.
         * @param previousEditor The previous editor for the object. After returning from CreateCachedEditor previousEditor is an editor for the targetObject or targetObjects.
         * @param objects The objects the editor is tracking.
         */
        static CreateCachedEditor(targetObject: Object, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** On return previousEditor is an editor for targetObject or targetObjects. The function either returns if the editor is already tracking the objects, or destroys the previous editor and creates a new one.
         * @param obj The object the editor is tracking.
         * @param editorType The requested editor type. Set to null for the default editor for the object.
         * @param previousEditor The previous editor for the object. After returning from CreateCachedEditor previousEditor is an editor for the targetObject or targetObjects.
         * @param objects The objects the editor is tracking.
         */
        static CreateCachedEditor(targetObjects: Array<Object>, editorType: any, previousEditor: jsb.Ref<Editor>): void
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObject: Object, editorType: any): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObjects: Array<Object>, editorType: any): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObject: Object): Editor
        /** Make a custom editor for targetObject or targetObjects.
         * @param objects All objects must be of the same type.
         */
        static CreateEditor(targetObjects: Array<Object>): Editor
        /** Draws the inspector GUI with a foldout header for target.
         * @param target The object to display the Inspector for.
         * @param editor The reference to a variable of type Editor.
         */
        static DrawFoldoutInspector(target: Object, editor: jsb.Ref<Editor>): void
        /** The object being inspected.
         */
        target: Object
        /** An array of all the object being inspected.
         */
        readonly targets: Array<Object>
        /** A SerializedObject representing the object or objects being inspected.
         */
        readonly serializedObject: SerializedObject
        static finishedDefaultHeaderGUI(op: "add" | "remove", fn: (obj: Editor) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Vector2, GUIContent, Rect, Event } from "UnityEngine";
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    import { Overlay } from "UnityEditor.Overlays";
    /** Derive from this class to create an editor window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorWindow extends ScriptableObject {
        constructor()
        BeginWindows(): void
        EndWindows(): void
        /** Show a notification message.
         * @param notification The contents of the notification message.
         * @param fadeoutWait The duration the notification is displayed. Measured in seconds.
         */
        ShowNotification(notification: GUIContent, fadeoutWait: number): void
        /** Show a notification message.
         * @param notification The contents of the notification message.
         * @param fadeoutWait The duration the notification is displayed. Measured in seconds.
         */
        ShowNotification(notification: GUIContent): void
        RemoveNotification(): void
        ShowTab(): void
        Focus(): void
        ShowUtility(): void
        ShowPopup(): void
        ShowModalUtility(): void
        /** Shows a window with dropdown behaviour and styling.
         * @param buttonRect The button from which the position of the window will be determined (see description).
         * @param windowSize The initial size of the window.
         */
        ShowAsDropDown(buttonRect: Rect, windowSize: Vector2): void
        /** Show the EditorWindow window.
         * @param immediateDisplay Immediately display Show.
         */
        Show(immediateDisplay: boolean): void
        Show(): void
        ShowAuxWindow(): void
        ShowModal(): void
        SaveChanges(): void
        DiscardChanges(): void
        Close(): void
        Repaint(): void
        /** Sends an Event to a window.
         */
        SendEvent(e: Event): boolean
        GetExtraPaneTypes(): any
        /** Get an Overlay with matching ID from an EditorWindow canvas.
         * @param id ID of the overlay to retrieve.
         * @param match Contains the overlay with matching id, or null if no matching overlay was found.
         * @returns Returns true if the overlay was found, false otherwise. 
         */
        TryGetOverlay(id: string, match: jsb.Out<Overlay>): boolean
        /** Returns the first EditorWindow of type windowType which is currently on the screen.
         * @param windowType The type of the window. Must derive from EditorWindow.
         * @param utility Set this to true, to create a floating utility window, false to create a normal window.
         * @param title If GetWindow creates a new window, it will get this title. If this value is null, use the class name as title.
         * @param focus Whether to give the window focus, if it already exists. (If GetWindow creates a new window, it will always get focus).
         * @returns An EditorWindow instance of windowType. 
         */
        static GetWindow<T extends EditorWindow>(type: { new(): T }): T
        /** Focuses the first found EditorWindow of specified type if it is open.
         * @param windowType The type of the window. Must derive from EditorWindow.
         */
        static FocusWindowIfItsOpen(t: any): void
        static CreateWindow<T extends EditorWindow>(type: { new(): T }, ...desiredDockNextTo: any[]): T
        static CreateWindow<T extends EditorWindow>(type: { new(): T }, title: string, ...desiredDockNextTo: any[]): T
        /** Retrieves the root visual element of this window hierarchy.
         */
        readonly rootVisualElement: any
        /** Checks whether MouseMove events are received in the GUI in this Editor window.
         */
        wantsMouseMove: boolean
        /** Checks whether MouseEnterWindow and MouseLeaveWindow events are received in the GUI in this Editor window.
         */
        wantsMouseEnterLeaveWindow: boolean
        /** Specifies whether a layout pass is performed before all user events (for example, EventType.MouseDown or EventType, KeyDown), or is only performed before repaint events.
         */
        wantsLessLayoutEvents: boolean
        /** Does the window automatically repaint whenever the Scene has changed?
         */
        autoRepaintOnSceneChange: boolean
        /** Whether or not this window is maximized?
         */
        maximized: boolean
        /** Returns true if EditorWindow is focused.
         */
        readonly hasFocus: boolean
        /** Returns true if EditorWindow is docked.
         */
        readonly docked: boolean
        /** The EditorWindow which currently has keyboard focus. (Read Only)
         */
        static readonly focusedWindow: EditorWindow
        /** The EditorWindow currently under the mouse cursor. (Read Only)
         */
        static readonly mouseOverWindow: EditorWindow
        /** This property specifies whether the Editor prompts the user to save or discard unsaved changes before the window closes.
         */
        readonly hasUnsavedChanges: boolean
        /** The message that displays to the user if they are prompted to save
         */
        readonly saveChangesMessage: string
        /** The minimum size of this window when it is floating or modal. The minimum size is not used when the window is docked.
         */
        minSize: Vector2
        /** The maximum size of this window when it is floating or modal. The maximum size is not used when the window is docked.
         */
        maxSize: Vector2
        /** The GUIContent used for drawing the title of EditorWindows.
         */
        titleContent: GUIContent
        depthBufferBits: number
        /** The desired position of the window in screen space.
         */
        position: Rect
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class HotfixTest2 extends Object {
        constructor()
        CallByRef(v: jsb.Out<number>): void
        Foo(x: number): number
    }
}
declare module "global" {
    import * as jsb from "jsb";
    interface MyInterface {
        Foo(): void
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class MyClass extends Object implements MyInterface {
        constructor()
        Foo(): void
        static GetMyInterface(): MyInterface
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Vector3, Vector2 } from "UnityEngine";
    import { Array, ValueType } from "System";
    class NoNamespaceClass extends NoNamespaceBase {
        constructor()
        static V1(v: Vector3): void
        static V1(v: Vector2): void
        static Moo(): void
        static MakeBytes(): Array<jsb.byte>
        static TestBytes(test: Array<jsb.byte>): Array<jsb.byte>
        static TestOut(x: jsb.Out<number>, y: number, z: jsb.Out<number>): void
        static TestOut(x: jsb.Out<string>, y: number, z: jsb.Out<string>): void
        static TestRefOut(g: jsb.Ref<number>, x: jsb.Out<number>, y: number, z: jsb.Out<number>): void
        static TestNullable(x: jsb.Nullable<number>, y: jsb.Nullable<number>): jsb.Nullable<number>
        static TestNullable(xy: jsb.Nullable<Vector2>, g: jsb.Ref<jsb.Nullable<number>>): jsb.Nullable<number>
        static TestNullable(xy: jsb.Nullable<Vector2>): jsb.Nullable<number>
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class NoNamespaceBase extends Object {
        constructor()
    }
}
declare module "global" {
    import * as jsb from "jsb";
    import { MonoBehaviour } from "UnityEngine";
    import { Object } from "System";
    class SampleBehaviour extends MonoBehaviour {
        constructor()
        SimpleWait(t: number): Promise<string>
        AnotherWait(t: number): Promise<any>
        PrimitiveCall(a: string, b: number): void
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class ArrayTest extends Object {
        constructor()
        static values1: Array<number>
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class AsyncTaskTest extends Object {
        constructor()
        static GetHostEntryAsync(host: string): any
        static SimpleTest(ms: number): any
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Vector3 } from "UnityEngine";
    class DelegateTest extends Object {
        constructor()
        TestComplexCall(): void
        AddAction(): void
        DipatchEvent(v: number): void
        CallAction(): void
        CallActionWithArgs(a1: string, a2: number, a3: number): void
        CallFunc(a1: number): number
        static DipatchStaticEvent(v: number): void
        static UseDelegateInParameter(n: () => void): void
        static GetNotExportedClass(): any
        static CallStaticActionWithArgs(a1: string, a2: number, a3: number): void
        static CallHotfixTest(): void
        static GetArray(): Array<DelegateTest.InnerTest>
        onEvent(op: "add" | "remove", fn: (id: number) => void): void
        static onStaticEvent(op: "add" | "remove", fn: (id: number) => void): void
        complexCall(op: "get"): (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number
        complexCall(op: "add" | "remove" | "set", fn?: (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number): void
        complexCall(op: "add" | "remove" | "set" | "get", fn?: (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number): (b: number, a: jsb.Ref<number>, v: jsb.Out<number>) => number | void
        complexCall2(op: "get"): (v: jsb.Ref<Vector3>) => void
        complexCall2(op: "add" | "remove" | "set", fn?: (v: jsb.Ref<Vector3>) => void): void
        complexCall2(op: "add" | "remove" | "set" | "get", fn?: (v: jsb.Ref<Vector3>) => void): (v: jsb.Ref<Vector3>) => void | void
        actionFieldRW(op: "get"): () => void
        actionFieldRW(op: "add" | "remove" | "set", fn?: () => void): void
        actionFieldRW(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        actionFieldR(op: "get"): () => void
        static actionFieldRW_s(op: "get"): () => void
        static actionFieldRW_s(op: "add" | "remove" | "set", fn?: () => void): void
        static actionFieldRW_s(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static actionFieldR_s(op: "get"): () => void
        onAction(op: "get"): () => void
        onAction(op: "add" | "remove" | "set", fn?: () => void): void
        onAction(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        onActionWithArgs(op: "get"): (arg1: string, arg2: number, arg3: number) => void
        onActionWithArgs(op: "add" | "remove" | "set", fn?: (arg1: string, arg2: number, arg3: number) => void): void
        onActionWithArgs(op: "add" | "remove" | "set" | "get", fn?: (arg1: string, arg2: number, arg3: number) => void): (arg1: string, arg2: number, arg3: number) => void | void
        static onStaticActionWithArgs(op: "get"): (arg1: string, arg2: number, arg3: number) => void
        static onStaticActionWithArgs(op: "add" | "remove" | "set", fn?: (arg1: string, arg2: number, arg3: number) => void): void
        static onStaticActionWithArgs(op: "add" | "remove" | "set" | "get", fn?: (arg1: string, arg2: number, arg3: number) => void): (arg1: string, arg2: number, arg3: number) => void | void
        onFunc(op: "get"): (arg: number) => number
        onFunc(op: "add" | "remove" | "set", fn?: (arg: number) => number): void
        onFunc(op: "add" | "remove" | "set" | "get", fn?: (arg: number) => number): (arg: number) => number | void
        actionPropG(op: "get"): () => void
        actionPropS(op: "set", fn: () => void)
        actionPropGS(op: "get"): () => void
        actionPropGS(op: "add" | "remove" | "set", fn?: () => void): void
        actionPropGS(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static actionPropG_s(op: "get"): () => void
        static actionPropS_s(op: "set", fn: () => void)
        static actionPropGS_s(op: "get"): () => void
        static actionPropGS_s(op: "add" | "remove" | "set", fn?: () => void): void
        static actionPropGS_s(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    abstract class NativeFileUtil extends Object {
        static ReadAllText(path: string): string
        static ReadAllBytes(path: string): Array<jsb.byte>
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class Jankfest extends Object {
        constructor()
        static DoNothing(jankfest: Jankfest): Jankfest
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GameObject } from "UnityEngine";
    class ValueTest extends Object {
        constructor()
        toString(): string
        static TakeStringWithCache(v: string): void
        static TakeString(v: string): void
        static Foo(v: string): string
        static CheckArgs(a: number, b: jsb.Out<number>, c: jsb.Ref<string>): boolean
        static CheckArgs(a: number, b: jsb.Out<number>, c: jsb.Ref<GameObject>): boolean
        static MakeTrouble(): void
        static values1: Array<number>
        static values2: Array<number, 2>
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class Galaxy extends Object {
        constructor()
        static GetName(): string
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class IncompatibleOverloadTest1 extends Object {
        constructor()
        Test(): void
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    class IncompatibleOverloadTest2 extends IncompatibleOverloadTest1 {
        constructor()
        Test(a: number): void
        Test(): void
    }
}
declare module "Example" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace DelegateTest {
        class InnerTest extends Object {
            constructor()
            static readonly hello: string
        }
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace Galaxy {
        class Sun extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace Galaxy {
        class Earth extends Object {
            constructor()
            GetSun(): Galaxy.Sun
            GetContinents(): Array<Galaxy.Earth.Continent>
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace Galaxy.Earth {
        class Ocean extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "Example.New.World" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace Galaxy.Earth {
        class Continent extends Object {
            constructor()
            static GetName(): string
        }
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Byte extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: jsb.byte): number
        Equals(obj: Object): boolean
        Equals(obj: jsb.byte): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): jsb.byte
        static Parse(s: string, style: any): jsb.byte
        static Parse(s: string, provider: any): jsb.byte
        static Parse(s: string): jsb.byte
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<jsb.byte>): boolean
        static TryParse(s: string, result: jsb.Out<jsb.byte>): boolean
        protected constructor()
        static readonly MaxValue: jsb.byte
        static readonly MinValue: jsb.byte
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class SByte extends ValueType {
        CompareTo(obj: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Single extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static IsInfinity(f: number): boolean
        static IsNaN(f: number): boolean
        static IsNegative(f: number): boolean
        static IsNegativeInfinity(f: number): boolean
        static IsNormal(f: number): boolean
        static IsPositiveInfinity(f: number): boolean
        static IsSubnormal(f: number): boolean
        static op_Equality(left: number, right: number): boolean
        static op_Inequality(left: number, right: number): boolean
        static op_LessThan(left: number, right: number): boolean
        static op_GreaterThan(left: number, right: number): boolean
        static op_LessThanOrEqual(left: number, right: number): boolean
        static op_GreaterThanOrEqual(left: number, right: number): boolean
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        // js_op_overloading: static ==(left: number, right: number): boolean
        // js_op_overloading: static <(left: number, right: number): boolean
        protected constructor()
        static readonly MinValue: number
        static readonly Epsilon: number
        static readonly MaxValue: number
        static readonly PositiveInfinity: number
        static readonly NegativeInfinity: number
        static readonly NaN: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Double extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static IsInfinity(d: number): boolean
        static IsNaN(d: number): boolean
        static IsNegative(d: number): boolean
        static IsNegativeInfinity(d: number): boolean
        static IsNormal(d: number): boolean
        static IsPositiveInfinity(d: number): boolean
        static IsSubnormal(d: number): boolean
        static op_Equality(left: number, right: number): boolean
        static op_Inequality(left: number, right: number): boolean
        static op_LessThan(left: number, right: number): boolean
        static op_GreaterThan(left: number, right: number): boolean
        static op_LessThanOrEqual(left: number, right: number): boolean
        static op_GreaterThanOrEqual(left: number, right: number): boolean
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        // js_op_overloading: static ==(left: number, right: number): boolean
        // js_op_overloading: static <(left: number, right: number): boolean
        protected constructor()
        static readonly MinValue: number
        static readonly MaxValue: number
        static readonly Epsilon: number
        static readonly NegativeInfinity: number
        static readonly PositiveInfinity: number
        static readonly NaN: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    import { IEnumerable } from "System.Collections.Generic";
    class String extends Object {
        constructor(value: Array<string>, startIndex: number, length: number)
        constructor(c: string, count: number)
        constructor(value: Array<string>)
        CompareTo(value: Object): number
        CompareTo(strB: string): number
        EndsWith(value: string, ignoreCase: boolean, culture: any): boolean
        EndsWith(value: string, comparisonType: any): boolean
        EndsWith(value: string): boolean
        EndsWith(value: string): boolean
        Equals(value: string, comparisonType: any): boolean
        Equals(obj: Object): boolean
        Equals(value: string): boolean
        GetHashCode(comparisonType: any): number
        GetHashCode(): number
        StartsWith(value: string, ignoreCase: boolean, culture: any): boolean
        StartsWith(value: string, comparisonType: any): boolean
        StartsWith(value: string): boolean
        StartsWith(value: string): boolean
        Clone(): Object
        CopyTo(sourceIndex: number, destination: Array<string>, destinationIndex: number, count: number): void
        ToCharArray(startIndex: number, length: number): Array<string>
        ToCharArray(): Array<string>
        toString(provider: any): string
        toString(): string
        GetEnumerator(): any
        GetTypeCode(): any
        IsNormalized(normalizationForm: any): boolean
        IsNormalized(): boolean
        Normalize(normalizationForm: any): string
        Normalize(): string
        Insert(startIndex: number, value: string): string
        PadLeft(totalWidth: number, paddingChar: string): string
        PadLeft(totalWidth: number): string
        PadRight(totalWidth: number, paddingChar: string): string
        PadRight(totalWidth: number): string
        Remove(startIndex: number, count: number): string
        Remove(startIndex: number): string
        Replace(oldValue: string, newValue: string, ignoreCase: boolean, culture: any): string
        Replace(oldValue: string, newValue: string, comparisonType: any): string
        Replace(oldChar: string, newChar: string): string
        Replace(oldValue: string, newValue: string): string
        Split(separator: string, count: number, options: any): Array<string>
        Split(separator: Array<string>, count: number, options: any): Array<string>
        Split(separator: string, count: number, options: any): Array<string>
        Split(separator: Array<string>, count: number, options: any): Array<string>
        Split(separator: string, options: any): Array<string>
        Split(separator: Array<string>, count: number): Array<string>
        Split(separator: Array<string>, options: any): Array<string>
        Split(separator: string, options: any): Array<string>
        Split(separator: Array<string>, options: any): Array<string>
        Split(...separator: string[]): Array<string>
        Substring(startIndex: number, length: number): string
        Substring(startIndex: number): string
        ToLower(culture: any): string
        ToLower(): string
        ToLowerInvariant(): string
        ToUpper(culture: any): string
        ToUpper(): string
        ToUpperInvariant(): string
        Trim(trimChar: string): string
        Trim(): string
        Trim(...trimChars: string[]): string
        TrimStart(trimChar: string): string
        TrimStart(): string
        TrimStart(...trimChars: string[]): string
        TrimEnd(trimChar: string): string
        TrimEnd(): string
        TrimEnd(...trimChars: string[]): string
        Contains(value: string, comparisonType: any): boolean
        Contains(value: string, comparisonType: any): boolean
        Contains(value: string): boolean
        Contains(value: string): boolean
        IndexOf(value: string, startIndex: number, count: number, comparisonType: any): number
        IndexOf(value: string, startIndex: number, count: number): number
        IndexOf(value: string, startIndex: number, count: number): number
        IndexOf(value: string, startIndex: number, comparisonType: any): number
        IndexOf(value: string, startIndex: number): number
        IndexOf(value: string, comparisonType: any): number
        IndexOf(value: string, startIndex: number): number
        IndexOf(value: string, comparisonType: any): number
        IndexOf(value: string): number
        IndexOf(value: string): number
        IndexOfAny(anyOf: Array<string>, startIndex: number, count: number): number
        IndexOfAny(anyOf: Array<string>, startIndex: number): number
        IndexOfAny(anyOf: Array<string>): number
        LastIndexOf(value: string, startIndex: number, count: number, comparisonType: any): number
        LastIndexOf(value: string, startIndex: number, count: number): number
        LastIndexOf(value: string, startIndex: number, count: number): number
        LastIndexOf(value: string, startIndex: number, comparisonType: any): number
        LastIndexOf(value: string, startIndex: number): number
        LastIndexOf(value: string, startIndex: number): number
        LastIndexOf(value: string, comparisonType: any): number
        LastIndexOf(value: string): number
        LastIndexOf(value: string): number
        LastIndexOfAny(anyOf: Array<string>, startIndex: number, count: number): number
        LastIndexOfAny(anyOf: Array<string>, startIndex: number): number
        LastIndexOfAny(anyOf: Array<string>): number
        AsMemory(start: number, length: number): any
        AsMemory(start: number): any
        AsMemory(startIndex: any): any
        AsMemory(range: any): any
        AsMemory(): any
        ArrayListFromJson(): any
        HashtableFromJson(): any
        ToIntArray(): Array<number>
        VarName(): string
        GetReadableName(): string
        ToNPath(): any
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean, culture: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, culture: any, options: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, ignoreCase: boolean): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number, comparisonType: any): number
        static Compare(strA: string, indexA: number, strB: string, indexB: number, length: number): number
        static Compare(strA: string, strB: string, culture: any, options: any): number
        static Compare(strA: string, strB: string, ignoreCase: boolean, culture: any): number
        static Compare(strA: string, strB: string, ignoreCase: boolean): number
        static Compare(strA: string, strB: string, comparisonType: any): number
        static Compare(strA: string, strB: string): number
        static CompareOrdinal(strA: string, indexA: number, strB: string, indexB: number, length: number): number
        static CompareOrdinal(strA: string, strB: string): number
        static Equals(a: string | Object, b: string | Object, comparisonType: any): boolean
        static Equals(a: string | Object, b: string | Object): boolean
        static op_Equality(a: string, b: string): boolean
        static op_Inequality(a: string, b: string): boolean
        static Copy(str: string): string
        static IsNullOrEmpty(value: string): boolean
        static IsNullOrWhiteSpace(value: string): boolean
        static Concat(str0: string, str1: string, str2: string, str3: string): string
        static Concat(arg0: Object, arg1: Object, arg2: Object, arg3: Object): string
        static Concat(arg0: Object, arg1: Object, arg2: Object): string
        static Concat(str0: string, str1: string, str2: string): string
        static Concat(arg0: Object, arg1: Object): string
        static Concat(str0: string, str1: string): string
        static Concat(arg0: Object): string
        static Concat(values: IEnumerable<string>): string
        static Concat(...args: Object[]): string
        static Concat(...values: string[]): string
        static Format(provider: any, format: string, arg0: Object, arg1: Object, arg2: Object): string
        static Format(format: string, arg0: Object, arg1: Object, arg2: Object): string
        static Format(provider: any, format: string, arg0: Object, arg1: Object): string
        static Format(format: string, arg0: Object, arg1: Object): string
        static Format(provider: any, format: string, arg0: Object): string
        static Format(format: string, arg0: Object): string
        static Format(provider: any, format: string, ...args: Object[]): string
        static Format(format: string, ...args: Object[]): string
        static Join(separator: string, value: Array<string>, startIndex: number, count: number): string
        static Join(separator: string, value: Array<string>, startIndex: number, count: number): string
        static Join(separator: string, values: IEnumerable<string>): string
        static Join(separator: string, ...value: string[]): string
        static Join(separator: string, ...values: Object[]): string
        static Join(separator: string, ...value: string[]): string
        static Join(separator: string, ...values: Object[]): string
        static Intern(str: string): string
        static IsInterned(str: string): string
        // js_op_overloading: static ==(a: string, b: string): boolean
        readonly Length: number
        static readonly Empty: string
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Int32 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(format: string): string
        toString(provider: any): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class UInt32 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Int16 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class UInt16 extends ValueType {
        CompareTo(value: Object): number
        CompareTo(value: number): number
        Equals(obj: Object): boolean
        Equals(obj: number): boolean
        GetHashCode(): number
        toString(format: string, provider: any): string
        toString(provider: any): string
        toString(format: string): string
        toString(): string
        GetTypeCode(): any
        static Parse(s: string, style: any, provider: any): number
        static Parse(s: string, style: any): number
        static Parse(s: string, provider: any): number
        static Parse(s: string): number
        static TryParse(s: string, style: any, provider: any, result: jsb.Out<number>): boolean
        static TryParse(s: string, result: jsb.Out<number>): boolean
        protected constructor()
        static readonly MaxValue: number
        static readonly MinValue: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    import { IEnumerator } from "System.Collections";
    abstract class Array<T, RANK = 1> extends Object {
        CopyTo(array: Array<any>, index: number): void
        Clone(): Object
        GetLongLength(dimension: number): number
        GetEnumerator(): IEnumerator
        GetLength(dimension: number): number
        GetLowerBound(dimension: number): number
        GetValue(index1: number, index2: number, index3: number): T
        GetValue(index1: number, index2: number): T
        GetValue(index: number): T
        GetValue(...index: number[]): T
        SetValue(value: T, index1: number, index2: number, index3: number): T
        SetValue(value: T, index1: number, index2: number): T
        SetValue(value: T, index: number): T
        SetValue(value: T, ...index: number[]): T
        GetUpperBound(dimension: number): number
        Initialize(): void
        static BinarySearch<T>(array: Array<T>, index: number, length: number, value: Object, comparer: any): number
        static BinarySearch<T>(array: Array<T>, index: number, length: number, value: Object): number
        static BinarySearch<T>(array: Array<T>, value: Object, comparer: any): number
        static BinarySearch<T>(array: Array<T>, value: Object): number
        static IndexOf<T>(array: Array<T>, value: Object, startIndex: number, count: number): number
        static IndexOf<T>(array: Array<T>, value: Object, startIndex: number): number
        static IndexOf<T>(array: Array<T>, value: Object): number
        static LastIndexOf<T>(array: Array<T>, value: Object, startIndex: number, count: number): number
        static LastIndexOf<T>(array: Array<T>, value: Object, startIndex: number): number
        static LastIndexOf<T>(array: Array<T>, value: Object): number
        static Reverse<T>(array: Array<T>, index: number, length: number): void
        static Reverse<T>(array: Array<T>): void
        static Sort<T>(keys: Array<T>, items: Array<T>, index: number, length: number, comparer: any): void
        static Sort<T>(array: Array<T>, index: number, length: number, comparer: any): void
        static Sort<T>(keys: Array<T>, items: Array<T>, index: number, length: number): void
        static Sort<T>(array: Array<T>, index: number, length: number): void
        static Sort<T>(keys: Array<T>, items: Array<T>, comparer: any): void
        static Sort<T>(array: Array<T>, comparer: any): void
        static Sort<T>(keys: Array<T>, items: Array<T>): void
        static Sort<T>(array: Array<T>): void
        static CreateInstance<T>(elementType: any, length1: number, length2: number, length3: number): Array<T>
        static CreateInstance<T>(elementType: any, length1: number, length2: number): Array<T>
        static CreateInstance<T>(elementType: any, lengths: Array<number>, lowerBounds: Array<number>): Array<T>
        static CreateInstance<T>(elementType: any, length: number): Array<T>
        static CreateInstance<T>(elementType: any, ...lengths: number[]): Array<T>
        static Clear<T>(array: Array<T>, index: number, length: number): void
        static Copy<T>(sourceArray: Array<T>, sourceIndex: number, destinationArray: Array<T>, destinationIndex: number, length: number): void
        static Copy<T>(sourceArray: Array<T>, destinationArray: Array<T>, length: number): void
        static ConstrainedCopy<T>(sourceArray: Array<T>, sourceIndex: number, destinationArray: Array<T>, destinationIndex: number, length: number): void
        readonly LongLength: number
        readonly IsFixedSize: boolean
        readonly IsReadOnly: boolean
        readonly IsSynchronized: boolean
        readonly SyncRoot: Object
        readonly Length: number
        readonly Rank: number
    }
}
declare module "System" {
    import * as jsb from "jsb";
    abstract class Delegate extends Object {
        DynamicInvoke(...args: Object[]): Object
        Clone(): Object
        Equals(obj: Object): boolean
        GetHashCode(): number
        GetObjectData(info: any, context: any): void
        GetInvocationList(): Array<Delegate>
        GetMethodInfo(): any
        static Combine(a: Delegate, b: Delegate): Delegate
        static Combine(...delegates: Delegate[]): Delegate
        static Remove(source: Delegate, value: Delegate): Delegate
        static RemoveAll(source: Delegate, value: Delegate): Delegate
        static op_Equality(d1: Delegate, d2: Delegate): boolean
        static op_Inequality(d1: Delegate, d2: Delegate): boolean
        // js_op_overloading: static ==(d1: Delegate, d2: Delegate): boolean
        readonly Method: any
        readonly Target: Object
    }
}
declare module "QuickJS.IO" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    class ByteBuffer extends Object {
        constructor(initialCapacity: number, maxCapacity: number, allocator: any)
        constructor(data: Array<jsb.byte>, maxCapacity: number)
        constructor(data: Array<jsb.byte>)
        toString(): string
        Release(): void
        Retain(): ByteBuffer
        Slice(size: number): ByteBuffer
        CheckReadalbe(size: number): void
        ReadBytes(dst: Array<jsb.byte>, dstOffset: number, size: number): number
        ReadBytes(pointer: any, size: number): number
        ReadBytes(count: number): void
        ReadUByte(): jsb.byte
        ReadSByte(): number
        ReadBoolean(): boolean
        ReadAllBytes(): Array<jsb.byte>
        ReadSingle(): number
        ReadDouble(): number
        ReadString(): string
        ReadInt16(): number
        ReadUInt16(): number
        ReadInt32(): number
        ReadUInt32(): number
        ReadInt64(): number
        ReadUInt64(): number
        EnsureCapacity(value: number): void
        WriteByte(data: jsb.byte): void
        WriteSByte(data: number): void
        WriteBytes(src: Array<jsb.byte>, srcOffset: number, count: number): void
        WriteBytes(memoryStream: any, size: number): void
        WriteBytes(other: ByteBuffer): void
        WriteBytes(byteCount: number): void
        WriteBytes(data: Array<jsb.byte>): void
        WriteBoolean(value: boolean): void
        WriteInt16(value: number): void
        WriteUInt16(value: number): void
        WriteInt32(value: number): void
        WriteUInt32(value: number): void
        WriteInt64(value: number): void
        WriteUInt64(value: number): void
        WriteSingle(value: number): void
        WriteDouble(value: number): void
        WriteString(value: string): void
        readonly data: Array<jsb.byte>
        readonly capacity: number
        writerIndex: number
        readonly readableBytes: number
        readerIndex: number
        readonly maxCapacity: number
        readonly isWritable: boolean
    }
}
declare module "Unity.Profiling.Editor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Provides a descriptor for a Profiler counter.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ProfilerCounterDescriptor extends ValueType {
        constructor(name: string, category: any)
        constructor(name: string, categoryName: string)
        toString(): string
        /** The name of the described Profiler counter.
         */
        readonly Name: string
        /** The category name of the described Profiler counter.
         */
        readonly CategoryName: string
    }
}
declare module "Unity.Profiling.Editor" {
    import * as jsb from "jsb";
    /** Options for a Profiler module’s chart type.
     */
    enum ProfilerModuleChartType {
        /** Display a line chart.
         */
        Line = 0,
        /** Display a stacked-area chart.
         */
        StackedTimeArea = 1,
    }
}
declare module "Unity.Profiling.Editor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Represents a Profiler module in the Profiler window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ProfilerModule extends Object {
        CreateDetailsViewController(): ProfilerModuleViewController
        /** The module’s display name.
         */
        readonly DisplayName: string
    }
}
declare module "Unity.Profiling.Editor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Provides a single view of content for a ProfilerModule displayed in the Profiler window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ProfilerModuleViewController extends Object {
        Dispose(): void
        readonly Disposed: boolean
    }
}
declare module "UnityEditorInternal.Profiling" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class NetworkingOperationsProfilerOverrides extends Object {
        static drawDetailsViewOverride(op: "get"): (arg1: Rect, arg2: number) => void
        static drawDetailsViewOverride(op: "add" | "remove" | "set", fn?: (arg1: Rect, arg2: number) => void): void
        static drawDetailsViewOverride(op: "add" | "remove" | "set" | "get", fn?: (arg1: Rect, arg2: number) => void): (arg1: Rect, arg2: number) => void | void
        static getCustomChartCounters(op: "get"): () => any
        static getCustomChartCounters(op: "add" | "remove" | "set", fn?: () => any): void
        static getCustomChartCounters(op: "add" | "remove" | "set" | "get", fn?: () => any): () => any | void
    }
}
declare module "UnityEditorInternal.Profiling" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class NetworkingMessagesProfilerOverrides extends Object {
        static drawDetailsViewOverride(op: "get"): (arg1: Rect, arg2: number) => void
        static drawDetailsViewOverride(op: "add" | "remove" | "set", fn?: (arg1: Rect, arg2: number) => void): void
        static drawDetailsViewOverride(op: "add" | "remove" | "set" | "get", fn?: (arg1: Rect, arg2: number) => void): (arg1: Rect, arg2: number) => void | void
        static getCustomChartCounters(op: "get"): () => any
        static getCustomChartCounters(op: "add" | "remove" | "set", fn?: () => any): void
        static getCustomChartCounters(op: "add" | "remove" | "set" | "get", fn?: () => any): () => any | void
    }
}
declare module "UnityEditorInternal.Profiling" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class NetworkCounterData extends ValueType {
        constructor()
        category: string
        name: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GUID extends ValueType {
        constructor(hexRepresentation: string)
        Equals(obj: Object): boolean
        Equals(obj: GUID): boolean
        GetHashCode(): number
        CompareTo(obj: Object): number
        CompareTo(rhs: GUID): number
        Empty(): boolean
        toString(): string
        static op_Equality(x: GUID, y: GUID): boolean
        static op_Inequality(x: GUID, y: GUID): boolean
        static op_LessThan(x: GUID, y: GUID): boolean
        static op_GreaterThan(x: GUID, y: GUID): boolean
        static TryParse(hex: string, result: jsb.Out<GUID>): boolean
        static Generate(): GUID
        // js_op_overloading: static ==(x: GUID, y: GUID): boolean
        // js_op_overloading: static <(x: GUID, y: GUID): boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI } from "UnityEngine";
    namespace EditorGUI {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class DisabledGroupScope extends GUI.Scope {
            constructor(disabled: boolean)
        }
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Object as Object1 } from "System";
    namespace GUI {
        abstract class Scope extends Object1 {
            Dispose(): void
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    namespace EditorGUI {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class DisabledScope extends ValueType {
            constructor(disabled: boolean)
            Dispose(): void
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI } from "UnityEngine";
    namespace EditorGUI {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ChangeCheckScope extends GUI.Scope {
            constructor()
            readonly changed: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI } from "UnityEngine";
    namespace EditorGUI {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class IndentLevelScope extends GUI.Scope {
            constructor(increment: number)
            constructor()
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, GUIContent, Rect } from "UnityEngine";
    namespace EditorGUI {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class PropertyScope extends GUI.Scope {
            constructor(totalPosition: Rect, label: GUIContent, property: SerializedProperty)
            readonly content: GUIContent
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Whether you can append an existing build using BuildOptions.AcceptExternalModificationsToPlayer.
     */
    enum CanAppendBuild {
        /** The target platform does not support appending builds.
         */
        Unsupported = 0,
        /** The target platform supports appending builds, and the build can be appended.
         */
        Yes = 1,
        /** The target platform supports appending builds, and the build is not in a valid state.
         */
        No = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** AssetBundle building map entry.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetBundleBuild extends ValueType {
        constructor()
        /** AssetBundle name.
         */
        assetBundleName: string
        /** AssetBundle variant.
         */
        assetBundleVariant: string
        /** Asset names which belong to the given AssetBundle.
         */
        assetNames: Array<string>
        /** Addressable name used to load an asset.
         */
        addressableNames: Array<string>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Describes how the player connects to the Editor.
     */
    enum PlayerConnectionInitiateMode {
        /** Player connection mode not set.
         */
        None = 0,
        /** Player connection is initiated by the player connecting to the host, usually the host is the Editor.
         */
        PlayerConnectsToHost = 1,
        /** Player connection is initiated by the player broadcasting its IP address, and then Editor connecting to the player.
         */
        PlayerListens = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { Object as Object1, Vector2, Color, Vector4, Texture } from "UnityEngine";
    /** Describes information and value of a single shader property.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MaterialProperty extends Object {
        constructor()
        ReadFromMaterialPropertyBlock(block: any): void
        WriteToMaterialPropertyBlock(materialblock: any, changedPropertyMask: number): void
        /** Material objects being edited by this property (Read Only).
         */
        readonly targets: Array<Object1>
        /** Type of the property (Read Only).
         */
        readonly type: MaterialProperty.PropType
        /** Name of the property (Read Only).
         */
        readonly name: string
        /** Display name of the property (Read Only).
         */
        readonly displayName: string
        /** Flags that control how property is displayed (Read Only).
         */
        readonly flags: MaterialProperty.PropFlags
        /** Texture dimension (2D, Cubemap etc.) of the property (Read Only).
         */
        readonly textureDimension: any
        /** Min/max limits of a ranged float property (Read Only).
         */
        readonly rangeLimits: Vector2
        /** Does this property have multiple different values? (Read Only)
         */
        readonly hasMixedValue: boolean
        /** Color value of the property.
         */
        colorValue: Color
        /** Vector value of the property.
         */
        vectorValue: Vector4
        /** Float value of the property.
         */
        floatValue: number
        /** Int value of the property.
         */
        intValue: number
        /** Texture value of the property.
         */
        textureValue: Texture
        textureScaleAndOffset: Vector4
        applyPropertyCallback(op: "get"): (prop: MaterialProperty, changeMask: number, previousValue: Object) => boolean
        applyPropertyCallback(op: "add" | "remove" | "set", fn?: (prop: MaterialProperty, changeMask: number, previousValue: Object) => boolean): void
        applyPropertyCallback(op: "add" | "remove" | "set" | "get", fn?: (prop: MaterialProperty, changeMask: number, previousValue: Object) => boolean): (prop: MaterialProperty, changeMask: number, previousValue: Object) => boolean | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace MaterialProperty {
        enum PropType {
            Color = 0,
            Vector = 1,
            Float = 2,
            Range = 3,
            Texture = 4,
            Int = 5,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace MaterialProperty {
        enum PropFlags {
            None = 0,
            HideInInspector = 1,
            PerRendererData = 2,
            NoScaleOffset = 4,
            Normal = 8,
            HDR = 16,
            Gamma = 32,
            NonModifiableTextureData = 64,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Texture2D, Vector2 } from "UnityEngine";
    import { ValueType, Enum, Array } from "System";
    import { NamedBuildTarget } from "UnityEditor.Build";
    /** Player Settings is where you define various parameters for the final game that you will build in Unity. Some of these values are used in the Resolution Dialog that launches when you open a standalone game.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PlayerSettings extends Object {
        /** Returns whether or not the specified aspect ratio is enabled.
         */
        static HasAspectRatio(aspectRatio: AspectRatio): boolean
        /** Enables the specified aspect ratio.
         */
        static SetAspectRatio(aspectRatio: AspectRatio, enable: boolean): void
        static GetPreloadedAssets(): Array<Object>
        /** Assigns the assets that will be loaded at start up in the player and be kept alive until the player terminates.
         */
        static SetPreloadedAssets(assets: Array<Object>): void
        /** Gets the default size for compressed shader variant chunks for the build target.
         * @param buildTarget The build target to get the shader chunk size for.
         */
        static GetShaderChunkSizeInMBForPlatform(buildTarget: BuildTarget): number
        /** Sets the default size for compressed shader variant chunks on the build target.
         * @param buildTarget The build target to set the shader chunk size for.
         * @param sizeInMegabytes The chunk size in megabytes.
         */
        static SetShaderChunkSizeInMBForPlatform(buildTarget: BuildTarget, sizeInMegabytes: number): void
        /** Gets the default limit on the number of shader variant chunks Unity loads and keeps in memory for the build target.
         * @param buildTarget The build target to get the shader chunk count for.
         */
        static GetShaderChunkCountForPlatform(buildTarget: BuildTarget): number
        /** Sets the default limit on the number of shader variant chunks Unity loads and keeps in memory on the build target.
         * @param buildTarget The build target to set the shader chunk count for.
         * @param chunkCount The maximum number of chunks to keep in memory for each shader.
         */
        static SetShaderChunkCountForPlatform(buildTarget: BuildTarget, chunkCount: number): void
        static GetDefaultShaderChunkSizeInMB(): number
        /** Sets the default size for compressed shader variant chunks.
         * @param sizeInMegabytes The chunk size in megabytes.
         */
        static SetDefaultShaderChunkSizeInMB(sizeInMegabytes: number): void
        static GetDefaultShaderChunkCount(): number
        /** Sets the default limit on the number of shader variant chunks Unity loads and keeps in memory.
         * @param buildTarget The build target to set the shader chunk count for.
         * @param chunkCount The maximum number of chunks to keep in memory for each shader.
         */
        static SetDefaultShaderChunkCount(chunkCount: number): void
        /** If the value is true, settings for the buildTarget override the default settings.
         * @param buildTarget The build target to check the override for.
         */
        static GetOverrideShaderChunkSettingsForPlatform(buildTarget: BuildTarget): boolean
        /** Enable this to override the default shader variant chunk settings.
         * @param buildTarget The build target to set the override for.
         * @param value Set the value to true if you want settings for the buildTarget to override the default settings.
         */
        static SetOverrideShaderChunkSettingsForPlatform(buildTarget: BuildTarget, value: boolean): void
        /** Get graphics APIs to be used on a build platform.
         * @param platform Platform to get APIs for.
         * @returns Array of graphics APIs. 
         */
        static GetGraphicsAPIs(platform: BuildTarget): Array<any>
        /** Sets the graphics APIs used on a build platform.
         * @param platform Platform to set APIs for.
         * @param apis Array of graphics APIs.
         */
        static SetGraphicsAPIs(platform: BuildTarget, apis: Array<any>): void
        /** Is a build platform using automatic graphics API choice?
         * @param platform Platform to get the flag for.
         * @returns Should best available graphics API be used. 
         */
        static GetUseDefaultGraphicsAPIs(platform: BuildTarget): boolean
        /** Should a build platform use automatic graphics API choice.
         * @param platform Platform to set the flag for.
         * @param automatic Should best available graphics API be used?
         */
        static SetUseDefaultGraphicsAPIs(platform: BuildTarget, automatic: boolean): void
        /** Sets a value of a custom template variable.
         * @param name Name of the variable.
         * @param value Value of the custom template variable.
         */
        static SetTemplateCustomValue(name: string, value: string): void
        /** Returns a value of a custom template variable.
         * @param name Name of the variable.
         * @returns The current value of the custom template variable. 
         */
        static GetTemplateCustomValue(name: string): string
        static GetScriptingDefineSymbolsForGroup(targetGroup: BuildTargetGroup, defines: jsb.Out<Array<string>>): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetScriptingDefineSymbols instead.
         */
        static GetScriptingDefineSymbolsForGroup(targetGroup: BuildTargetGroup): string
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.SetScriptingDefineSymbols instead.
         * @param targetGroup The name of the group of devices.
         * @param defines Symbols for this group can be passed as an array or as a string separated by semicolons.
         */
        static SetScriptingDefineSymbolsForGroup(targetGroup: BuildTargetGroup, defines: string): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.SetScriptingDefineSymbols instead.
         * @param targetGroup The name of the group of devices.
         * @param defines Symbols for this group can be passed as an array or as a string separated by semicolons.
         */
        static SetScriptingDefineSymbolsForGroup(targetGroup: BuildTargetGroup, defines: Array<string>): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetAdditionalCompilerArguments instead.
         * @param targetGroup The BuildTargetGroup to get the compiler arguments for.
         * @returns Returns an array with the compiler arguments associated with a BuildTargetGroup. 
         */
        static GetAdditionalCompilerArgumentsForGroup(targetGroup: BuildTargetGroup): Array<string>
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.SetAdditionalCompilerArguments instead.
         * @param targetGroup The BuildTargetGroup to set the additional compiler arguments for.
         * @param additionalCompilerArguments An array of the additional compiler arguments.
         */
        static SetAdditionalCompilerArgumentsForGroup(targetGroup: BuildTargetGroup, additionalCompilerArguments: Array<string>): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetArchitecture(targetGroup: BuildTargetGroup): number
        /** Gets the architecture for the given build target.
         * @param buildTarget The NamedBuildTarget.
         * @returns An integer value associated with the architecture of the build target.  0 - None, 1 - ARM64, 2 - Universal. 
         */
        static GetArchitecture(buildTarget: NamedBuildTarget): number
        /** Sets the architecture for the given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param architecture An integer value associated with the architecture of the build target.  0 - None, 1 - ARM64, 2 - Universal.
         */
        static SetArchitecture(targetGroup: BuildTargetGroup, architecture: number): void
        /** Sets the architecture for the given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param architecture An integer value associated with the architecture of the build target.  0 - None, 1 - ARM64, 2 - Universal.
         */
        static SetArchitecture(buildTarget: NamedBuildTarget, architecture: number): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetScriptingBackend(targetGroup: BuildTargetGroup): ScriptingImplementation
        /** Gets the scripting framework for the build target you select.
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns IL2CPP, Mono or .NET scripting backends. 
         */
        static GetScriptingBackend(buildTarget: NamedBuildTarget): ScriptingImplementation
        /** Sets the scripting framework for a given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param backend The ScriptingImplementation.
         */
        static SetScriptingBackend(targetGroup: BuildTargetGroup, backend: ScriptingImplementation): void
        /** Sets the scripting framework for a given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param backend The ScriptingImplementation.
         */
        static SetScriptingBackend(buildTarget: NamedBuildTarget, backend: ScriptingImplementation): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         * @param targetGroup The platform group to retrieve the scripting backend for.
         * @returns A ScriptingImplementation object that describes the default scripting backend used on that build target. 
         */
        static GetDefaultScriptingBackend(targetGroup: BuildTargetGroup): ScriptingImplementation
        /** Returns the default ScriptingImplementation for the build target you select.
         * @param buildTarget The NamedBuildTarget.
         * @returns A ScriptingImplementation object that describes the default scripting backend for the build target you select. 
         */
        static GetDefaultScriptingBackend(buildTarget: NamedBuildTarget): ScriptingImplementation
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetApplicationIdentifier(targetGroup: BuildTargetGroup): string
        /** Get the application identifier for the specified platform.
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns the application identifier associated with a NamedBuildTarget. 
         */
        static GetApplicationIdentifier(buildTarget: NamedBuildTarget): string
        /** Set the application identifier for the specified platform.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetApplicationIdentifier(targetGroup: BuildTargetGroup, identifier: string): void
        /** Set the application identifier for the specified platform.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetApplicationIdentifier(buildTarget: NamedBuildTarget, identifier: string): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         * @param targetGroup Build target group.
         */
        static GetIl2CppCompilerConfiguration(targetGroup: BuildTargetGroup): Il2CppCompilerConfiguration
        /** Gets compiler configuration used when compiling generated C++ code for the build target you specify.
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns compiler configuration. 
         */
        static GetIl2CppCompilerConfiguration(buildTarget: NamedBuildTarget): Il2CppCompilerConfiguration
        /** Sets compiler configuration used when compiling generated C++ code for a particular build target.
         * @param buildTarget The NamedBuildTarget.
         * @param targetGroup Build target group.
         * @param configuration Compiler configuration.
         */
        static SetIl2CppCompilerConfiguration(targetGroup: BuildTargetGroup, configuration: Il2CppCompilerConfiguration): void
        /** Sets compiler configuration used when compiling generated C++ code for a particular build target.
         * @param buildTarget The NamedBuildTarget.
         * @param targetGroup Build target group.
         * @param configuration Compiler configuration.
         */
        static SetIl2CppCompilerConfiguration(buildTarget: NamedBuildTarget, configuration: Il2CppCompilerConfiguration): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetIncrementalIl2CppBuild(targetGroup: BuildTargetGroup): boolean
        /** Gets the value of incremental il2cpp build option.
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns a boolean indicating if a IL2CPP supported build target is set to use incremental builds. 
         */
        static GetIncrementalIl2CppBuild(buildTarget: NamedBuildTarget): boolean
        /** Sets incremental build flag.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetIncrementalIl2CppBuild(targetGroup: BuildTargetGroup, enabled: boolean): void
        /** Sets incremental build flag.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetIncrementalIl2CppBuild(buildTarget: NamedBuildTarget, enabled: boolean): void
        /** Sets the managed code stripping level for specified build target.
         * @param level The desired managed code stripping level.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetManagedStrippingLevel(targetGroup: BuildTargetGroup, level: ManagedStrippingLevel): void
        /** Sets the managed code stripping level for specified build target.
         * @param level The desired managed code stripping level.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetManagedStrippingLevel(buildTarget: NamedBuildTarget, level: ManagedStrippingLevel): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         * @param targetGroup The target platform group whose code stripping level you want to retrieve.
         */
        static GetManagedStrippingLevel(targetGroup: BuildTargetGroup): ManagedStrippingLevel
        /** Gets the managed code stripping level set for the build target you select
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns the default ManagedStrippingLevel for the build target you select. 
         */
        static GetManagedStrippingLevel(buildTarget: NamedBuildTarget): ManagedStrippingLevel
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetApiCompatibilityLevel(buildTargetGroup: BuildTargetGroup): ApiCompatibilityLevel
        /** Gets .NET API compatibility level for specified build target.
         * @param buildTarget The NamedBuildTarget.
         * @returns Returns the ApiCompatibilityLevel associated with a NamedBuildTarget. 
         */
        static GetApiCompatibilityLevel(buildTarget: NamedBuildTarget): ApiCompatibilityLevel
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static SetApiCompatibilityLevel(buildTargetGroup: BuildTargetGroup, value: ApiCompatibilityLevel): void
        /** Sets .NET API compatibility level for specified build target.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetApiCompatibilityLevel(buildTarget: NamedBuildTarget, value: ApiCompatibilityLevel): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         * @param targetGroup Mobile platform (Only iOS, tvOS and Android).
         */
        static GetMobileMTRendering(targetGroup: BuildTargetGroup): boolean
        /** Check if multithreaded rendering option for mobile platform is enabled.
         * @param buildTarget The NamedBuildTarget. (Only iOS, tvOS and Android).
         * @returns Returns true if multithreaded rendering option for build target is enabled. 
         */
        static GetMobileMTRendering(buildTarget: NamedBuildTarget): boolean
        /** Enable or disable multithreaded rendering option for mobile platform.
         * @param targetGroup Mobile platform (Only iOS, tvOS and Android).
         * @param buildTarget The NamedBuildTarget (Only iOS, tvOS and Android).
         */
        static SetMobileMTRendering(targetGroup: BuildTargetGroup, enable: boolean): void
        /** Enable or disable multithreaded rendering option for mobile platform.
         * @param targetGroup Mobile platform (Only iOS, tvOS and Android).
         * @param buildTarget The NamedBuildTarget (Only iOS, tvOS and Android).
         */
        static SetMobileMTRendering(buildTarget: NamedBuildTarget, enable: boolean): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         */
        static GetNormalMapEncoding(platform: BuildTargetGroup): NormalMapEncoding
        /** Gets the NormalMapEncoding for the build target you select.
         * @param buildTarget The NamedBuildTarget.
         */
        static GetNormalMapEncoding(buildTarget: NamedBuildTarget): NormalMapEncoding
        /** Sets the normal map encoding for the given build target.
         * @param encoding The desired normal map encoding.
         * @param buildTarget The NamedBuildTarget (only Android, iOS and tvOS).
         * @param platform The platform build target group whose normal map encoding you want to set.
         */
        static SetNormalMapEncoding(platform: BuildTargetGroup, encoding: NormalMapEncoding): void
        /** Sets the normal map encoding for the given build target.
         * @param encoding The desired normal map encoding.
         * @param buildTarget The NamedBuildTarget (only Android, iOS and tvOS).
         * @param platform The platform build target group whose normal map encoding you want to set.
         */
        static SetNormalMapEncoding(buildTarget: NamedBuildTarget, encoding: NormalMapEncoding): void
        /** Gets the user-specified symbols for script compilation for the build target you select.
         * @param buildTarget The NamedBuildTarget.
         * @param defines A string array where Unity stores the symbols for the given build target name.
         */
        static GetScriptingDefineSymbols(buildTarget: NamedBuildTarget, defines: jsb.Out<Array<string>>): void
        /** Gets the user-specified symbols for script compilation for the build target you select.
         * @param buildTarget The NamedBuildTarget.
         * @returns A string containing the symbols for the given build target name. 
         */
        static GetScriptingDefineSymbols(buildTarget: NamedBuildTarget): string
        /** Set user-specified symbols for script compilation for the given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param defines Symbols for this build target are passed as an array or as a string separated by semicolons.
         */
        static SetScriptingDefineSymbols(buildTarget: NamedBuildTarget, defines: string): void
        /** Set user-specified symbols for script compilation for the given build target.
         * @param buildTarget The NamedBuildTarget.
         * @param defines Symbols for this build target are passed as an array or as a string separated by semicolons.
         */
        static SetScriptingDefineSymbols(buildTarget: NamedBuildTarget, defines: Array<string>): void
        /** Gets an array of additional compiler arguments set for a specific NamedBuildTarget.
         * @param buildTarget The NamedBuildTarget to get the compiler arguments for.
         * @returns Returns an array with the compiler arguments associated with a NamedBuildTarget. 
         */
        static GetAdditionalCompilerArguments(buildTarget: NamedBuildTarget): Array<string>
        /** Sets additional compiler arguments for a build target.
         * @param buildTarget The NamedBuildTarget.
         * @param additionalCompilerArguments An array of the additional compiler arguments.
         */
        static SetAdditionalCompilerArguments(buildTarget: NamedBuildTarget, additionalCompilerArguments: Array<string>): void
        static GetAdditionalIl2CppArgs(): string
        /** Set additional arguments passed to the IL2CPP compiler during the build process.
         * @param additionalArgs The additional arguments passed to the IL2CPP compiler during the build process.
         */
        static SetAdditionalIl2CppArgs(additionalArgs: string): void
        static GetWsaHolographicRemotingEnabled(): boolean
        static SetWsaHolographicRemotingEnabled(enabled: boolean): void
        /** Gets stack trace logging options.
         */
        static GetStackTraceLogType(logType: any): any
        /** Set stack trace logging options.
Note: calling this function will implicitly call Application.SetStackTraceLogType.
         */
        static SetStackTraceLogType(logType: any, stackTraceType: any): void
        static GetVirtualTexturingSupportEnabled(): boolean
        /** Enable virtual texturing.
         * @param enabled True to enable, false to disable.
         */
        static SetVirtualTexturingSupportEnabled(enabled: boolean): void
        static GetShaderPrecisionModel(): ShaderPrecisionModel
        /** Sets the shader precision model.
         * @param model The new precision model to use.
         */
        static SetShaderPrecisionModel(model: ShaderPrecisionModel): void
        /** BuildTargetGroup is marked for deprecation in the future. Use NamedBuildTarget instead.
         * @param platform The full list of platforms that support this API and the supported icon kinds can be found in PlatformIconKind|icon kinds.
         * @param kind Each platform supports a different set of PlatformIconKind|icon kinds. These can be found in the specific platform namespace (for example iOSPlatformIconKind).
         */
        static GetPlatformIcons(platform: BuildTargetGroup, kind: PlatformIconKind): Array<PlatformIcon>
        /** Gets the list of available icon slots for the specified build target and  PlatformIconKind|kind.
         * @param buildTarget The NamedBuildTarget.
         * @param kind Each platform supports a different set of PlatformIconKind|icon kinds. These can be found in the specific platform namespace (for example iOSPlatformIconKind.
         */
        static GetPlatformIcons(buildTarget: NamedBuildTarget, kind: PlatformIconKind): Array<PlatformIcon>
        /** Assign a list of icons for the specified platform and icon kind.
         * @param platform The full list of platforms that support this API the supported  kinds can be found in PlatformIconKind|icon kinds.
         * @param icons All available PlatformIcon slots must be retrieved with GetPlatformIcons.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetPlatformIcons(platform: BuildTargetGroup, kind: PlatformIconKind, icons: Array<PlatformIcon>): void
        /** Assign a list of icons for the specified platform and icon kind.
         * @param platform The full list of platforms that support this API the supported  kinds can be found in PlatformIconKind|icon kinds.
         * @param icons All available PlatformIcon slots must be retrieved with GetPlatformIcons.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetPlatformIcons(buildTarget: NamedBuildTarget, kind: PlatformIconKind, icons: Array<PlatformIcon>): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetSupportedIconKinds instead.
         */
        static GetSupportedIconKindsForPlatform(platform: BuildTargetGroup): Array<PlatformIconKind>
        /** Retrieves all icon kinds that the specified build target supports
         * @param buildTarget The NamedBuildTarget.
         */
        static GetSupportedIconKinds(buildTarget: NamedBuildTarget): Array<PlatformIconKind>
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.SetIcons instead.
         */
        static SetIconsForTargetGroup(platform: BuildTargetGroup, icons: Array<Texture2D>, kind: IconKind): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.SetIcons instead.
         */
        static SetIconsForTargetGroup(platform: BuildTargetGroup, icons: Array<Texture2D>): void
        /** Assigns a list of icons for the specified platform.
         * @param buildTarget The NamedBuildTarget.
         */
        static SetIcons(buildTarget: NamedBuildTarget, icons: Array<Texture2D>, kind: IconKind): void
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetIcons instead.
         */
        static GetIconsForTargetGroup(platform: BuildTargetGroup, kind: IconKind): Array<Texture2D>
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetIcons instead.
         */
        static GetIconsForTargetGroup(platform: BuildTargetGroup): Array<Texture2D>
        /** Returns the list of assigned icons for the specified build target.
         * @param buildTarget The NamedBuildTarget.
         * @param kind The IconKind.
         */
        static GetIcons(buildTarget: NamedBuildTarget, kind: IconKind): Array<Texture2D>
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetIconSizes instead.
         */
        static GetIconSizesForTargetGroup(platform: BuildTargetGroup, kind: IconKind): Array<number>
        /** BuildTargetGroup is marked for deprecation in the future. Use PlayerSettings.GetIconSizes instead.
         */
        static GetIconSizesForTargetGroup(platform: BuildTargetGroup): Array<number>
        /** Returns a list of icon sizes for the specified platform.
         * @param buildTarget The NamedBuildTarget.
         */
        static GetIconSizes(buildTarget: NamedBuildTarget, kind: IconKind): Array<number>
        protected constructor()
        /** The name of your company.
         */
        static companyName: string
        /** The name of your product.
         */
        static productName: string
        static readonly productGUID: any
        /** Set the rendering color space for the current project.
         */
        static colorSpace: any
        /** Default horizontal dimension of stand-alone player window.
         */
        static defaultScreenWidth: number
        /** Default vertical dimension of stand-alone player window.
         */
        static defaultScreenHeight: number
        /** Default horizontal dimension of web player window.
         */
        static defaultWebScreenWidth: number
        /** Default vertical dimension of web player window.
         */
        static defaultWebScreenHeight: number
        static defaultIsNativeResolution: boolean
        /** Enable Retina support for macOS.
         */
        static macRetinaSupport: boolean
        /** If enabled, your game will continue to run after lost focus.
         */
        static runInBackground: boolean
        /** Defines if fullscreen games should darken secondary displays.
         */
        static captureSingleScreen: boolean
        /** Write a log file with debugging information.
         */
        static usePlayerLog: boolean
        /** Use resizable window in standalone player builds.
         */
        static resizableWindow: boolean
        /** Indicates whether to reset the application's screen resolution when the native window size changes.
         */
        static resetResolutionOnWindowResize: boolean
        /** Pre bake collision meshes on player build.
         */
        static bakeCollisionMeshes: boolean
        /** Enable receipt validation for the Mac App Store.
         */
        static useMacAppStoreValidation: boolean
        /** Platform agnostic setting to define fullscreen behavior. Not all platforms support all modes.
         */
        static fullScreenMode: any
        /** Enable 360 Stereo Capture support on the current build target.
         */
        static enable360StereoCapture: boolean
        /** Active stereo rendering path
         */
        static stereoRenderingPath: StereoRenderingPath
        /** Enable frame timing statistics.
         */
        static enableFrameTimingStats: boolean
        /** Enable ProfilerRecorder usage to record GPU timings when rendering with OpenGL.
         */
        static enableOpenGLProfilerGPURecorders: boolean
        /** Switch display to HDR mode (if available).
         */
        static useHDRDisplay: boolean
        /** The number of bits in each color channel for swap chain buffers. (Direct3D 11 and Direct3D 12 mode).
         */
        static D3DHDRBitDepth: any
        /** On Windows, shows the application in the background if the Fullscreen Windowed mode is used.
         */
        static visibleInBackground: boolean
        /** If enabled, allows the user to switch between full screen and windowed mode using OS specific keyboard short cuts.
         */
        static allowFullscreenSwitch: boolean
        /** Restrict standalone players to a single concurrent running instance.
         */
        static forceSingleInstance: boolean
        /** Use DXGI flip model swap chain for D3D11.
         */
        static useFlipModelSwapchain: boolean
        /** Specifies whether the application requires OpenGL ES 3.1 support.
         */
        static openGLRequireES31: boolean
        /** Specifies whether the application requires OpenGL ES 3.1 AEP support.
         */
        static openGLRequireES31AEP: boolean
        /** Specifies whether the application requires OpenGL ES 3.2 support.
         */
        static openGLRequireES32: boolean
        /** Virtual Reality specific splash screen.
         */
        static virtualRealitySplashScreen: Texture2D
        /** Set to true to exact version matching for strong named assemblies.
         */
        static assemblyVersionValidation: boolean
        /** Suppresses common C# warnings.
         */
        static suppressCommonWarnings: boolean
        /** Allow unsafe C# code to be compiled for predefined assemblies.
         */
        static allowUnsafeCode: boolean
        /** Allows you to enable or disable incremental mode for garbage collection.
         */
        static gcIncremental: boolean
        /** Password used for interacting with the Android Keystore.
         */
        static keystorePass: string
        /** Password for the key used for signing an Android application.
         */
        static keyaliasPass: string
        /** Enable GPU skinning on capable platforms.
         */
        static gpuSkinning: boolean
        /** Enable graphics jobs (multi threaded rendering).
         */
        static graphicsJobs: boolean
        /** Selects the graphics job mode to use on platforms that support both Native and Legacy graphics jobs.
         */
        static graphicsJobMode: GraphicsJobMode
        static readonly xboxPIXTextureCapture: boolean
        static readonly xboxEnableAvatar: boolean
        static readonly xboxOneResolution: number
        /** Enables internal profiler.
         */
        static enableInternalProfiler: boolean
        /** Sets the crash behavior on .NET unhandled exception.
         */
        static actionOnDotNetUnhandledException: ActionOnDotNetUnhandledException
        /** Are ObjC uncaught exceptions logged?
         */
        static logObjCUncaughtExceptions: boolean
        /** Enables CrashReport API.
         */
        static enableCrashReportAPI: boolean
        /** The application identifier for the currently selected build target.
         */
        static applicationIdentifier: string
        /** Application bundle version shared between iOS & Android platforms.
         */
        static bundleVersion: string
        /** Returns if status bar should be hidden. Supported on iOS only; on Android, the status bar is always hidden.
         */
        static statusBarHidden: boolean
        /** Remove unused Engine code from your build (IL2CPP-only).
         */
        static stripEngineCode: boolean
        /** Default screen orientation for mobiles.
         */
        static defaultInterfaceOrientation: UIOrientation
        /** Is auto-rotation to portrait supported?
         */
        static allowedAutorotateToPortrait: boolean
        /** Is auto-rotation to portrait upside-down supported?
         */
        static allowedAutorotateToPortraitUpsideDown: boolean
        /** Is auto-rotation to landscape right supported?
         */
        static allowedAutorotateToLandscapeRight: boolean
        /** Is auto-rotation to landscape left supported?
         */
        static allowedAutorotateToLandscapeLeft: boolean
        /** Let the OS autorotate the screen as the device orientation changes.
         */
        static useAnimatedAutorotation: boolean
        /** 32-bit Display Buffer is used.
         */
        static use32BitDisplayBuffer: boolean
        /** When enabled, preserves the alpha value in the framebuffer to support rendering over native UI on Android.
         */
        static preserveFramebufferAlpha: boolean
        /** Should unused Mesh components be excluded from game build?
         */
        static stripUnusedMeshComponents: boolean
        /** Enable mip stripping for all platforms.
         */
        static mipStripping: boolean
        /** Is the advanced version being used?
         */
        static readonly advancedLicense: boolean
        /** Additional AOT compilation options. Shared by AOT platforms.
         */
        static aotOptions: string
        /** The default cursor for your application.
         */
        static defaultCursor: Texture2D
        /** Default cursor's click position in pixels from the top left corner of the cursor image.
         */
        static cursorHotspot: Vector2
        /** Accelerometer update frequency.
         */
        static accelerometerFrequency: number
        /** Is multi-threaded rendering enabled?
         */
        static MTRendering: boolean
        /** Stops or allows audio from other applications to play in the background while your Unity application is running.
         */
        static muteOtherAudioSources: boolean
        /** Defines whether the BlendShape weight range in SkinnedMeshRenderers is clamped.
         */
        static legacyClampBlendShapeWeights: boolean
        /** Enables Metal API validation in the Editor.
         */
        static enableMetalAPIValidation: boolean
        /** Specifies the desired Windows API to be used for input.
         */
        static windowsGamepadBackendHint: WindowsGamepadBackendHint
        /** Enables Graphics.SetSRGBWrite() on Vulkan renderer.
         */
        static vulkanEnableSetSRGBWrite: boolean
        /** Set number of swapchain buffers to be used with Vulkan renderer
         */
        static vulkanNumSwapchainBuffers: number
        /** Delays acquiring the swapchain image until after the frame is rendered.
         */
        static vulkanEnableLateAcquireNextImage: boolean
        /** Applies the display rotation during rendering.
         */
        static vulkanEnablePreTransform: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSAApplicationShowName {
            NotSet = 0,
            AllLogos = 1,
            NoLogos = 2,
            StandardLogoOnly = 3,
            WideLogoOnly = 4,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSADefaultTileSize {
            NotSet = 0,
            Medium = 1,
            Wide = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSAApplicationForegroundText {
            Light = 1,
            Dark = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSACapability {
            EnterpriseAuthentication = 0,
            InternetClient = 1,
            InternetClientServer = 2,
            MusicLibrary = 3,
            PicturesLibrary = 4,
            PrivateNetworkClientServer = 5,
            RemovableStorage = 6,
            SharedUserCertificates = 7,
            VideosLibrary = 8,
            WebCam = 9,
            Proximity = 10,
            Microphone = 11,
            Location = 12,
            HumanInterfaceDevice = 13,
            AllJoyn = 14,
            BlockedChatMessages = 15,
            Chat = 16,
            CodeGeneration = 17,
            Objects3D = 18,
            PhoneCall = 19,
            UserAccountInformation = 20,
            VoipCall = 21,
            Bluetooth = 22,
            SpatialPerception = 23,
            InputInjectionBrokered = 24,
            Appointments = 25,
            BackgroundMediaPlayback = 26,
            Contacts = 27,
            LowLevelDevices = 28,
            OfflineMapsManagement = 29,
            PhoneCallHistoryPublic = 30,
            PointOfService = 31,
            RecordedCallsFolder = 32,
            RemoteSystem = 33,
            SystemManagement = 34,
            UserDataTasks = 35,
            UserNotificationListener = 36,
            GazeInput = 37,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSATargetFamily {
            Desktop = 0,
            Mobile = 1,
            Xbox = 2,
            Holographic = 3,
            Team = 4,
            IoT = 5,
            IoTHeadless = 6,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSAImageScale {
            Target16 = 16,
            Target24 = 24,
            Target32 = 32,
            Target48 = 48,
            _80 = 80,
            _100 = 100,
            _125 = 125,
            _140 = 140,
            _150 = 150,
            _180 = 180,
            _200 = 200,
            _240 = 240,
            Target256 = 256,
            _400 = 400,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSAImageType {
            PackageLogo = 1,
            SplashScreenImage = 2,
            UWPSquare44x44Logo = 31,
            UWPSquare71x71Logo = 32,
            UWPSquare150x150Logo = 33,
            UWPSquare310x310Logo = 34,
            UWPWide310x150Logo = 35,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings {
        enum WSAInputSource {
            CoreWindow = 0,
            IndependentInputSource = 1,
            SwapChainPanel = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class WSASupportedFileType extends ValueType {
            constructor()
            contentType: string
            fileType: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class WSAFileTypeAssociations extends ValueType {
            constructor()
            name: string
            supportedFileTypes: Array<PlayerSettings.WSASupportedFileType>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, DateTime, ValueType } from "System";
    import { Color } from "UnityEngine";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class WSA extends Object {
            constructor()
            static SetCertificate(path: string, password: string): boolean
            static GetVisualAssetsImage(type: PlayerSettings.WSAImageType, scale: PlayerSettings.WSAImageScale): string
            static SetVisualAssetsImage(image: string, type: PlayerSettings.WSAImageType, scale: PlayerSettings.WSAImageScale): void
            static SetCapability(capability: PlayerSettings.WSACapability, value: boolean): void
            static GetCapability(capability: PlayerSettings.WSACapability): boolean
            static SetTargetDeviceFamily(family: PlayerSettings.WSATargetFamily, value: boolean): void
            static GetTargetDeviceFamily(family: PlayerSettings.WSATargetFamily): boolean
            static transparentSwapchain: boolean
            static packageName: string
            static readonly certificatePath: string
            static readonly certificateSubject: string
            static readonly certificateIssuer: string
            static applicationDescription: string
            static tileShortName: string
            static tileShowName: PlayerSettings.WSAApplicationShowName
            static mediumTileShowName: boolean
            static largeTileShowName: boolean
            static wideTileShowName: boolean
            static defaultTileSize: PlayerSettings.WSADefaultTileSize
            static tileForegroundText: PlayerSettings.WSAApplicationForegroundText
            static tileBackgroundColor: Color
            static inputSource: PlayerSettings.WSAInputSource
            static supportStreamingInstall: boolean
            static lastRequiredScene: number
            static syncCapabilities: boolean
            static vcxProjDefaultLanguage: string
            static packageVersion: any
            static readonly certificateNotAfter: jsb.Nullable<DateTime>
            static splashScreenBackgroundColor: jsb.Nullable<Color>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PlayerSettings.WSA {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class Declarations extends Object {
            static protocolName: string
            static fileTypeAssociations: PlayerSettings.WSAFileTypeAssociations
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Sprite, Color } from "UnityEngine";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class SplashScreen extends Object {
            constructor()
            static animationMode: PlayerSettings.SplashScreen.AnimationMode
            static animationBackgroundZoom: number
            static animationLogoZoom: number
            static background: Sprite
            static backgroundPortrait: Sprite
            static blurBackgroundImage: boolean
            static backgroundColor: Color
            static drawMode: PlayerSettings.SplashScreen.DrawMode
            static logos: Array<PlayerSettings.SplashScreenLogo>
            static overlayOpacity: number
            static show: boolean
            static showUnityLogo: boolean
            static unityLogoStyle: PlayerSettings.SplashScreen.UnityLogoStyle
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.SplashScreen {
        enum AnimationMode {
            Static = 0,
            Dolly = 1,
            Custom = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.SplashScreen {
        enum DrawMode {
            UnityLogoBelow = 0,
            AllSequential = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.SplashScreen {
        enum UnityLogoStyle {
            DarkOnLight = 0,
            LightOnDark = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class XboxOne extends Object {
            constructor()
            static SetCapability(capability: string, value: boolean): void
            static GetCapability(capability: string): boolean
            static SetSupportedLanguage(language: string, enabled: boolean): void
            static GetSupportedLanguage(language: string): boolean
            static RemoveSocketDefinition(name: string): void
            static SetSocketDefinition(name: string, port: string, protocol: number, usages: Array<number>, templateName: string, sessionRequirment: number, deviceUsages: Array<number>): void
            static GetSocketDefinition(name: string, port: jsb.Out<string>, protocol: jsb.Out<number>, usages: jsb.Out<Array<number>>, templateName: jsb.Out<string>, sessionRequirment: jsb.Out<number>, deviceUsages: jsb.Out<Array<number>>): void
            static RemoveAllowedProductId(id: string): void
            static AddAllowedProductId(id: string): boolean
            static UpdateAllowedProductId(idx: number, id: string): void
            static XTitleMemory: number
            static defaultLoggingLevel: XboxOneLoggingLevel
            static ProductId: string
            static UpdateKey: string
            static ContentId: string
            static TitleId: string
            static SCID: string
            static EnableVariableGPU: boolean
            static PresentImmediateThreshold: number
            static Enable7thCore: boolean
            static DisableKinectGpuReservation: boolean
            static EnablePIXSampling: boolean
            static GameOsOverridePath: string
            static PackagingOverridePath: string
            static PackagingEncryption: XboxOneEncryptionLevel
            static PackageUpdateGranularity: XboxOnePackageUpdateGranularity
            static OverrideIdentityName: string
            static OverrideIdentityPublisher: string
            static AppManifestOverridePath: string
            static IsContentPackage: boolean
            static EnhancedXboxCompatibilityMode: boolean
            static Version: string
            static Description: string
            static readonly SocketNames: Array<string>
            static readonly AllowedProductIds: Array<string>
            static PersistentLocalStorageSize: number
            static EnableTypeOptimization: boolean
            static monoLoggingLevel: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class tvOS extends Object {
            constructor()
            static sdkVersion: tvOSSdkVersion
            static buildNumber: string
            static targetOSVersionString: string
            static requireExtendedGameController: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Sprite } from "UnityEngine";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class SplashScreenLogo extends ValueType {
            constructor()
            static Create(duration: number, logo: Sprite): PlayerSettings.SplashScreenLogo
            static Create(duration: number): PlayerSettings.SplashScreenLogo
            static Create(): PlayerSettings.SplashScreenLogo
            static CreateWithUnityLogo(duration: number): PlayerSettings.SplashScreenLogo
            static CreateWithUnityLogo(): PlayerSettings.SplashScreenLogo
            logo: Sprite
            static readonly unityLogo: Sprite
            duration: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class EmbeddedLinux extends Object {
            constructor()
            static playerDataPath: string
            static forceSRGBBlit: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Lumin extends Object {
            constructor()
            static iconModelFolderPath: string
            static iconPortalFolderPath: string
            static certificatePath: string
            static signPackage: boolean
            static isChannelApp: boolean
            static versionCode: number
            static versionName: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class macOS extends Object {
            constructor()
            static buildNumber: string
            static applicationCategoryType: string
            static cameraUsageDescription: string
            static microphoneUsageDescription: string
            static bluetoothUsageDescription: string
            static urlSchemes: Array<string>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class WebGL extends Object {
            constructor()
            static memorySize: number
            static exceptionSupport: WebGLExceptionSupport
            static dataCaching: boolean
            static emscriptenArgs: string
            static modulesDirectory: string
            static template: string
            static analyzeBuildSize: boolean
            static useEmbeddedResources: boolean
            static threadsSupport: boolean
            static linkerTarget: WebGLLinkerTarget
            static compressionFormat: WebGLCompressionFormat
            static nameFilesAsHashes: boolean
            static debugSymbolMode: WebGLDebugSymbolMode
            static decompressionFallback: boolean
            static wasmArithmeticExceptions: WebGLWasmArithmeticExceptions
            static powerPreference: WebGLPowerPreference
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Texture2D } from "UnityEngine";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Switch extends Object {
            constructor()
            static GetRatingAge(category: PlayerSettings.Switch.RatingCategories): number
            static socketMemoryPoolSize: number
            static socketAllocatorPoolSize: number
            static socketConcurrencyLimit: number
            static useSwitchCPUProfiler: boolean
            static enableFileSystemTrace: boolean
            static switchLTOSetting: number
            static systemResourceMemory: number
            static queueCommandMemory: number
            static readonly defaultSwitchQueueCommandMemory: number
            static readonly minimumSwitchQueueCommandMemory: number
            static queueControlMemory: number
            static readonly defaultSwitchQueueControlMemory: number
            static readonly minimumSwitchQueueControlMemory: number
            static queueComputeMemory: number
            static readonly defaultSwitchQueueComputeMemory: number
            static NVNShaderPoolsGranularity: number
            static NVNDefaultPoolsGranularity: number
            static NVNOtherPoolsGranularity: number
            static NVNMaxPublicTextureIDCount: number
            static NVNMaxPublicSamplerIDCount: number
            static switchMaxWorkerMultiple: number
            static screenResolutionBehavior: PlayerSettings.Switch.ScreenResolutionBehavior
            static NMETAOverride: string
            static readonly NMETAOverrideFullPath: string
            static applicationID: string
            static nsoDependencies: string
            static titleNames: Array<string>
            static publisherNames: Array<string>
            static icons: Array<Texture2D>
            static smallIcons: Array<Texture2D>
            static manualHTMLPath: string
            static accessibleURLPath: string
            static legalInformationPath: string
            static mainThreadStackSize: number
            static presenceGroupId: string
            static logoHandling: PlayerSettings.Switch.LogoHandling
            static releaseVersion: string
            static displayVersion: string
            static startupUserAccount: PlayerSettings.Switch.StartupUserAccount
            static supportedLanguages: number
            static logoType: PlayerSettings.Switch.LogoType
            static applicationErrorCodeCategory: string
            static userAccountSaveDataSize: number
            static userAccountSaveDataJournalSize: number
            static applicationAttribute: PlayerSettings.Switch.ApplicationAttribute
            static cardSpecSize: number
            static cardSpecClock: number
            static ratingsMask: number
            static localCommunicationIds: Array<string>
            static isUnderParentalControl: boolean
            static isScreenshotEnabled: boolean
            static isVideoCapturingEnabled: boolean
            static isRuntimeAddOnContentInstallEnabled: boolean
            static isDataLossConfirmationEnabled: boolean
            static isUserAccountLockEnabled: boolean
            static supportedNpadStyles: PlayerSettings.Switch.SupportedNpadStyle
            static ratingAgeArray: Array<number>
            static nativeFsCacheSize: number
            static isHoldTypeHorizontal: boolean
            static supportedNpadCount: number
            static enableTouchScreen: boolean
            static socketConfigEnabled: boolean
            static tcpInitialSendBufferSize: number
            static tcpInitialReceiveBufferSize: number
            static tcpAutoSendBufferSizeMax: number
            static tcpAutoReceiveBufferSizeMax: number
            static udpSendBufferSize: number
            static udpReceiveBufferSize: number
            static socketBufferEfficiency: number
            static socketInitializeEnabled: boolean
            static networkInterfaceManagerInitializeEnabled: boolean
            static useNewStyleFilepaths: boolean
            static switchUseLegacyFmodPriorities: boolean
            static switchUseMicroSleepForYield: boolean
            static switchMicroSleepForYieldTime: number
            static switchEnableRamDiskSupport: boolean
            static switchRamDiskSpaceSize: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum ScreenResolutionBehavior {
            Manual = 0,
            OperationMode = 1,
            PerformanceMode = 2,
            Both = 3,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum Languages {
            AmericanEnglish = 0,
            BritishEnglish = 1,
            Japanese = 2,
            French = 3,
            German = 4,
            LatinAmericanSpanish = 5,
            Spanish = 6,
            Italian = 7,
            Dutch = 8,
            CanadianFrench = 9,
            Portuguese = 10,
            Russian = 11,
            SimplifiedChinese = 12,
            TraditionalChinese = 13,
            Korean = 14,
            BrazilianPortuguese = 15,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum StartupUserAccount {
            None = 0,
            Required = 1,
            RequiredWithNetworkServiceAccountAvailable = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum LogoHandling {
            Auto = 0,
            Manual = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum LogoType {
            LicensedByNintendo = 0,
            DistributedByNintendo = 1,
            Nintendo = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum ApplicationAttribute {
            None = 0,
            Demo = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum RatingCategories {
            CERO = 0,
            GRACGCRB = 1,
            GSRMR = 2,
            ESRB = 3,
            ClassInd = 4,
            USK = 5,
            PEGI = 6,
            PEGIPortugal = 7,
            PEGIBBFC = 8,
            Russian = 9,
            ACB = 10,
            OFLC = 11,
            IARCGeneric = 12,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.Switch {
        enum SupportedNpadStyle {
            FullKey = 2,
            Handheld = 4,
            JoyDual = 16,
            JoyLeft = 256,
            JoyRight = 65536,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Android extends Object {
            constructor()
            static disableDepthAndStencilBuffers: boolean
            static defaultWindowWidth: number
            static defaultWindowHeight: number
            static minimumWindowWidth: number
            static minimumWindowHeight: number
            static resizableWindow: boolean
            static fullscreenMode: any
            static autoRotationBehavior: AndroidAutoRotationBehavior
            static bundleVersionCode: number
            static minSdkVersion: any
            static targetSdkVersion: any
            static preferredInstallLocation: any
            static forceInternetPermission: boolean
            static forceSDCardPermission: boolean
            static androidTVCompatibility: boolean
            static androidIsGame: boolean
            static ARCoreEnabled: boolean
            static chromeosInputEmulation: boolean
            static targetArchitectures: any
            static buildApkPerCpuArchitecture: boolean
            static androidTargetDevices: AndroidTargetDevices
            static splashScreenScale: any
            static useCustomKeystore: boolean
            static keystoreName: string
            static keystorePass: string
            static keyaliasName: string
            static keyaliasPass: string
            static readonly licenseVerification: boolean
            static useAPKExpansionFiles: boolean
            static showActivityIndicatorOnLoading: any
            static blitType: any
            static maxAspectRatio: number
            static startInFullscreen: boolean
            static renderOutsideSafeArea: boolean
            static minifyWithR8: boolean
            static minifyRelease: boolean
            static minifyDebug: boolean
            static optimizedFramePacing: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum, Array } from "System";
    import { Texture2D } from "UnityEngine";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class iOS extends Object {
            constructor()
            static SetLaunchScreenImage(image: Texture2D, type: iOSLaunchScreenImageType): void
            static SetiPhoneLaunchScreenType(type: iOSLaunchScreenType): void
            static SetiPadLaunchScreenType(type: iOSLaunchScreenType): void
            static applicationDisplayName: string
            static buildNumber: string
            static disableDepthAndStencilBuffers: boolean
            static scriptCallOptimization: ScriptCallOptimizationLevel
            static sdkVersion: iOSSdkVersion
            static targetOSVersionString: string
            static targetDevice: iOSTargetDevice
            static prerenderedIcon: boolean
            static requiresPersistentWiFi: boolean
            static requiresFullScreen: boolean
            static statusBarStyle: iOSStatusBarStyle
            static deferSystemGesturesMode: any
            static hideHomeButton: boolean
            static appInBackgroundBehavior: iOSAppInBackgroundBehavior
            static backgroundModes: iOSBackgroundMode
            static forceHardShadowsOnMetal: boolean
            static allowHTTPDownload: boolean
            static appleDeveloperTeamID: string
            static iOSManualProvisioningProfileID: string
            static tvOSManualProvisioningProfileID: string
            static tvOSManualProvisioningProfileType: ProvisioningProfileType
            static iOSManualProvisioningProfileType: ProvisioningProfileType
            static appleEnableAutomaticSigning: boolean
            static cameraUsageDescription: string
            static locationUsageDescription: string
            static microphoneUsageDescription: string
            static showActivityIndicatorOnLoading: iOSShowActivityIndicatorOnLoading
            static useOnDemandResources: boolean
            static iOSUrlSchemes: Array<string>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    namespace PlayerSettings {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class PS4 extends Object {
            constructor()
            static npTrophyPackPath: string
            static npAgeRating: number
            static npTitleSecret: string
            static parentalLevel: number
            static applicationParameter1: number
            static applicationParameter2: number
            static applicationParameter3: number
            static applicationParameter4: number
            static passcode: string
            static monoEnv: string
            static playerPrefsSupport: boolean
            static restrictedAudioUsageRights: boolean
            static useResolutionFallback: boolean
            static contentID: string
            static category: PlayerSettings.PS4.PS4AppCategory
            static appType: number
            static masterVersion: string
            static appVersion: string
            static remotePlayKeyAssignment: PlayerSettings.PS4.PS4RemotePlayKeyAssignment
            static remotePlayKeyMappingDir: string
            static playTogetherPlayerCount: number
            static enterButtonAssignment: PlayerSettings.PS4.PS4EnterButtonAssignment
            static paramSfxPath: string
            static videoOutPixelFormat: number
            static videoOutInitialWidth: number
            static SdkOverride: string
            static videoOutBaseModeInitialWidth: number
            static videoOutReprojectionRate: number
            static PronunciationXMLPath: string
            static PronunciationSIGPath: string
            static BackgroundImagePath: string
            static StartupImagePath: string
            static startupImagesFolder: string
            static iconImagesFolder: string
            static SaveDataImagePath: string
            static BGMPath: string
            static ShareFilePath: string
            static ShareOverlayImagePath: string
            static PrivacyGuardImagePath: string
            static ExtraSceSysFile: string
            static patchDayOne: boolean
            static PatchPkgPath: string
            static PatchLatestPkgPath: string
            static PatchChangeinfoPath: string
            static NPtitleDatPath: string
            static pnSessions: boolean
            static pnPresence: boolean
            static pnFriends: boolean
            static pnGameCustomData: boolean
            static downloadDataSize: number
            static garlicHeapSize: number
            static proGarlicHeapSize: number
            static reprojectionSupport: boolean
            static useAudio3dBackend: boolean
            static audio3dVirtualSpeakerCount: number
            static scriptOptimizationLevel: number
            static useLowGarlicFragmentationMode: boolean
            static socialScreenEnabled: number
            static attribUserManagement: boolean
            static attribMoveSupport: boolean
            static attrib3DSupport: boolean
            static attribShareSupport: boolean
            static attribExclusiveVR: boolean
            static disableAutoHideSplash: boolean
            static attribCpuUsage: number
            static videoRecordingFeaturesUsed: boolean
            static contentSearchFeaturesUsed: boolean
            static attribEyeToEyeDistanceSettingVR: PlayerSettings.PS4.PlayStationVREyeToEyeDistanceSettings
            static includedModules: Array<string>
            static enableApplicationExit: boolean
            static resetTempFolder: boolean
            static playerPrefsMaxSize: number
            static attribVROutputEnabled: boolean
            static compatibilityPS5: boolean
            static allowPS5Detection: boolean
            static gpu800MHz: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.PS4 {
        enum PS4AppCategory {
            Application = 0,
            Patch = 1,
            Remaster = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.PS4 {
        enum PS4RemotePlayKeyAssignment {
            PatternA = 0,
            PatternB = 1,
            PatternC = 2,
            PatternD = 3,
            PatternE = 4,
            PatternF = 5,
            PatternG = 6,
            PatternH = 7,
            None = -1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.PS4 {
        enum PS4EnterButtonAssignment {
            CircleButton = 0,
            CrossButton = 1,
            SystemDefined = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PlayerSettings.PS4 {
        enum PlayStationVREyeToEyeDistanceSettings {
            PerUser = 0,
            ForceDefault = 1,
            DynamicModeAtRuntime = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Scripting implementation (backend).
     */
    enum ScriptingImplementation {
        /** The standard Mono 2.6 runtime.
         */
        Mono2x = 0,
        /** Unity's .NET runtime.
         */
        IL2CPP = 1,
        /** Microsoft's .NET runtime.
         */
        WinRTDotNET = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** C++ compiler configuration used when compiling IL2CPP generated code.
     */
    enum Il2CppCompilerConfiguration {
        /** Debug configuration turns off all optimizations, which makes the code quicker to build but slower to run.
         */
        Debug = 0,
        /** Release configuration enables optimizations, so the compiled code runs faster and the binary size is smaller but it takes longer to compile.
         */
        Release = 1,
        /** Master configuration enables all possible optimizations, squeezing every bit of performance possible. For instance, on platforms that use the MSVC++ compiler, this option enables link-time code generation. Compiling code using this configuration can take significantly longer than it does using the Release configuration. Unity recommends building the shipping version of your game using the Master configuration if the increase in build time is acceptable.
         */
        Master = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Aspect ratio.
     */
    enum AspectRatio {
        /** Undefined aspect ratios.
         */
        AspectOthers = 0,
        /** 4:3 aspect ratio.
         */
        Aspect4by3 = 1,
        /** 5:4 aspect ratio.
         */
        Aspect5by4 = 2,
        /** 16:10 aspect ratio.
         */
        Aspect16by10 = 3,
        /** 16:9 aspect ratio.
         */
        Aspect16by9 = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Mac fullscreen mode.
     */
    enum MacFullscreenMode {
        CaptureDisplay = 0,
        /** Fullscreen window.
         */
        FullscreenWindow = 1,
        /** Fullscreen window with Dock and Menu bar.
         */
        FullscreenWindowWithDockAndMenuBar = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Direct3D 11 fullscreen mode.
     */
    enum D3D11FullscreenMode {
        /** Exclusive mode.
         */
        ExclusiveMode = 0,
        /** Fullscreen window.
         */
        FullscreenWindow = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum used to specify what stereo rendering path to use.
     */
    enum StereoRenderingPath {
        /** Multiple pass VR rendering.
         */
        MultiPass = 0,
        /** Single pass VR rendering ( via double-wide render texture ).
         */
        SinglePass = 1,
        /** Single pass VR rendering ( via instanced rendering ).
         */
        Instancing = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Managed code stripping level.
     */
    enum StrippingLevel {
        /** Deprecated. See ManagedStrippingLevel.
         */
        Disabled = 0,
        /** Deprecated. See ManagedStrippingLevel.
         */
        StripAssemblies = 1,
        /** Deprecated. See ManagedStrippingLevel.
         */
        StripByteCode = 2,
        /** Deprecated. See ManagedStrippingLevel.
         */
        UseMicroMSCorlib = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Script call optimization level.
     */
    enum ScriptCallOptimizationLevel {
        /** Default setting.
         */
        SlowAndSafe = 0,
        /** Script method call overhead decreased at the expense of limited compatibility.
         */
        FastButNoExceptions = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** .NET API compatibility level.
     */
    enum ApiCompatibilityLevel {
        /** .NET 2.0.
         */
        NET_2_0 = 1,
        /** .NET 2.0 Subset.
         */
        NET_2_0_Subset = 2,
        /** Profile that targets the union of the .NET Framework 4.8 and .NET Standard 2.1 API
         */
        NET_4_6 = 3,
        /** Profile that targets the union of the .NET Framework 4.8 and .NET Standard 2.1 API
         */
        NET_Unity_4_8 = 3,
        /** Web profile, formerly used only by Samsung TV.
         */
        NET_Web = 4,
        /** Micro profile, used by Mono scripting backend on iOS, tvOS, and Android if stripping level is set to "Use micro mscorlib".
         */
        NET_Micro = 5,
        /** Deprecated, use ApiCompatibilityLevel.NET_Standard instead.
         */
        NET_Standard_2_0 = 6,
        /** Deprecated, use ApiCompatibilityLevel.NET_Standard instead.
         */
        NET_Standard = 6,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Defines how aggressively Unity strips unused managed (C#) code.
     */
    enum ManagedStrippingLevel {
        /** Do not strip any code.
         */
        Disabled = 0,
        /** Remove unreachable managed code to reduce build size and Mono/IL2CPP build times.
         */
        Low = 1,
        /** Run UnityLinker in a less conservative mode than Low. This will further reduce code size beyond what Low can achieve. However, this additional reduction may come with tradeoffs. Possible side effects may include, having to maintain a custom link.xml file, and some reflection code paths may not behave the same.
         */
        Medium = 2,
        /** UnityLinker will strip as much as possible. This will further reduce code size beyond what Medium can achieve. However, this additional reduction may come with tradeoffs. Possible side effects may include, managed code debugging of some methods may no longer work.  You may need to maintain a custom link.xml file, and some reflection code paths may not behave the same.
         */
        High = 3,
        /** The class libraries, UnityEngine, and Windows Runtime assemblies will be stripped. All other assemblies are copied.
         */
        Minimal = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The behavior in case of unhandled .NET exception.
     */
    enum ActionOnDotNetUnhandledException {
        /** Silent exit in case of unhandled .NET exception (no Crash Report generated).
         */
        SilentExit = 0,
        /** Crash in case of unhandled .NET exception (Crash Report will be generated).
         */
        Crash = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum used to specify the graphics jobs mode to use.
     */
    enum GraphicsJobMode {
        /** Native graphics jobs.
         */
        Native = 0,
        /** Legacy graphics jobs.
         */
        Legacy = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Icon kind.
     */
    enum IconKind {
        /** This icon is used for the main application icons.
         */
        Application = 0,
        /** This icon is used for settings.
         */
        Settings = 1,
        /** This icon is used for push notifications.
         */
        Notification = 2,
        /** This icon is used for Spotlight searches. (iOS only).
         */
        Spotlight = 3,
        /** This icon is used by the iOS App Store.
         */
        Store = 4,
        /** This icon can be used for any purpose in an application.
         */
        Any = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for the shader precision model.
     */
    enum ShaderPrecisionModel {
        /** Use the target platform defaults for sampler precision. This results in lower precision on mobile targets and full precision elsewhere.
         */
        PlatformDefault = 0,
        /** Use full sampler precision by default and make it so you have to explicitly declare when you want to use lower precision. This sets Rendering.BuiltinShaderDefine.UNITY_UNIFIED_SHADER_PRECISION_MODEL when Unity compiles shaders.
         */
        Unified = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Describes the encoding of normal maps.
     */
    enum NormalMapEncoding {
        /** Three-component normal map encoding.
         */
        XYZ = 0,
        /** Two-component DXT5nm-style normal map encoding.
         */
        DXT5nm = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Specifies the desired Windows API to be used for input.
     */
    enum WindowsGamepadBackendHint {
        /** Select a Windows Input API automatically based on platform support.
         */
        WindowsGamepadBackendHintDefault = 0,
        /** Windows XInput API.
         */
        WindowsGamepadBackendHintXInput = 1,
        /** Windows GameInput API.
         */
        WindowsGamepadBackendHintWindowsGamingInput = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** This class has event dispatchers for assembly reload events.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class AssemblyReloadEvents extends Object {
        static beforeAssemblyReload(op: "add" | "remove", fn: () => void): void
        static afterAssemblyReload(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum that selects which skin to return from EditorGUIUtility.GetBuiltinSkin.
     */
    enum EditorSkin {
        /** The skin used for game views.
         */
        Game = 0,
        /** The skin used for inspectors.
         */
        Inspector = 1,
        /** The skin used for Scene views.
         */
        Scene = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    namespace EditorGUIUtility {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class PropertyCallbackScope extends Object {
            constructor(callback: (arg1: Rect, arg2: SerializedProperty) => void)
            Dispose(): void
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, Vector2 } from "UnityEngine";
    namespace EditorGUIUtility {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class IconSizeScope extends GUI.Scope {
            constructor(iconSizeWithinScope: Vector2)
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Vector3 } from "UnityEngine";
    /** SessionState is a Key-Value Store intended for storing and retrieving Editor session state that should survive assembly reloading.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SessionState extends Object {
        constructor()
        /** Store a Boolean value.
         */
        static SetBool(key: string, value: boolean): void
        /** Retrieve a Boolean value.
         */
        static GetBool(key: string, defaultValue: boolean): boolean
        /** Erase a Boolean entry in the key-value store.
         */
        static EraseBool(key: string): void
        /** Store a Float value.
         */
        static SetFloat(key: string, value: number): void
        /** Retrieve a Float value.
         */
        static GetFloat(key: string, defaultValue: number): number
        /** Erase a Float entry in the key-value store.
         */
        static EraseFloat(key: string): void
        /** Store an Integer value.
         */
        static SetInt(key: string, value: number): void
        /** Retrieve an Integer value.
         */
        static GetInt(key: string, defaultValue: number): number
        /** Erase an Integer entry in the key-value store.
         */
        static EraseInt(key: string): void
        /** Store a String value.
         */
        static SetString(key: string, value: string): void
        /** Retrieve a String value.
         */
        static GetString(key: string, defaultValue: string): string
        /** Erase a String entry in the key-value store.
         */
        static EraseString(key: string): void
        /** Store a Vector3.
         */
        static SetVector3(key: string, value: Vector3): void
        /** Retrieve a Vector3.
         */
        static GetVector3(key: string, defaultValue: Vector3): Vector3
        /** Erase a Vector3 entry in the key-value store.
         */
        static EraseVector3(key: string): void
        /** Erase an Integer array entry in the key-value store.
         */
        static EraseIntArray(key: string): void
        /** Store an Integer array.
         */
        static SetIntArray(key: string, value: Array<number>): void
        /** Retrieve an Integer array.
         */
        static GetIntArray(key: string, defaultValue: Array<number>): Array<number>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Enum, Array } from "System";
    import { OverrideTextureCompression, Il2CppCodeGeneration, NamedBuildTarget } from "UnityEditor.Build";
    /** User build settings for the Editor
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorUserBuildSettings extends Object {
        /** Select a new build target to be active.
         * @param target Target build platform.
         * @param targetGroup Build target group.
         * @returns True if the build target was successfully switched, false otherwise (for example, if license checks fail, files are missing, or if the user has cancelled the operation via the UI). 
         */
        static SwitchActiveBuildTarget(targetGroup: BuildTargetGroup, target: BuildTarget): boolean
        static SwitchActiveBuildTarget(namedBuildTarget: NamedBuildTarget, target: BuildTarget): boolean
        /** Select a new build target to be active during the next Editor update.
         * @param targetGroup Target build platform.
         * @param target Build target group.
         * @returns True if the build target was successfully switched, false otherwise (for example, if license checks fail, files are missing, or if the user has cancelled the operation via the UI). 
         */
        static SwitchActiveBuildTargetAsync(targetGroup: BuildTargetGroup, target: BuildTarget): boolean
        /** Get the current location for the build.
         */
        static GetBuildLocation(target: BuildTarget): string
        /** Set a new location for the build.
         */
        static SetBuildLocation(target: BuildTarget, location: string): void
        static SetPlatformSettings(buildTargetGroup: string, buildTarget: string, name: string, value: string): void
        static SetPlatformSettings(platformName: string, name: string, value: string): void
        static GetPlatformSettings(buildTargetGroup: string, platformName: string, name: string): string
        static GetPlatformSettings(platformName: string, name: string): string
        protected constructor()
        /** The currently selected build target group.
         */
        static selectedBuildTargetGroup: BuildTargetGroup
        static selectedEmbeddedLinuxArchitecture: EmbeddedLinuxArchitecture
        static remoteDeviceInfo: boolean
        static remoteDeviceAddress: string
        static remoteDeviceUsername: string
        static remoteDeviceExports: string
        static pathOnRemoteDevice: string
        /** The currently selected target for a standalone build.
         */
        static selectedStandaloneTarget: BuildTarget
        /** Desktop standalone build subtarget.
         */
        static standaloneBuildSubtarget: StandaloneBuildSubtarget
        /** PS4 Build Subtarget.
         */
        static ps4BuildSubtarget: PS4BuildSubtarget
        /** Specifies which version of PS4 hardware to target.
         */
        static ps4HardwareTarget: PS4HardwareTarget
        /** Are null references actively validated?
         */
        static explicitNullChecks: boolean
        /** Are divide by zero's actively validated?
         */
        static explicitDivideByZeroChecks: boolean
        /** Are array bounds actively validated?
         */
        static explicitArrayBoundsChecks: boolean
        /** Build submission materials.
         */
        static needSubmissionMaterials: boolean
        /** Force installation of package, even if error.
         */
        static forceInstallation: boolean
        /** Places the package on the outer edge of the disk.
         */
        static movePackageToDiscOuterEdge: boolean
        /** Compress files in package.
         */
        static compressFilesInPackage: boolean
        /** Is build script only enabled.
         */
        static buildScriptsOnly: boolean
        /** Xbox Build subtarget.
         */
        static xboxBuildSubtarget: XboxBuildSubtarget
        /** When building an Xbox One Streaming Install package (makepkg.exe) The layout generation code in Unity will assign each Scene and associated assets to individual chunks. Unity will mark Scene 0 as being part of the launch range, IE the set of chunks required to launch the game, you may include additional Scenes in this launch range if you desire, this specifies a range of Scenes (starting at 0) to be included in the launch set. 
         */
        static streamingInstallLaunchRange: number
        /** The currently selected Xbox One Deploy Method.
         */
        static xboxOneDeployMethod: XboxOneDeployMethod
        /** The currently selected Xbox One Deploy Drive.
         */
        static xboxOneDeployDrive: XboxOneDeployDrive
        static xboxOneAdditionalDebugPorts: string
        /** Sets the XBox to reboot and redeploy when the deployment fails.
         */
        static xboxOneRebootIfDeployFailsAndRetry: boolean
        /** Android platform options.
         */
        static androidBuildSubtarget: MobileTextureSubtarget
        /** WebGL Build subtarget.
         */
        static webGLBuildSubtarget: WebGLTextureSubtarget
        /** ETC2 texture decompression fallback on Android devices that don't support ETC2.
         */
        static androidETC2Fallback: any
        static androidBuildSystem: any
        static androidBuildType: any
        /** Specifies the type of symbol package to create.
         */
        static androidCreateSymbols: AndroidCreateSymbols
        /** The build type for the Universal Windows Platform.
         */
        static wsaUWPBuildType: any
        /** Sets and gets target UWP SDK to build Windows Store application against.
         */
        static wsaUWPSDK: string
        static wsaMinUWPSDK: string
        static wsaArchitecture: string
        /** Sets and gets Visual Studio version to build Windows Store application with.
         */
        static wsaUWPVisualStudioVersion: string
        /** Specifies the Windows DevicePortal connection address of the device to deploy and launch the UWP app on when using Build and Run.
         */
        static windowsDevicePortalAddress: string
        /** Specifies the Windows DevicePortal username for the device to deploy and launch the UWP app on when using Build and Run.
         */
        static windowsDevicePortalUsername: string
        /** Specifies the Windows DevicePortal password for the device to deploy and launch the UWP app on when using Build and Run.
         */
        static windowsDevicePortalPassword: string
        /** Sets and gets the Windows device to launch the UWP app when using Build and Run.
         */
        static wsaBuildAndRunDeployTarget: any
        /** The override for the maximum texture size when importing assets.
         */
        static overrideMaxTextureSize: number
        /** The asset importing override of texture compression.
         */
        static overrideTextureCompression: OverrideTextureCompression
        /** The currently active build target.
         */
        static readonly activeBuildTarget: BuildTarget
        /** DEFINE directives for the compiler.
         */
        static readonly activeScriptCompilationDefines: Array<string>
        /** Enables a development build.
         */
        static development: boolean
        /** Specifies code generation option for IL2CPP.
         */
        static il2CppCodeGeneration: Il2CppCodeGeneration
        /** Start the player with a connection to the profiler.
         */
        static connectProfiler: boolean
        /** Enables Deep Profiling support in the player.
         */
        static buildWithDeepProfilingSupport: boolean
        /** Enable source-level debuggers to connect.
         */
        static allowDebugging: boolean
        /** Sets the Player to wait for player connection on player start.
         */
        static waitForPlayerConnection: boolean
        /** Export Android Project for use with Android Studio/Gradle.
         */
        static exportAsGoogleAndroidProject: boolean
        /** Set to true to build an Android App Bundle (aab file) instead of an apk. The default value is false.
         */
        static buildAppBundle: boolean
        /** Symlink sources when generating the project.
         */
        static symlinkSources: boolean
        /** The scheme Xcode uses to run this project.
         */
        static iOSXcodeBuildConfig: XcodeBuildConfig
        /** The scheme Xcode uses to run this project.
         */
        static macOSXcodeBuildConfig: XcodeBuildConfig
        static switchCreateRomFile: boolean
        static switchEnableRomCompression: boolean
        static switchSaveADF: boolean
        static switchRomCompressionType: SwitchRomCompressionType
        static switchRomCompressionLevel: number
        static switchRomCompressionConfig: string
        static switchNVNGraphicsDebugger: boolean
        static generateNintendoSwitchShaderInfo: boolean
        static switchNVNShaderDebugging: boolean
        static switchNVNDrawValidation_Light: boolean
        static switchNVNDrawValidation_Heavy: boolean
        static switchEnableMemoryTracker: boolean
        static switchWaitForMemoryTrackerOnStartup: boolean
        static switchEnableDebugPad: boolean
        static switchRedirectWritesToHostMount: boolean
        static switchHTCSScriptDebugging: boolean
        static switchUseLegacyNvnPoolAllocator: boolean
        /** Place the built player in the build folder.
         */
        static installInBuildFolder: boolean
        /** Instructs the player to wait for managed debugger to attach before executing any script code.
         */
        static waitForManagedDebugger: boolean
        /** Force the port used by the managed debugger. Default is 0 which means platform-specific auto-selection of a port.
         */
        static managedDebuggerFixedPort: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, ScriptableObject, Component, GameObject, Vector3 } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Unsupported extends Object {
        static CaptureScreenshotImmediate(filePath: string, x: number, y: number, width: number, height: number): void
        static GetSubmenusCommands(menuPath: string): Array<string>
        static GetTypeFromFullName(fullName: string): any
        static GetSubmenus(menuPath: string): Array<string>
        static GetSubmenusIncludingSeparators(menuPath: string): Array<string>
        static PrepareObjectContextMenu(c: Object1, contextUserData: number): void
        static IsDeveloperBuild(): boolean
        static IsDeveloperMode(): boolean
        static IsSourceBuild(checkHumanControllingUs: boolean): boolean
        static IsSourceBuild(): boolean
        static IsBleedingEdgeBuild(): boolean
        static IsDestroyScriptableObject(target: ScriptableObject): boolean
        static IsNativeCodeBuiltInReleaseMode(): boolean
        static GetBaseUnityDeveloperFolder(): string
        static StopPlayingImmediately(): void
        static SceneTrackerFlushDirty(): void
        static SetAllowCursorHide(allow: boolean): void
        static SetOverrideLightingSettings(scene: any): boolean
        static RestoreOverrideLightingSettings(): void
        static SetRenderSettingsUseFogNoDirty(fog: boolean): void
        static SetSceneViewDebugModeExposureNoDirty(exposure: number): void
        static SetQualitySettingsShadowDistanceTemporarily(distance: number): void
        static DeleteGameObjectSelection(): void
        static CopyGameObjectsToPasteboard(): void
        static PasteGameObjectsFromPasteboard(): void
        static GetSerializedAssetInterfaceSingleton(className: string): Object1
        static DuplicateGameObjectsUsingPasteboard(): void
        static CopyComponentToPasteboard(component: Component): boolean
        static PasteComponentFromPasteboard(go: GameObject): boolean
        static PasteComponentValuesFromPasteboard(component: Component): boolean
        static HasStateMachineTransitionDataInPasteboard(): boolean
        static AreAllParametersInDestination(transition: Object1, controller: any, missingParameters: any): boolean
        static DestinationHasCompatibleParameterTypes(transition: Object1, controller: any, mismatchedParameters: any): boolean
        static CanPasteParametersToTransition(transition: Object1, controller: any): boolean
        static CopyStateMachineTransitionParametersToPasteboard(transition: Object1, controller: any): void
        static PasteToStateMachineTransitionParametersFromPasteboard(transition: Object1, controller: any, conditions: boolean, parameters: boolean): void
        static CopyStateMachineDataToPasteboard(stateMachineObject: Object1, controller: any, layerIndex: number): void
        static PasteToStateMachineFromPasteboard(sm: any, controller: any, layerIndex: number, position: Vector3): void
        static HasStateMachineDataInPasteboard(): boolean
        static SmartReset(obj: Object1): void
        static ResolveSymlinks(path: string): string
        static ResolveRedirectedPath(path: string): string
        static SetApplicationSettingCompressAssetsOnImport(value: boolean): void
        static GetApplicationSettingCompressAssetsOnImport(): boolean
        static GetLocalIdentifierInFileForPersistentObject(obj: Object1): number
        static IsHiddenFile(path: string): boolean
        static ClearSkinCache(): void
        static GetRenderSettings(): Object1
        static useScriptableRenderPipeline: boolean
        static IsRegistryValidationDisabled: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Arguments for the event EditorGUI.hyperLinkClicked.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class HyperLinkClickedEventArgs extends Object {
        protected constructor()
        /** Parameters found in the hyperlink tag.
         */
        readonly hyperLinkData: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Helpers for builtin arrays.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ArrayUtility extends Object {
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum InspectorMode {
        Normal = 0,
        Debug = 1,
        DebugInternal = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum HierarchyType {
        Assets = 1,
        GameObjects = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum IconDrawStyle {
        NonTexture = 0,
        Texture = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, Texture2D } from "UnityEngine";
    import { SceneHierarchyHooks } from "UnityEditor.SceneManagement";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class HierarchyProperty extends Object {
        constructor(hierarchyType: HierarchyType, rootPath: string, forceImport: boolean)
        constructor(hierarchyType: HierarchyType, forceImport: boolean)
        constructor(rootPath: string, forceImport: boolean)
        constructor(hierarchyType: HierarchyType)
        constructor(rootPath: string)
        SetCustomScenes(sceneHandles: Array<number>): void
        SetSubScenes(subScenes: Array<SceneHierarchyHooks.SubSceneInfo>): void
        Reset(): void
        GetScene(): any
        IsExpanded(expanded: Array<number>): boolean
        Next(expanded: Array<number>): boolean
        NextWithDepthCheck(expanded: Array<number>, minDepth: number): boolean
        Previous(expanded: Array<number>): boolean
        Parent(): boolean
        Find(instanceID: number, expanded: Array<number>): boolean
        Skip(count: number, expanded: Array<number>): boolean
        CountRemaining(expanded: Array<number>): number
        GetInstanceIDIfImported(): number
        SetSearchFilter(searchString: string, mode: number): void
        FindAllAncestors(instanceIDs: Array<number>): Array<number>
        static ClearSceneObjectsFilter(): void
        static FilterSingleSceneObject(instanceID: number, otherVisibilityState: boolean): void
        readonly instanceID: number
        readonly pptrValue: Object1
        readonly name: string
        readonly hasChildren: boolean
        readonly depth: number
        readonly ancestors: Array<number>
        readonly row: number
        readonly colorCode: number
        readonly guid: string
        alphaSorted: boolean
        showSceneHeaders: boolean
        readonly isSceneHeader: boolean
        readonly isValid: boolean
        readonly isMainRepresentation: boolean
        readonly hasFullPreviewImage: boolean
        readonly iconDrawStyle: IconDrawStyle
        readonly isFolder: boolean
        readonly dynamicDependencies: Array<GUID>
        readonly icon: Texture2D
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ActiveEditorTracker extends Object {
        constructor()
        Equals(o: Object): boolean
        GetHashCode(): number
        Destroy(): void
        GetVisible(index: number): number
        SetVisible(index: number, visible: number): void
        ClearDirty(): void
        RebuildIfNecessary(): void
        ForceRebuild(): void
        VerifyModifiedMonoBehaviours(): void
        static HasCustomEditor(obj: Object1): boolean
        readonly activeEditors: Array<Editor>
        readonly isDirty: boolean
        isLocked: boolean
        inspectorMode: InspectorMode
        readonly hasComponentsWhichCannotBeMultiEdited: boolean
        static readonly sharedTracker: ActiveEditorTracker
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum XboxOneEncryptionLevel {
        None = 0,
        DevkitCompatible = 1,
        FullEncryption = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum XboxOnePackageUpdateGranularity {
        Chunk = 1,
        File = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum XboxOneLoggingLevel {
        ErrorsOnly = 1,
        WarningsAndErrors = 2,
        AllLogging = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Supported tvOS SDK versions.
     */
    enum tvOSSdkVersion {
        /** Device SDK.
         */
        Device = 0,
        /** Simulator SDK.
         */
        Simulator = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Visual indication mode for Drag & Drop operation.
     */
    enum DragAndDropVisualMode {
        /** No indication (drag should not be performed).
         */
        None = 0,
        /** Copy dragged objects.
         */
        Copy = 1,
        /** Link dragged objects to target.
         */
        Link = 2,
        /** Generic drag operation.
         */
        Generic = 4,
        /** Move dragged objects.
         */
        Move = 16,
        /** Rejected drag operation.
         */
        Rejected = 32,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Define how dragged objects should be dropped relative to already existing Hierarchy items.
     */
    enum HierarchyDropFlags {
        /** Insert dragged object in the Hierarchy. The default flag value is 0. The only case in which DropMode is 0 is when dragging outside items and parentForDraggedObjects is set. Then dropTargetInstanceID is 0 and the target is passed to the parentForDraggedObjects.
         */
        None = 0,
        /** Drop a dragged object on the Hierarchy item the mouse is hovering over. The hovered-over item is the dropTargetInstanceID and the dropped object is inserted as a child of the target. This flag is also used when dragging and dropping objects from outside the Hierarchy and into and below the last item in the Hierarchy to add to the Scene. In this case, the dropTargetInstanceID is the Scene handle.
         */
        DropUpon = 1,
        /** Drop a dragged object between two Hierarchy sibling items the mouse is hovered over. The dropTargetInstanceID is the Hierarchy item above the hover point, the dropped object is inserted below the target. 
         */
        DropBetween = 2,
        /** Drop a dragged object into the first child position after the parent of the Hierarchy item when the mouse is hovering between the parent and the first child. The dropTargetInstanceID is the first child under a parent and the dropped object is inserted between the parent and the first child. When using DropAfterParent, DropBetween and DropAbove are also used to provide information to locate the dropped object.
         */
        DropAfterParent = 4,
        /** This flag is set if the Hierarchy is showing search results. If a search is active, only DropUpon is allowed (no other actions can be performed on a partial list of items).
         */
        SearchActive = 8,
        /** Drop a dragged object above the Hierarchy sibling item the mouse is hovered over. The dropTargetInstanceID is the Hierarchy item below the hover point and the dropped object is inserted above the target.
         */
        DropAbove = 16,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** IDs for core windows. These are used by the DragAndDrop.RemoveHandler API.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DragAndDropWindowTarget extends ValueType {
        constructor()
        /** ID to target the Project browser.
         */
        static readonly projectBrowser: number
        /** ID to target the Scene view.
         */
        static readonly sceneView: number
        /** ID to target the Hierarchy.
         */
        static readonly hierarchy: number
        /** ID to target the Inspector.
         */
        static readonly inspector: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, Vector3, Vector2, Transform } from "UnityEngine";
    /** Editor drag & drop operations.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DragAndDrop extends Object {
        constructor()
        static PrepareStartDrag(): void
        /** Start a drag operation.
         */
        static StartDrag(title: string): void
        /** Get data associated with current drag and drop operation.
         */
        static GetGenericData(type: string): Object
        /** Set data associated with current drag and drop operation.
         */
        static SetGenericData(type: string, data: Object): void
        static AcceptDrag(): void
        /** Check if the handler is already registered for the destination window ID.
         * @param dropDstId ID of the destination window.
         * @param handler The handler of the targeted window.
         * @returns True if the handler is already registered. 
         */
        static HasHandler(dropDstId: number, handler: Delegate): boolean
        static AddDropHandler(handler: (dragInstanceId: number, dropUponPath: string, perform: boolean) => DragAndDropVisualMode): void
        static AddDropHandler(handler: (dropUpon: Object1, worldPosition: Vector3, viewportPosition: Vector2, parentForDraggedObjects: Transform, perform: boolean) => DragAndDropVisualMode): void
        static AddDropHandler(handler: (dropTargetInstanceID: number, dropMode: HierarchyDropFlags, parentForDraggedObjects: Transform, perform: boolean) => DragAndDropVisualMode): void
        static AddDropHandler(handler: (targets: Array<Object1>, perform: boolean) => DragAndDropVisualMode): void
        static RemoveDropHandler(handler: (dragInstanceId: number, dropUponPath: string, perform: boolean) => DragAndDropVisualMode): void
        static RemoveDropHandler(handler: (dropUpon: Object1, worldPosition: Vector3, viewportPosition: Vector2, parentForDraggedObjects: Transform, perform: boolean) => DragAndDropVisualMode): void
        static RemoveDropHandler(handler: (dropTargetInstanceID: number, dropMode: HierarchyDropFlags, parentForDraggedObjects: Transform, perform: boolean) => DragAndDropVisualMode): void
        static RemoveDropHandler(handler: (targets: Array<Object1>, perform: boolean) => DragAndDropVisualMode): void
        /** References to Object|objects being dragged.
         */
        static objectReferences: Array<Object1>
        /** The file names being dragged.
         */
        static paths: Array<string>
        /** Get or set ID of currently active drag and drop control.
         */
        static activeControlID: number
        /** The visual indication of the drag.
         */
        static visualMode: DragAndDropVisualMode
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Use these enum flags to specify which elements of a vertex to compress.
     */
    enum VertexChannelCompressionFlags {
        /** Vertex compression disabled.
         */
        None = 0,
        /** Position compression enabled.
         */
        Position = 1,
        /** Position compression enabled.
         */
        kPosition = 1,
        /** Normal compression enabled.
         */
        Normal = 2,
        /** Normal compression enabled.
         */
        kNormal = 2,
        /** Tangent compression enabled.
         */
        Tangent = 4,
        /** Tangent compression enabled.
         */
        kColor = 4,
        Color = 8,
        kUV0 = 8,
        TexCoord0 = 16,
        kUV1 = 16,
        TexCoord1 = 32,
        kUV2 = 32,
        TexCoord2 = 64,
        kUV3 = 64,
        /** Texture coordinate 3 compression enabled.
         */
        TexCoord3 = 128,
        /** Texture coordinate 3 compression enabled.
         */
        kTangent = 128,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PackageInfo extends ValueType {
        constructor()
        packagePath: string
        jsonInfo: string
        iconURL: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IHasCustomMenu {
        /** Adds your custom menu items to an Editor Window.
         */
        AddItemsToMenu(menu: GenericMenu): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Derive from this class to create an editor wizard.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ScriptableWizard extends EditorWindow {
        constructor()
        /** Creates a wizard.
         * @param title The title shown at the top of the wizard window.
         * @param klass The class implementing the wizard. It has to derive from ScriptableWizard.
         * @param createButtonName The text shown on the create button.
         * @param otherButtonName The text shown on the optional other button. Leave this parameter out to leave the button out.
         * @returns The wizard. 
         */
        static DisplayWizard(title: string, klass: any, createButtonName: string, otherButtonName: string): ScriptableWizard
        static DisplayWizard(title: string, klass: any, createButtonName: string): ScriptableWizard
        static DisplayWizard(title: string, klass: any): ScriptableWizard
        /** Allows you to set the help text of the wizard.
         */
        helpString: string
        /** Allows you to set the error text of the wizard.
         */
        errorString: string
        /** Allows you to set the text shown on the create button of the wizard.
         */
        createButtonName: string
        /** Allows you to set the text shown on the optional other button of the wizard. Leave this parameter out to leave the button out.
         */
        otherButtonName: string
        /** Allows you to enable and disable the wizard create button, so that the user can not click it.
         */
        isValid: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Determines how a gizmo is drawn or picked in the Unity editor.
     */
    enum GizmoType {
        /** The gizmo can be picked in the editor.
         */
        Pickable = 1,
        /** Draw the gizmo if it is not selected and also no parent/ancestor is selected.
         */
        NotInSelectionHierarchy = 2,
        /** Draw the gizmo if it is selected.
         */
        Selected = 4,
        /** Draw the gizmo if it is active (shown in the inspector).
         */
        Active = 8,
        /** Draw the gizmo if it is selected or it is a child/descendent of the selected.
         */
        InSelectionHierarchy = 16,
        /** Draw the gizmo if it is not selected.
         */
        NonSelected = 32,
        NotSelected = -127,
        SelectedOrChild = -127,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Color, Matrix4x4 } from "UnityEngine";
    namespace Handles {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class DrawingScope extends ValueType {
            constructor(color: Color, matrix: Matrix4x4)
            constructor(color: Color)
            constructor(matrix: Matrix4x4)
            Dispose(): void
            readonly originalColor: Color
            readonly originalMatrix: Matrix4x4
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ExternalVersionControl extends ValueType {
        constructor(value: string)
        toString(): string
        static op_Implicit(d: ExternalVersionControl): string
        static op_Implicit(d: string): ExternalVersionControl
        static readonly Disabled: string
        static readonly AutoDetect: string
        static readonly Generic: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VersionControlSettings extends Object {
        protected constructor()
        static mode: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Menu class to manipulate the menu item.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Menu extends Object {
        constructor()
        /** Set the check status of the given menu.
         */
        static SetChecked(menuPath: string, isChecked: boolean): void
        /** Get the check status of the given menu.
         */
        static GetChecked(menuPath: string): boolean
        /** Gets a menu item's enabled status.
         * @param menuPath A slash-delimited path to the item's position in the menu. For example, "Scene/Place on Surface".
         * @returns True if the menu item is enabled. False otherwise. 
         */
        static GetEnabled(menuPath: string): boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for Exception support in WebGL.
     */
    enum WebGLExceptionSupport {
        /** Disable exception support.
         */
        None = 0,
        /** Enable throw support.
         */
        ExplicitlyThrownExceptionsOnly = 1,
        /** Enable exception support for all exceptions, without stack trace information.
         */
        FullWithoutStacktrace = 2,
        /** Enable exception support for all exceptions, including stack trace information.
         */
        FullWithStacktrace = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** An enum containing different compression types.
     */
    enum WebGLCompressionFormat {
        /** WebGL resources are stored using Brotli compression.
         */
        Brotli = 0,
        /** WebGL resources are stored using Gzip compression.
         */
        Gzip = 1,
        /** WebGL resources are uncompressed.
         */
        Disabled = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The build format options available when building to WebGL.
     */
    enum WebGLLinkerTarget {
        /** Only asm.js output will be generated. This setting has been deprecated.
         */
        Asm = 0,
        /** Only WebAssembly output will be generated. This will require a browser with WebAssembly support to run the generated content.
         */
        Wasm = 1,
        /** Both asm.js and WebAssembly output will be generated. The WebAssembly version of the generated content will be used if supported by the browser, otherwise, the asm.js version will be used. This setting has been deprecated.
         */
        Both = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** An enum containing different trapping modes for WebAssembly code.
     */
    enum WebGLWasmArithmeticExceptions {
        /** WebAssembly code will throw an exception on things like division by zero, rounding a very large float to an int, and so forth.
         */
        Throw = 0,
        /** This mode avoids traps by clamping floating point value to a reasonable range when performing arithmetic operations.
         */
        Ignore = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** An enum containing different modes for debug symbols.
     */
    enum WebGLDebugSymbolMode {
        /** No debug symbols are added to the build.
         */
        Off = 0,
        /** Debug symbols are stored in an external file.
         */
        External = 1,
        /** Debug symbols are embedded into the wasm file.
         */
        Embedded = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** An enum containing different power preference hints for the WebGL context.
     */
    enum WebGLPowerPreference {
        /** The WebGL implementation is left to decide which GPU configuration is most suitable.
         */
        Default = 0,
        /** Requests the WebGL implementation prioritizes power savings.
         */
        LowPower = 1,
        /** Requests the WebGL implementation prioritizes rendering performance.
         */
        HighPerformance = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The default build settings window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPlayerWindow extends EditorWindow {
        constructor()
        static ShowBuildPlayerWindow(): void
        static GetPlaybackEngineDownloadURL(moduleName: string): string
        static RegisterGetBuildPlayerOptionsHandler(func: (arg: BuildPlayerOptions) => BuildPlayerOptions): void
        static RegisterBuildPlayerHandler(func: (obj: BuildPlayerOptions) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Exception } from "System";
    namespace BuildPlayerWindow {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class BuildMethodException extends Exception {
            constructor(message: string)
            constructor()
        }
    }
}
declare module "System" {
    import * as jsb from "jsb";
    class Exception extends Object {
        constructor(message: string, innerException: Exception)
        constructor(message: string)
        constructor()
        GetBaseException(): Exception
        toString(): string
        GetObjectData(info: any, context: any): void
        GetType(): any
        readonly Message: string
        readonly Data: any
        readonly InnerException: Exception
        readonly TargetSite: any
        readonly StackTrace: string
        HelpLink: string
        Source: string
        readonly HResult: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace BuildPlayerWindow {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class DefaultBuildMethods extends Object {
            static BuildPlayer(options: BuildPlayerOptions): void
            static GetBuildPlayerOptions(defaultBuildPlayerOptions: BuildPlayerOptions): BuildPlayerOptions
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, GUIContent } from "UnityEngine";
    namespace EditorGUILayout {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ToggleGroupScope extends GUI.Scope {
            constructor(label: string, toggle: boolean)
            constructor(label: GUIContent, toggle: boolean)
            readonly enabled: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, Rect, GUIStyle, GUILayoutOption } from "UnityEngine";
    namespace EditorGUILayout {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class HorizontalScope extends GUI.Scope {
            constructor(style: GUIStyle, ...options: GUILayoutOption[])
            constructor(...options: GUILayoutOption[])
            readonly rect: Rect
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, Rect, GUIStyle, GUILayoutOption } from "UnityEngine";
    namespace EditorGUILayout {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class VerticalScope extends GUI.Scope {
            constructor(style: GUIStyle, ...options: GUILayoutOption[])
            constructor(...options: GUILayoutOption[])
            readonly rect: Rect
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI, Vector2, GUIStyle, GUILayoutOption } from "UnityEngine";
    namespace EditorGUILayout {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ScrollViewScope extends GUI.Scope {
            constructor(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, background: GUIStyle, ...options: GUILayoutOption[])
            constructor(scrollPosition: Vector2, alwaysShowHorizontal: boolean, alwaysShowVertical: boolean, ...options: GUILayoutOption[])
            constructor(scrollPosition: Vector2, horizontalScrollbar: GUIStyle, verticalScrollbar: GUIStyle, ...options: GUILayoutOption[])
            constructor(scrollPosition: Vector2, style: GUIStyle, ...options: GUILayoutOption[])
            constructor(scrollPosition: Vector2, ...options: GUILayoutOption[])
            readonly scrollPosition: Vector2
            handleScrollWheel: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GUI } from "UnityEngine";
    namespace EditorGUILayout {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class FadeGroupScope extends GUI.Scope {
            constructor(value: number)
            readonly visible: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Used to extract the context for a MenuItem.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MenuCommand extends Object {
        constructor(inContext: Object1, inUserData: number)
        constructor(inContext: Object1)
        /** Context is the object that is the target of a menu command.
         */
        context: Object1
        /** An integer for passing custom information to a menu item.
         */
        userData: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Transform, GameObject, Object as Object1 } from "UnityEngine";
    /** Access to the selection in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Selection extends Object {
        constructor()
        /** Returns whether an object is contained in the current selection.
         */
        static Contains(obj: Object1): boolean
        /** Returns whether an object is contained in the current selection.
         */
        static Contains(instanceID: number): boolean
        /** Returns the current selection filtered by type and mode.
         * @param type Only objects of this type will be retrieved.
         * @param mode Further options to refine the selection.
         */
        static GetFiltered(type: any, mode: SelectionMode): Array<Object1>
        /** Selects an object with a context.
         * @param obj Object being selected (will be equal activeObject).
         * @param context Context object.
         */
        static SetActiveObjectWithContext(obj: Object1, context: Object1): void
        /** Allows for fine grained control of the selection type using the SelectionMode bitmask.
         * @param mode Options for refining the selection.
         */
        static GetTransforms(mode: SelectionMode): Array<Transform>
        /** Returns the top level selection, excluding Prefabs.
         */
        static readonly transforms: Array<Transform>
        /** Returns the active transform. (The one shown in the inspector).
         */
        static activeTransform: Transform
        /** Returns the actual game object selection. Includes Prefabs, non-modifiable objects.
         */
        static readonly gameObjects: Array<GameObject>
        /** Returns the active game object. (The one shown in the inspector).
         */
        static activeGameObject: GameObject
        /** Returns the actual object selection. Includes Prefabs, non-modifiable objects.
         */
        static activeObject: Object1
        /** Returns the current context object, as was set via SetActiveObjectWithContext.
         */
        static readonly activeContext: Object1
        /** Returns the instanceID of the actual object selection. Includes Prefabs, non-modifiable objects.
         */
        static activeInstanceID: number
        /** The actual unfiltered selection from the Scene.
         */
        static objects: Array<Object1>
        /** The actual unfiltered selection from the Scene returned as instance ids instead of objects.
         */
        static instanceIDs: Array<number>
        /** Returns the guids of the selected assets.
         */
        static readonly assetGUIDs: Array<string>
        /** Returns the number of objects in the Selection.
         */
        static readonly count: number
        static selectionChanged(op: "get"): () => void
        static selectionChanged(op: "add" | "remove" | "set", fn?: () => void): void
        static selectionChanged(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** StaticOcclusionCulling lets you perform static occlusion culling operations.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class StaticOcclusionCulling extends Object {
        static Compute(): boolean
        static GenerateInBackground(): boolean
        static RemoveCacheFolder(): void
        static Cancel(): void
        static Clear(): void
        static SetDefaultOcclusionBakeSettings(): void
        /** Used to check if asynchronous generation of static occlusion culling data is still running.
         */
        static readonly isRunning: boolean
        static smallestOccluder: number
        static smallestHole: number
        static backfaceThreshold: number
        /** Does the Scene contain any occlusion portals that were added manually rather than automatically?
         */
        static readonly doesSceneHaveManualPortals: boolean
        /** Returns the size in bytes that the PVS data is currently taking up in this Scene on disk.
         */
        static readonly umbraDataSize: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Camera } from "UnityEngine";
    /** Used to visualize static occlusion culling at development time in Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class StaticOcclusionCullingVisualization extends Object {
        /** If set to true, visualization of target volumes is enabled.
         */
        static showOcclusionCulling: boolean
        /** If set to true, the visualization lines of the PVS volumes will show all cells rather than cells after culling.
         */
        static showPreVisualization: boolean
        /** If set to true, visualization of view volumes is enabled.
         */
        static showViewVolumes: boolean
        static showDynamicObjectBounds: boolean
        /** If set to true, visualization of portals is enabled.
         */
        static showPortals: boolean
        /** If set to true, visualization of portals is enabled.
         */
        static showVisibilityLines: boolean
        /** If set to true, culling of geometry is enabled.
         */
        static showGeometryCulling: boolean
        static readonly isPreviewOcclusionCullingCameraInPVS: boolean
        static readonly previewOcclusionCamera: Camera
        static readonly previewOcclucionCamera: Camera
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum SerializationMode {
        Mixed = 0,
        ForceBinary = 1,
        ForceText = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum EditorBehaviorMode {
        Mode3D = 0,
        Mode2D = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Sprite Packer mode for the current project.
     */
    enum SpritePackerMode {
        /** Doesn't pack sprites.
         */
        Disabled = 0,
        /** Updates the sprite atlas cache when the Player or bundles builds containing Sprite with the legacy packing tag.
         */
        BuildTimeOnly = 1,
        /** Always maintain an up-to-date sprite atlas cache for Sprite with packing tag (legacy).
         */
        AlwaysOn = 2,
        /** Pack all the SpriteAtlas when building player/bundles.
         */
        BuildTimeOnlyAtlas = 3,
        /** Always pack all the SpriteAtlas.
         */
        AlwaysOnAtlas = 4,
        /** If enabled, will automatically migrate all *.spriteatlas assets to *.spriteatlasv2 assets. Old *.spriteatlas assets will be removed.
         */
        SpriteAtlasV2 = 5,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Defines the type of line endings used when creating new C# files from within the editor.
     */
    enum LineEndingsMode {
        /** File endings are the default for the active platform. On Windows, this is a carriage return character followed by linefeed character (\r\n). On macOS or Linux, this is a single linefeed characater (\n).
         */
        OSNative = 0,
        /** Lines are terminated with a newline character. Also referred to as linefeed, or LF.
         */
        Unix = 1,
        /** Lines are terminated with carriage return and newline characters. Also referred to as CR/LF or `\r\n`.
         */
        Windows = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Selects the Assetpipeline mode to use.
     */
    enum AssetPipelineMode {
        /** Use this if you want to use assetpipeline version 1.
         */
        Version1 = 0,
        /** Use this if you want to use assetpipeline version 2.
         */
        Version2 = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Selects the cache server configuration mode.
     */
    enum CacheServerMode {
        /** Use this if you want to use the global cache server settings.
         */
        AsPreferences = 0,
        /** Use this if you want to enable use of the project specific cache server settings.
         */
        Enabled = 1,
        /** Use this if you want to disable the use of cache server for the project.
         */
        Disabled = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for the accelerate server validation mode.
     */
    enum CacheServerValidationMode {
        /** Disable validation for the cache server.
         */
        Disabled = 0,
        /** Calculate content hashes for uploaded artifacts and send them to the Accelerator for validation.
         */
        UploadOnly = 1,
        /** Calculate and upload hashes. Validate Accelerator-provided hashes during downloads.
         */
        Enabled = 2,
        /** Calculate and uploaded content hashes to the Accelerator. Require Accelerator-provided hashes for download validation.
         */
        Required = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Determines the flags for the Enter Play Mode Options in the Unity Editor.
     */
    enum EnterPlayModeOptions {
        /** This makes Unity reload the .NET Application Domain and entire Scene when entering Play Mode.
         */
        None = 0,
        /** When Domain Reload is disabled, scripts are not reloaded when entering Play Mode. This makes it quicker to switch to Play Mode, because there's no need to destroy, create and reload the .NET Application Domain.
         */
        DisableDomainReload = 1,
        /** When Scene Reload is disabled, Unity resets the Scene state and emulates all of the required post-processor calls when entering Play Mode, instead of reloading the whole Scene. This makes it quicker to switch to Play Mode, because there's no need to destroy, create and awaken all the Scene objects, and serialize and deserialize the Scene from disk.
         */
        DisableSceneReload = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Array } from "System";
    /** User settings for Unity Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorSettings extends Object {
        protected constructor()
        /** Gets or sets device ID used for Unity Remote feature.
         */
        static unityRemoteDevice: string
        /** Gets or sets compression method used for Unity Remote screen stream.
         */
        static unityRemoteCompression: string
        /** Gets or sets resolution used for Unity Remote screen stream.
         */
        static unityRemoteResolution: string
        /** Gets or sets joystick source used in editor when Unity Remote is connected.
         */
        static unityRemoteJoystickSource: string
        static serializationMode: SerializationMode
        /** Determines what line endings to use in a new C# file created in the Editor.
         */
        static lineEndingsForNewScripts: LineEndingsMode
        static defaultBehaviorMode: EditorBehaviorMode
        /** Allows you to specify a Scene to use as the for Prefabs.
         */
        static prefabRegularEnvironment: SceneAsset
        /** Allows you to specify a Scene to use as the for UI Prefabs.
         */
        static prefabUIEnvironment: SceneAsset
        /** Allow Auto Save in Prefab Mode for this project.
         */
        static prefabModeAllowAutoSave: boolean
        static spritePackerMode: SpritePackerMode
        /** Power of 2 value to add a boundary (padding) to Sprites packed to the Atlas (Legacy Sprite Packer).
         */
        static spritePackerPaddingPower: number
        static etcTextureCompressorBehavior: number
        static etcTextureFastCompressor: number
        static etcTextureNormalCompressor: number
        static etcTextureBestCompressor: number
        /** Enable texture mipmap streaming system when in Edit Mode.
         */
        static enableTextureStreamingInEditMode: boolean
        /** Enable texture mipmap streaming system when in Play Mode.
         */
        static enableTextureStreamingInPlayMode: boolean
        /** Enable asynchronous Shader compilation in Game and Scene view.
         */
        static asyncShaderCompilation: boolean
        /** Enables the Caching Shader Preprocessor.
         */
        static cachingShaderPreprocessor: boolean
        /** Controls list of extensions of files that will be included in the c# .csproj projects that Unity generates.
         */
        static projectGenerationUserExtensions: Array<string>
        static readonly projectGenerationBuiltinExtensions: Array<string>
        /** Controls which root namespace gets written into the c# .csproj projects that Unity generates.
         */
        static projectGenerationRootNamespace: string
        /** Enable the legacy fixed sample counts for baking Light Probes with Progressive Lightmapper.
         */
        static useLegacyProbeSampleCount: boolean
        /** Determines whether cookies should be evaluated by the Progressive Lightmapper during Global Illumination calculations.
         */
        static enableCookiesInLightmapper: boolean
        /** Determines whether the Enter Play Mode Options are enabled in the Unity Editor or not.
         */
        static enterPlayModeOptionsEnabled: boolean
        /** Determines the state of the Enter Play Mode Options in the Unity Editor.
         */
        static enterPlayModeOptions: EnterPlayModeOptions
        /** Forces Unity to write references and other inline mappings on one line, to help reduce version control noise.
         */
        static serializeInlineMappingsOnOneLine: boolean
        /** Select the assetpipeline mode.
         */
        static readonly assetPipelineMode: AssetPipelineMode
        /** Select cache server mode
         */
        static cacheServerMode: CacheServerMode
        /** Controls the Editor's use of parallel processes when it imports assets during an asset database refresh, for this project.
         */
        static refreshImportMode: AssetDatabase.RefreshImportMode
        /** Cache server endpoint IP address
         */
        static cacheServerEndpoint: string
        /** Sets the namespace prefix to use for the cache server.
         */
        static cacheServerNamespacePrefix: string
        /** Toggle whether to enable downloading from cache server.
         */
        static cacheServerEnableDownload: boolean
        /** Toggle whether to enable uploading from cache server.
         */
        static cacheServerEnableUpload: boolean
        /** Toggle whether to enable authentication to cache server.
         */
        static cacheServerEnableAuth: boolean
        /** Toggle whether to enable TLS encryption to cache server.
         */
        static cacheServerEnableTls: boolean
        /** Select Accelerator server validation mode.
         */
        static cacheServerValidationMode: CacheServerValidationMode
        /** Controls the size of the batches used when making cacheserver download requests.
         */
        static cacheServerDownloadBatchSize: number
        /** Indicates the amount of digits to use for the numbers in a duplicated GameoObject's name.
         */
        static gameObjectNamingDigits: number
        /** Indicates which naming scheme to use for duplicated GameObjects.
         */
        static gameObjectNamingScheme: EditorSettings.NamingScheme
        /** Controls whether to insert a space before a number in duplicated Asset names.
         */
        static assetNamingUsesSpace: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace EditorSettings {
        enum NamingScheme {
            SpaceParenthesis = 0,
            Dot = 1,
            Underscore = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { TextAsset, MonoBehaviour, ScriptableObject } from "UnityEngine";
    import { Object } from "System";
    /** Representation of Script assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MonoScript extends TextAsset {
        constructor()
        GetClass(): any
        /** Returns the MonoScript object containing specified MonoBehaviour.
         * @param behaviour The MonoBehaviour whose MonoScript should be returned.
         */
        static FromMonoBehaviour(behaviour: MonoBehaviour): MonoScript
        /** Returns the MonoScript object containing specified ScriptableObject.
         * @param scriptableObject The ScriptableObject whose MonoScript should be returned.
         */
        static FromScriptableObject(scriptableObject: ScriptableObject): MonoScript
    }
}
declare module "UnityEngine" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** Represents a raw text or binary file asset.
     */
    class TextAsset extends Object {
        constructor(text: string)
        constructor()
        toString(): string
        /** The raw bytes of the text asset. (Read Only)
         */
        readonly bytes: Array<jsb.byte>
        /** The text contents of the file as a string. (Read Only)
         */
        readonly text: string
        /** The size of the text asset data in bytes. (Read Only)
         */
        readonly dataSize: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Unwrapping settings.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class UnwrapParam extends ValueType {
        constructor()
        /** Will set default values for params.
         */
        static SetDefaults(param: jsb.Out<UnwrapParam>): void
        /** Maximum allowed angle distortion (0..1).
         */
        angleError: number
        /** Maximum allowed area distortion (0..1).
         */
        areaError: number
        /** This angle (in degrees) or greater between triangles will cause seam to be created.
         */
        hardAngle: number
        /** How much uv-islands will be padded.
         */
        packMargin: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Vector2, Object as Object1 } from "UnityEngine";
    /** This class holds everything you may need in regard to uv-unwrapping.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Unwrapping extends Object {
        /** Will generate per-triangle uv (3 UVs for each triangle) with provided settings.
         * @param src The source mesh to generate UVs for.
         * @param settings Allows you to specify custom parameters to control the unwrapping.
         * @returns The list of UVs generated. 
         */
        static GeneratePerTriangleUV(src: any, settings: UnwrapParam): Array<Vector2>
        /** Will generate per-triangle uv (3 UVs for each triangle) with default settings.
         * @param src The source mesh to generate UVs for.
         * @returns The list of UVs generated. 
         */
        static GeneratePerTriangleUV(src: any): Array<Vector2>
        /** Will auto generate uv2 with provided settings for provided mesh, and fill them in.
         */
        static GenerateSecondaryUVSet(src: any, settings: UnwrapParam): void
        /** Will auto generate uv2 with default settings for provided mesh, and fill them in.
         */
        static GenerateSecondaryUVSet(src: any): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Sets the preprocessor that Unity uses to compile this shader.
     */
    enum PreprocessorOverride {
        /** Use the preprocessor defined in your Project's Editor Settings.
         */
        UseProjectSettings = 0,
        /** Use the platform compilers' preprocessors.
         */
        ForcePlatformPreprocessor = 1,
        /** Use the Caching Shader Preprocessor.
         */
        ForceCachingPreprocessor = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Contains the following information about a shader:
-If the shader has compilation errors or warnings.
-If the shader is supported on the currently selected platform.
-The name of the shader.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderInfo extends ValueType {
        constructor()
        /** The name of the shader (Read Only).
         */
        readonly name: string
        /** Indicates whether the current platform supports the shader (Read Only).
         */
        readonly supported: boolean
        /** Indicates whether the shader has compilation errors (Read Only).
         */
        readonly hasErrors: boolean
        /** Indicates whether the shader has compilation warnings (Read Only).
         */
        readonly hasWarnings: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum, Object } from "System";
    /** Contains information about messages generated by Unity's Shader Compiler.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderMessage extends ValueType {
        constructor(msg: string, sev: any)
        /** Compares two ShaderMessage on an element-by-element basis.
         * @returns True if all fields of the message are equal, otherwise false. 
         */
        Equals(other: ShaderMessage): boolean
        /** Compares two ShaderMessage on an element-by-element basis.
         * @returns True if all fields of the message are equal, otherwise false. 
         */
        Equals(obj: Object): boolean
        GetHashCode(): number
        static op_Equality(left: ShaderMessage, right: ShaderMessage): boolean
        static op_Inequality(left: ShaderMessage, right: ShaderMessage): boolean
        // js_op_overloading: static ==(left: ShaderMessage, right: ShaderMessage): boolean
        /** The message returned by the Unity Shader Compiler.
         */
        readonly message: string
        /** An (optional) detailed message returned from the Unity Shader Compiler.
         */
        readonly messageDetails: string
        /** The source file where the shader message was found.
         */
        readonly file: string
        /** The line of code where the shader message was found.
         */
        readonly line: number
        /** The specific platform where the Unity Shader Compiler discovered the message.
         */
        readonly platform: any
        /** Indicates the severity of the message returned from the Unity Shader Compiler.
         */
        readonly severity: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Helper class for constructing displayable names for objects.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ObjectNames extends Object {
        constructor()
        /** Inspector title for an object.
         */
        static GetInspectorTitle(obj: Object1): string
        /** Make a displayable name for a variable.
         */
        static NicifyVariableName(name: string): string
        /** Class name of an object.
         */
        static GetClassName(obj: Object1): string
        /** Drag and drop title for an object.
         */
        static GetDragAndDropTitle(obj: Object1): string
        /** Sets the name of an Object.
         */
        static SetNameSmart(obj: Object1, name: string): void
        /** Make a unique name using the provided name as a base.

If the target name is in the provided list of existing names, a unique name is generated by appending the next available numerical increment.
         * @param existingNames A list of pre-existing names.
         * @param name Desired name to be used as is, or as a base.
         * @returns A name not found in the list of pre-existing names. 
         */
        static GetUniqueName(existingNames: Array<string>, name: string): string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Behavior of semantic merge.
     */
    enum SemanticMergeMode {
        /** Disable use of semantic merging.
         */
        Off = 0,
        Premerge = 1,
        Ask = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorUserSettings extends Object {
        static GetConfigValue(name: string): string
        static SetConfigValue(name: string, value: string): void
        protected constructor()
        static AutomaticAdd: boolean
        static WorkOffline: boolean
        static showFailedCheckout: boolean
        static overwriteFailedCheckoutAssets: boolean
        static overlayIcons: boolean
        static hierarchyOverlayIcons: boolean
        static otherOverlayIcons: boolean
        static allowAsyncStatusUpdate: boolean
        static artifactGarbageCollection: boolean
        static semanticMergeMode: SemanticMergeMode
        static desiredImportWorkerCount: number
        static standbyImportWorkerCount: number
        static idleImportWorkerShutdownDelayMilliseconds: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Helper class to access Unity documentation.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Help extends Object {
        constructor()
        /** Is there a help page for this object?
         */
        static HasHelpForObject(obj: Object1): boolean
        /** Get the URL for this object's documentation.
         * @param obj The object to retrieve documentation for.
         * @returns The documentation URL for the object. Note that this could use the https: or file: schemas. 
         */
        static GetHelpURLForObject(obj: Object1): string
        /** Show help page for this object.
         */
        static ShowHelpForObject(obj: Object1): void
        /** Show a help page.
         */
        static ShowHelpPage(page: string): void
        /** Open url in the default web browser.
         */
        static BrowseURL(url: string): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Component } from "UnityEngine";
    /** LOD Utility Helpers.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LODUtility extends Object {
        constructor()
        /** Recalculate the bounding region for the given LODGroup.
         */
        static CalculateLODGroupBoundingBox(group: any): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The editor selected render mode for Scene View selection.
     */
    enum EditorSelectedRenderState {
        /** The Renderer has no selection highlight or wireframe in the Editor.
         */
        Hidden = 0,
        /** The Renderer has wireframe but not selection highlight in the Editor.
         */
        Wireframe = 1,
        /** The Renderer has selection highlight but no wireframe in the Editor.
         */
        Highlight = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The mode of interaction, user or automated, that an API method is called with.
     */
    enum InteractionMode {
        /** Use this setting to prevent a method from showing any dialog boxes to the user, and to prevent it recording to the undo history.
         */
        AutomatedAction = 0,
        /** Use this setting to allow a method to show dialog boxes to the user, and to allow it to record to the undo history.
         */
        UserAction = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Compression Quality.
     */
    enum TextureCompressionQuality {
        /** Fast compression.
         */
        Fast = 0,
        /** Normal compression (default).
         */
        Normal = 50,
        /** Best compression.
         */
        Best = 100,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The type of opt-out decision a user can make.
     */
    enum DialogOptOutDecisionType {
        /** The decision to opt out of seeing a dialog box for all time on the user's current machine.
         */
        ForThisMachine = 0,
        /** The decision to opt out of seeing a dialog box for the duration of the current Editor session.
         */
        ForThisSession = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    /** SceneAsset is used to reference Scene objects in the Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneAsset extends Object {
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** SelectionMode can be used to tweak the selection returned by Selection.GetTransforms.
     */
    enum SelectionMode {
        /** Return the whole selection.
         */
        Unfiltered = 0,
        /** Only return the topmost selected transform. A selected child of another selected transform will be filtered out.
         */
        TopLevel = 1,
        /** Return the selection and all child transforms of the selection.
         */
        Deep = 2,
        /** Excludes any Prefabs from the selection.
         */
        ExcludePrefab = 4,
        Editable = 8,
        OnlyUserModifiable = 8,
        /** Only return objects that are assets in the Asset directory.
         */
        Assets = 16,
        /** If the selection contains folders, also include all assets and subfolders within that folder in the file hierarchy.
         */
        DeepAssets = 32,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Desktop platform subtarget type.
     */
    enum StandaloneBuildSubtarget {
        /** Build the default Desktop player.
         */
        Player = 0,
        /** Build a player that is optimized for running as a headless server.
         */
        Server = 1,
        NoSubtarget = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Type of build to generate.
     */
    enum PS4BuildSubtarget {
        /** Build hosted on a PC, for file serving to a dev or test kit.
         */
        PCHosted = 0,
        /** Package build for installation on either a dev or test kit.
         */
        Package = 1,
        Iso = 2,
        GP4Project = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum PS4HardwareTarget {
        BaseOnly = 0,
        NeoAndBase = 1,
        ProAndBase = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Target Xbox build type.
     */
    enum XboxBuildSubtarget {
        /** Development player.
         */
        Development = 0,
        /** Master player (submission-proof).
         */
        Master = 1,
        /** Debug player (for building with source code).
         */
        Debug = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum XboxOneDeployMethod {
        Push = 0,
        RunFromPC = 2,
        Package = 3,
        PackageStreaming = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum XboxOneDeployDrive {
        Default = 0,
        Retail = 1,
        Development = 2,
        Ext1 = 3,
        Ext2 = 4,
        Ext3 = 5,
        Ext4 = 6,
        Ext5 = 7,
        Ext6 = 8,
        Ext7 = 9,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Defines the options available for choosing the type of symbol file to create in an Android build.
     */
    enum AndroidCreateSymbols {
        /** Do not create a symbols package.
         */
        Disabled = 0,
        /** Create a zip package containing public symbols.
         */
        Public = 1,
        /** Create a zip package containing debugging symbols.
         */
        Debugging = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Compressed texture format for target build platform.
     */
    enum MobileTextureSubtarget {
        /** Don't override texture compression.
         */
        Generic = 0,
        /** S3 texture compression. Supported on devices with NVidia Tegra, Vivante and Intel GPUs.
         */
        DXT = 1,
        /** PowerVR texture compression. Available on devices with PowerVR GPU.
         */
        PVRTC = 2,
        ATC = 3,
        /** ETC1 texture compression (or ETC2 for textures with alpha). ETC1 is supported by all devices. ETC2 is available on devices which support OpenGL ES 3.0; on OpenGL ES 2 devices the texture is decompressed on CPU.
         */
        ETC = 4,
        /** ETC2 texture compression. Available on devices which support OpenGL ES 3.0; on OpenGL ES 2 devices the texture is decompressed on CPU.
         */
        ETC2 = 5,
        /** ASTC texture compression.
         */
        ASTC = 6,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Compressed texture format for target build platform.
     */
    enum WebGLTextureSubtarget {
        /** Don't override texture compression.
         */
        Generic = 0,
        /** S3 texture compression. Supported on devices with NVidia Tegra, Vivante and Intel GPUs.
         */
        DXT = 1,
        /** ETC2 texture compression. Available on devices which support OpenGL ES 3.0; on OpenGL ES 2 devices the texture is decompressed on CPU.
         */
        ETC2 = 3,
        /** ASTC texture compression.
         */
        ASTC = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Build configurations for the Xcode project Unity generates.
     */
    enum XcodeBuildConfig {
        /** Sets the build configuration to Debug for the Xcode project Unity generates.
         */
        Debug = 0,
        /** Sets the build configuration to Release for the Xcode project Unity generates.
         */
        Release = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum SwitchRomCompressionType {
        None = 0,
        Lz4 = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum EmbeddedLinuxArchitecture {
        Arm64 = 0,
        Arm32 = 1,
        X64 = 2,
        X86 = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Result of Asset delete operation
     */
    enum AssetDeleteResult {
        /** Tells the internal implementation that the callback did not delete the asset. The asset will be delete by the internal implementation.
         */
        DidNotDelete = 0,
        /** Tells Unity that the file cannot be deleted and Unity should leave it alone.
         */
        FailedDelete = 1,
        /** Tells Unity that the asset was deleted by the callback. Unity will not try to delete the asset, but will delete the cached version and preview file.
         */
        DidDelete = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array, Object as Object1 } from "System";
    import { Object } from "UnityEngine";
    /** Struct providing an API for stable, project-global object identifiers.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GlobalObjectId extends ValueType {
        constructor()
        toString(): string
        /** Check equality between two GlobalObjectIds.
         */
        Equals(other: GlobalObjectId): boolean
        Equals(obj: Object1): boolean
        /** Converts an Object reference or InstanceID to a GlobalObjectId.
         * @param targetObject The Object to be converted.
         * @param instanceId The InstanceID of the Object to be converted.
         * @returns The converted GlobalObjectId. If the conversion is unsuccessful, the GlobalObjectId is set to the default null ID: "GlobalObjectId_V1-0-00000000000000000000000000000000-0-0". 
         */
        static GetGlobalObjectIdSlow(targetObject: Object): GlobalObjectId
        /** Converts an Object reference or InstanceID to a GlobalObjectId.
         * @param targetObject The Object to be converted.
         * @param instanceId The InstanceID of the Object to be converted.
         * @returns The converted GlobalObjectId. If the conversion is unsuccessful, the GlobalObjectId is set to the default null ID: "GlobalObjectId_V1-0-00000000000000000000000000000000-0-0". 
         */
        static GetGlobalObjectIdSlow(instanceId: number): GlobalObjectId
        /** Creates an array of GlobalObjectIds based on an array of Objects or InstanceIDs.
         * @param objects Array of Objects to convert.
         * @param outputIdentifiers Resulting array of GlobalObjectIds.
         * @param instanceIds Array of InstanceIDs to convert.
         */
        static GetGlobalObjectIdsSlow(objects: Array<Object>, outputIdentifiers: Array<GlobalObjectId>): void
        /** Creates an array of GlobalObjectIds based on an array of Objects or InstanceIDs.
         * @param objects Array of Objects to convert.
         * @param outputIdentifiers Resulting array of GlobalObjectIds.
         * @param instanceIds Array of InstanceIDs to convert.
         */
        static GetGlobalObjectIdsSlow(instanceIds: Array<number>, outputIdentifiers: Array<GlobalObjectId>): void
        /** Parses the string representation of a GlobalObjectId into a GlobalObjectId struct.
         * @param stringValue The string representation of a GlobalObjectId.
Example: "GlobalObjectId_V1-2-74c253e3f16be4776bb2d88e01f77c8a-902906726-0".
         * @param id The GlobalObjectId struct for the parsed values.
         * @returns Returns true if the string representation is successfully parsed. Otherwise, returns false. 
         */
        static TryParse(stringValue: string, id: jsb.Out<GlobalObjectId>): boolean
        /** Converts a GlobalObjectId to an Object reference.
         * @param id The GlobalObjectId to lookup.
         * @returns If the GlobalObjectId is found, this method returns the converted Object reference. Returns null if the GlobalObjectId is not found. 
         */
        static GlobalObjectIdentifierToObjectSlow(id: GlobalObjectId): Object
        /** Creates an array of Objects based on an array of GlobalObjectIds.
         * @param identifiers Array of GlobalObjectIds to convert.
         * @param outputObjects Resulting array of Object references.
         */
        static GlobalObjectIdentifiersToObjectsSlow(identifiers: Array<GlobalObjectId>, outputObjects: Array<Object>): void
        /** Converts a GlobalObjectId to an InstanceID.
         * @param id The GlobalObjectId to lookup.
         * @returns If the GlobalObjectId is found, this method returns the converted InstanceID. Returns 0 if the GlobalObjectId is not found. 
         */
        static GlobalObjectIdentifierToInstanceIDSlow(id: GlobalObjectId): number
        /** Creates an array of InstanceIDs based on an array of GlobalObjectIds.
         * @param identifiers Array of GlobalObjectIds to convert.
         * @param outputInstanceIDs Resulting array of InstanceIDs.
         */
        static GlobalObjectIdentifiersToInstanceIDsSlow(identifiers: Array<GlobalObjectId>, outputInstanceIDs: Array<number>): void
        /** The local file ID of the object.
         */
        readonly targetObjectId: number
        /** The prefab instance id of the object.
         */
        readonly targetPrefabId: number
        /** The GUID for the asset to which this object belongs.
         */
        readonly assetGUID: GUID
        /** The identifier type represented as an integer.
         */
        readonly identifierType: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** This class describes a shader.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderData extends Object {
        /** Get a subshader.
         * @param index The index of the subshader.
         * @returns The associated subshader or null if none exists. 
         */
        GetSubshader(index: number): ShaderData.Subshader
        /** Obtains the serialized subshader at the given index.
         * @param index The index of the serialized subshader.
         * @returns The associated serialized subshader or null if none exists. 
         */
        GetSerializedSubshader(index: number): ShaderData.Subshader
        protected constructor()
        /** Returns the index of the active subshader or -1 if none is currently active.
         */
        readonly ActiveSubshaderIndex: number
        /** The number of subshaders used by this shader.
         */
        readonly SubshaderCount: number
        /** Obtains the serialized subshader at the given index.
         */
        readonly SerializedSubshaderCount: number
        /** The shader attached to this data set.
         */
        readonly SourceShader: any
        /** Returns the active subshader or null if none is currently active.
         */
        readonly ActiveSubshader: ShaderData.Subshader
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Subshader extends Object {
            FindTagValue(tagName: any): any
            GetPass(passIndex: number): ShaderData.Pass
            protected constructor()
            readonly PassCount: number
            readonly LevelOfDetail: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType, Enum, Array } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Pass extends Object {
            FindTagValue(tagName: any): any
            HasShaderStage(shaderType: any): boolean
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>, tier: any, forExternalTool: boolean): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, tier: any, forExternalTool: boolean): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>, forExternalTool: boolean): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>, tier: any): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, forExternalTool: boolean): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, tier: any): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>): ShaderData.VariantCompileInfo
            CompileVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget): ShaderData.VariantCompileInfo
            PreprocessVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>, tier: any, stripLineDirectives: boolean): ShaderData.PreprocessedVariant
            PreprocessVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, tier: any, stripLineDirectives: boolean): ShaderData.PreprocessedVariant
            PreprocessVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, platformKeywords: Array<any>, stripLineDirectives: boolean): ShaderData.PreprocessedVariant
            PreprocessVariant(shaderType: any, keywords: Array<string>, shaderCompilerPlatform: any, buildTarget: BuildTarget, stripLineDirectives: boolean): ShaderData.PreprocessedVariant
            protected constructor()
            readonly SourceCode: string
            readonly Name: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class PreprocessedVariant extends ValueType {
            constructor()
            readonly Success: boolean
            readonly Messages: Array<ShaderMessage>
            readonly PreprocessedCode: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array, Enum } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class VariantCompileInfo extends ValueType {
            constructor()
            readonly Success: boolean
            readonly Messages: Array<ShaderMessage>
            readonly ShaderData: Array<jsb.byte>
            readonly Attributes: Array<any>
            readonly ConstantBuffers: Array<ShaderData.ConstantBufferInfo>
            readonly TextureBindings: Array<ShaderData.TextureBindingInfo>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ConstantBufferInfo extends ValueType {
            constructor()
            readonly Name: string
            readonly Size: number
            readonly Fields: Array<ShaderData.ConstantInfo>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum, Array } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ConstantInfo extends ValueType {
            constructor()
            readonly Name: string
            readonly Index: number
            readonly ConstantType: any
            readonly DataType: any
            readonly Rows: number
            readonly Columns: number
            readonly ArraySize: number
            readonly StructSize: number
            readonly StructFields: Array<ShaderData.ConstantInfo>
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    namespace ShaderData {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class TextureBindingInfo extends ValueType {
            constructor()
            readonly Name: string
            readonly Index: number
            readonly SamplerIndex: number
            readonly Multisampled: boolean
            readonly ArraySize: number
            readonly Dim: any
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Build target group.
     */
    enum BuildTargetGroup {
        /** Unknown target.
         */
        Unknown = 0,
        /** PC (Windows, Mac, Linux) target.
         */
        Standalone = 1,
        /** Mac/PC webplayer target.
         */
        WebPlayer = 2,
        /** OBSOLETE: Use iOS. Apple iOS target.
         */
        iPhone = 4,
        /** OBSOLETE: Use iOS. Apple iOS target.
         */
        iOS = 4,
        PS3 = 5,
        XBOX360 = 6,
        /** Android target.
         */
        Android = 7,
        /** WebGL.
         */
        WebGL = 13,
        /** Windows Store Apps target.
         */
        WSA = 14,
        /** Windows Store Apps target.
         */
        Metro = 14,
        WP8 = 15,
        BlackBerry = 16,
        Tizen = 17,
        PSP2 = 18,
        /** Sony Playstation 4 target.
         */
        PS4 = 19,
        PSM = 20,
        /** Microsoft Xbox One target.
         */
        XboxOne = 21,
        SamsungTV = 22,
        /** Nintendo 3DS target.
         */
        N3DS = 23,
        WiiU = 24,
        /** Apple's tvOS target.
         */
        tvOS = 25,
        Facebook = 26,
        /** Nintendo Switch target.
         */
        Switch = 27,
        Lumin = 28,
        /** Google Stadia target.
         */
        Stadia = 29,
        /** CloudRendering target.
         */
        CloudRendering = 30,
        /** CloudRendering target.
         */
        LinuxHeadlessSimulation = 30,
        GameCoreScarlett = 31,
        GameCoreXboxSeries = 31,
        GameCoreXboxOne = 32,
        /** Sony Playstation 5 target.
         */
        PS5 = 33,
        EmbeddedLinux = 34,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** AssetModificationProcessor lets you hook into saving of serialized assets and
      scenes which are edited inside Unity.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetModificationProcessor extends Object {
        constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Result of Asset move
     */
    enum AssetMoveResult {
        /** Tells the internal implementation that the asset was not moved physically on disk by the script.
         */
        DidNotMove = 0,
        /** Tells the internal implementation that the script could not move the assets.
         */
        FailedMove = 1,
        /** Tells the internal implementation that the script moved the asset physically on disk.
         */
        DidMove = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Supported iOS SDK versions.
     */
    enum iOSSdkVersion {
        /** Device SDK.
         */
        DeviceSDK = 988,
        /** Simulator SDK.
         */
        SimulatorSDK = 989,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Target iOS device.
     */
    enum iOSTargetDevice {
        /** iPhone/iPod Only.
         */
        iPhoneOnly = 0,
        /** iPad Only.
         */
        iPadOnly = 1,
        /** Universal : iPhone/iPod + iPad.
         */
        iPhoneAndiPad = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Activity Indicator on loading.
     */
    enum iOSShowActivityIndicatorOnLoading {
        /** White Large.
         */
        WhiteLarge = 0,
        /** White.
         */
        White = 1,
        /** Gray.
         */
        Gray = 2,
        /** Don't Show.
         */
        DontShow = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** iOS status bar style.
     */
    enum iOSStatusBarStyle {
        /** Default.
         */
        Default = 0,
        /** A light status bar, intended for use on dark backgrounds.
         */
        LightContent = 1,
        BlackTranslucent = -1,
        BlackOpaque = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Application behavior when entering background.
     */
    enum iOSAppInBackgroundBehavior {
        /** Application should suspend execution when entering background.
         */
        Suspend = 0,
        /** Application should exit when entering background.
         */
        Exit = 1,
        /** Custom background behavior, see iOSBackgroundMode for specific background modes.
         */
        Custom = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Background modes supported by the application corresponding to project settings in Xcode.
     */
    enum iOSBackgroundMode {
        /** No background modes supported.
         */
        None = 0,
        /** Audio, AirPlay and Picture in Picture.
         */
        Audio = 1,
        /** Location updates.
         */
        Location = 2,
        /** Voice over IP.
         */
        VOIP = 4,
        /** Newsstand downloads.
         */
        NewsstandContent = 8,
        /** External accessory communication.
         */
        ExternalAccessory = 16,
        /** Uses Bluetooth LE accessories.
         */
        BluetoothCentral = 32,
        /** Acts as a Bluetooth LE accessory.
         */
        BluetoothPeripheral = 64,
        /** Background fetch.
         */
        Fetch = 128,
        /** Remote notifications.
         */
        RemoteNotification = 256,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** iOS launch screen settings.
     */
    enum iOSLaunchScreenImageType {
        /** Portrait oriented launch screen image on the iPhone.
         */
        iPhonePortraitImage = 0,
        /** Landscape oriented launch screen image on the iPhone.
         */
        iPhoneLandscapeImage = 1,
        /** Launch screen image on the iPad.
         */
        iPadImage = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** iOS launch screen settings.
     */
    enum iOSLaunchScreenType {
        /** Use the default launch screen (dark blue background).
         */
        Default = 0,
        /** Use a custom launch screen image specified in the iOS Player Settings or with PlayerSettings.iOS.SetLaunchScreenImage which will be scaled across the entire screen.
         */
        ImageAndBackgroundRelative = 1,
        /** Use a specified custom Interface Builder (.xib) file in Player Settings.
         */
        CustomXib = 2,
        /** Generate the Xcode project without any custom launch screens.
         */
        None = 3,
        /** Use a custom launch screen image specified in the iOS Player Settings or with PlayerSettings.iOS.SetLaunchScreenImage and use its original dimensions.
         */
        ImageAndBackgroundConstant = 4,
        /** Use a specified custom Storyboard (.storyboard) file in Player Settings.
         */
        CustomStoryboard = 5,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The type of the iOS provisioning profile if manual signing is used.
     */
    enum ProvisioningProfileType {
        /** The provisioning profile type will be determined automatically when building the Xcode project.
         */
        Automatic = 0,
        /** Development provisioning profiles are used to install development apps on test devices.
         */
        Development = 1,
        /** Distribution provisioning profiles can be used when uploading the app to the App Store or for Ad Hoc and in house distribution.
         */
        Distribution = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** A device requirement description used for configuration of App Slicing.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class iOSDeviceRequirement extends Object {
        constructor()
        /** The values of the device requirement description.
         */
        readonly values: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class UnityStats extends Object {
        constructor()
        static readonly batches: number
        static readonly drawCalls: number
        static readonly dynamicBatchedDrawCalls: number
        static readonly staticBatchedDrawCalls: number
        static readonly instancedBatchedDrawCalls: number
        static readonly dynamicBatches: number
        static readonly staticBatches: number
        static readonly instancedBatches: number
        static readonly setPassCalls: number
        static readonly triangles: number
        static readonly vertices: number
        static readonly shadowCasters: number
        static readonly renderTextureChanges: number
        static readonly frameTime: number
        static readonly renderTime: number
        static readonly audioLevel: number
        static readonly audioClippingAmount: number
        static readonly audioDSPLoad: number
        static readonly audioStreamLoad: number
        static readonly renderTextureCount: number
        static readonly renderTextureBytes: number
        static readonly usedTextureMemorySize: number
        static readonly usedTextureCount: number
        static readonly screenRes: string
        static readonly screenBytes: number
        static readonly vboTotal: number
        static readonly vboTotalBytes: number
        static readonly vboUploads: number
        static readonly vboUploadBytes: number
        static readonly ibUploads: number
        static readonly ibUploadBytes: number
        static readonly visibleSkinnedMeshes: number
        static readonly animationComponentsPlaying: number
        static readonly animatorComponentsPlaying: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    import { Array, ValueType } from "System";
    /** Manages Scene Visibility in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneVisibilityManager extends ScriptableSingleton<SceneVisibilityManager> {
        constructor()
        HideAll(): void
        DisableAllPicking(): void
        /** Shows a GameObject, or an array of GameObjects, and its descendants.
         * @param gameObject GameObject to show.
         * @param gameObjects Array of GameObjects to show.
         * @param includeDescendants Whether to include descendants.
         */
        Show(gameObject: GameObject, includeDescendants: boolean): void
        /** Shows a GameObject, or an array of GameObjects, and its descendants.
         * @param gameObject GameObject to show.
         * @param gameObjects Array of GameObjects to show.
         * @param includeDescendants Whether to include descendants.
         */
        Show(gameObjects: Array<GameObject>, includeDescendants: boolean): void
        /** Shows all GameObjects in scene.
         * @param scene Scene containing GameObjects to show.
         */
        Show(scene: any): void
        /** Hides a GameObject, or an Array of GameObjects,  and their descendants.
         * @param gameObject GameObject to hide.
         * @param gameObjects Array of GameObjects to hide.
         * @param includeDescendants Whether to also hide descendants.
         */
        Hide(gameObject: GameObject, includeDescendants: boolean): void
        /** Hides a GameObject, or an Array of GameObjects,  and their descendants.
         * @param gameObject GameObject to hide.
         * @param gameObjects Array of GameObjects to hide.
         * @param includeDescendants Whether to also hide descendants.
         */
        Hide(gameObjects: Array<GameObject>, includeDescendants: boolean): void
        /** Hides all GameObjects in a scene.
         * @param scene Scene containing GameObjects to hide.
         */
        Hide(scene: any): void
        /** Disables picking on a GameObject, or an Array of GameObjects, and their descendants.
         * @param gameObject GameObject on which to disable picking.
         * @param includeDescendants Whether to include descendants.
         * @param gameObjects Array of GameObjects on which to disable picking.
         */
        DisablePicking(gameObject: GameObject, includeDescendants: boolean): void
        /** Disables picking on a GameObject, or an Array of GameObjects, and their descendants.
         * @param gameObject GameObject on which to disable picking.
         * @param includeDescendants Whether to include descendants.
         * @param gameObjects Array of GameObjects on which to disable picking.
         */
        DisablePicking(gameObjects: Array<GameObject>, includeDescendants: boolean): void
        /** Disables picking on all GameObjects in a Scene.
         * @param scene Scene containing GameObjects on which to disable picking.
         */
        DisablePicking(scene: any): void
        /** Enables picking on a GameObject, or an array of GameObjects, and its descendants.
         * @param includeDescendants Whether to include descendants.
         * @param gameObject GameObject on which to enable picking.
         * @param gameObjects Array of GameObjects on which to enable picking.
         */
        EnablePicking(gameObject: GameObject, includeDescendants: boolean): void
        /** Enables picking on a GameObject, or an array of GameObjects, and its descendants.
         * @param includeDescendants Whether to include descendants.
         * @param gameObject GameObject on which to enable picking.
         * @param gameObjects Array of GameObjects on which to enable picking.
         */
        EnablePicking(gameObjects: Array<GameObject>, includeDescendants: boolean): void
        /** Enables picking on all GameObjects in a Scene.
         * @param scene Scene containing GameObjects on which to enable picking.
         */
        EnablePicking(scene: any): void
        ShowAll(): void
        EnableAllPicking(): void
        /** Checks the hidden state of a GameObject and, optionally, its descendants.
         * @param gameObject GameObject to check.
         * @param includeDescendants Specify true to check the GameObject and all its descendants. Set to false to check the GameObject.
         * @returns When includeDescendants is true, this method returns true when the GameObject and all its descendants are hidden. When includeDescendants is false, this method returns true when the GameObject is hidden. 
         */
        IsHidden(gameObject: GameObject, includeDescendants: boolean): boolean
        IsHidden(scene: any): boolean
        /** Checks the picking state of a GameObject and, optionally, its descendants.
         * @param gameObject GameObject to check.
         * @param includeDescendants Specify true to check the GameObject and all its descendants. Set to false to check the GameObject.
         * @returns When includeDescendants is true, this method returns true when the GameObject and all its descendants have picking disabled. When includeDescendants is false, this method returns true when the GameObject has picking disabled. 
         */
        IsPickingDisabled(gameObject: GameObject, includeDescendants: boolean): boolean
        IsPickingDisabled(scene: any): boolean
        /** Checks whether root GameObjects, and all their descendants, are hidden in a Scene.
         * @param scene Scene to check.
         * @returns Returns true if all root GameObjects of the Scene and all their descendants are hidden. 
         */
        AreAllDescendantsHidden(scene: any): boolean
        /** Checks whether all the descendants of a GameObject are hidden.
         * @param gameObject GameObject to check.
         * @returns Returns true if all descendants are hidden. 
         */
        AreAllDescendantsHidden(gameObject: GameObject): boolean
        /** Checks whether all the descendants of a GameObject have picking disabled.
         * @param scene Scene to check.
         * @returns Returns true if all descendants have picking disabled. 
         */
        IsPickingDisabledOnAllDescendants(scene: any): boolean
        /** Checks whether root GameObjects, and all their descendants, have picking disabled in a scene.
         * @param gameObject GameObject to check.
         * @returns Returns true if all root GameObjects of the Scene and all their descendants have picking disabled. 
         */
        IsPickingDisabledOnAllDescendants(gameObject: GameObject): boolean
        /** Checks whether any descendants are hidden.
         * @param scene Scene to check.
         * @returns Returns true when at least one hidden descendant is found. 
         */
        AreAnyDescendantsHidden(scene: any): boolean
        /** Checks whether any descendants have picking disabled.
         * @param scene Scene to check.
         * @returns Returns true when at least one descendant with picking disabled is found. 
         */
        IsPickingDisabledOnAnyDescendant(scene: any): boolean
        /** Isolates a GameObject and its descendants.
         * @param gameObject GameObject to isolate.
         * @param includeDescendants Whether to include descendants.
         */
        Isolate(gameObject: GameObject, includeDescendants: boolean): void
        /** Isolates an Array of GameObjects and their descendants.
         * @param gameObjects Array of GameObjects to isolate.
         * @param includeDescendants Whether to include descendants.
         */
        Isolate(gameObjects: Array<GameObject>, includeDescendants: boolean): void
        /** Toggles the visible state of a GameObject.
         * @param gameObject GameObject on which to toggle visibility.
         * @param includeDescendants Whether to include descendants.
         */
        ToggleVisibility(gameObject: GameObject, includeDescendants: boolean): void
        /** Toggles the picking ability of a GameObject.
         * @param gameObject GameObject on which to toggle picking ability.
         * @param includeDescendants Whether to include descendants.
         */
        TogglePicking(gameObject: GameObject, includeDescendants: boolean): void
        /** Checks whether all the descendants are visible.
         * @param gameObject GameObject to check.
         * @returns Returns true if all descendants of the GameObject are visible. 
         */
        AreAllDescendantsVisible(gameObject: GameObject): boolean
        /** Checks whether all the descendants are pickable.
         * @param gameObject GameObject on which to do the check.
         * @returns Returns true if all descendants of the GameObject are pickable. 
         */
        IsPickingEnabledOnAllDescendants(gameObject: GameObject): boolean
        IsCurrentStageIsolated(): boolean
        ExitIsolation(): void
        static visibilityChanged(op: "add" | "remove", fn: () => void): void
        static pickingChanged(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ScriptableSingleton_SceneVisibilityManager extends ScriptableObject {
        protected constructor()
        static readonly instance: SceneVisibilityManager
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ScriptableSingleton<T> extends ScriptableObject {
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Defines the types of devices on which an Android application is allowed to run. Used for the PlayerSettings.Android._androidTargetDevices property.
     */
    enum AndroidTargetDevices {
        /** The Android build is allowed to run on all target devices.
         */
        AllDevices = 0,
        /** The Android build is only allowed to run on Android phones, tablets, and TV devices, not on any type of Chrome OS device.
         */
        PhonesTabletsAndTVDevicesOnly = 1,
        /** The Android build is only allowed to run on Chrome OS devices.
         */
        ChromeOSDevicesOnly = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options to control the application window orientation when Default orientation is set to Auto rotation.
     */
    enum AndroidAutoRotationBehavior {
        /** Application window rotates based on the device’s auto rotate orientation settings.
         */
        User = 1,
        /** Application window rotates based on the device’s orientation sensor.
         */
        Sensor = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    /** Represents entries in the Scenes list, as displayed in the window. This class contains the Scene path of a Scene and an enabled flag that indicates whether the Scene is enabled in the Build Settings window or not.

You can use this class in combination with EditorBuildSettings.scenes to populate the list of Scenes included in the build via script. This is useful when you create custom editor scripts to automate your build pipeline.

See EditorBuildSettings.scenes for an example script.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorBuildSettingsScene extends Object {
        constructor(path: string, enabled: boolean)
        constructor(guid: GUID, enabled: boolean)
        constructor()
        CompareTo(obj: Object): number
        static GetActiveSceneList(scenes: Array<EditorBuildSettingsScene>): Array<string>
        /** Whether this Scene is enabled in the for an example of how to use this class.

Additional resources: EditorBuildSettingsScene, EditorBuildSettings.scenes.
         */
        enabled: boolean
        /** The file path of the Scene as listed in the Editor for an example of how to use this class.

Additional resources: EditorBuildSettingsScene, EditorBuildSettings.scenes.
         */
        path: string
        guid: GUID
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Array } from "System";
    /** This class allows you to modify the Editor for an example of how to use this class.

Additional resources: EditorBuildSettingsScene, EditorBuildSettings.scenes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorBuildSettings extends Object {
        /** Remove a config object reference by name.
         * @param name The name in string format of the config object reference to be removed. This is the name given to the object when the reference is first created. Note: This may be different than the object name as an object can be added multiple times with different names.
         * @returns Returns true if the reference was found and removed, otherwise false. 
         */
        static RemoveConfigObject(name: string): boolean
        static GetConfigObjectNames(): Array<string>
        /** Store a reference to a config object by name.  The object must be an asset in the project, otherwise it will not be saved when the editor is restarted or scripts are reloaded.  To avoid name conflicts with other packages, it is recommended that names are qualified by a namespace, i.e. "company.package.name".
         * @param name The name of the object reference in string format. This string name must be unique within your project or the overwrite parameter must be set to true.
         * @param obj Object reference to be stored.  This object must be persisted and not null.
         * @param overwrite Boolean parameter used to specify that you want to overwrite an entry with the same name if one already exists.
         * @returns Throws an exception if the object is null, not persisted, or if there is a name conflict and the overwrite parameter is set to false. 
         */
        static AddConfigObject(name: string, obj: Object, overwrite: boolean): void
        protected constructor()
        /** The list of Scenes that should be included in the build.
This is the same list of Scenes that is shown in the window. You can modify this list to set up which Scenes should be included in the build.
         */
        static scenes: Array<EditorBuildSettingsScene>
        static sceneListChanged(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    /** DefaultAsset is used for assets that do not have a specific type (yet).
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DefaultAsset extends Object {
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, Transform, GameObject, Component } from "UnityEngine";
    /** Lets you register undo operations on specific objects you are about to perform changes on.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Undo extends Object {
        constructor()
        /** Stores a copy of the object states on the undo stack.
         * @param objectToUndo The object whose state changes need to be undone.
         * @param name The name of the undo operation.
         */
        static RegisterCompleteObjectUndo(objectToUndo: Object1, name: string): void
        /** This is equivalent to calling the first overload mutiple times, save for the fact that only one undo operation will be generated for this one.
         * @param objectsToUndo An array of objects whose state changes need to be undone.
         * @param name The name of the undo operation.
         */
        static RegisterCompleteObjectUndo(objectsToUndo: Array<Object1>, name: string): void
        static SetTransformParent(transform: Transform, newParent: Transform, worldPositionStays: boolean, name: string): void
        /** Sets the parent of transform to the new parent and records an undo operation.
         * @param transform The Transform component whose parent is to be changed.
         * @param newParent The parent Transform to be assigned.
         * @param name The name of this action, to be stored in the Undo history buffer.
         */
        static SetTransformParent(transform: Transform, newParent: Transform, name: string): void
        /** Move a GameObject from its current Scene to a new Scene.
It is required that the GameObject is at the root of its current Scene.
         * @param go GameObject to move.
         * @param scene Scene to move the GameObject into.
         * @param name Name of the undo action.
         */
        static MoveGameObjectToScene(go: GameObject, scene: any, name: string): void
        /** Registers an undo operation to undo the creation of an object.
         * @param objectToUndo The newly created object. This object is destroyed when the undo operation is performed. When the value is a GameObject, Unity registers the GameObject and its child GameObjects, but not sibling or parent GameObjects.
         * @param name The name of the action to undo. Use this string to provide a short description of the action to be undone. For Undo or Redo items in the Edit menu, Unity adds "Undo" or "Redo" to the string that you provide. For example, if you provide the string "Create GameObject", the Unity Editor displays the menu item Edit > Undo Create GameObject.
         */
        static RegisterCreatedObjectUndo(objectToUndo: Object1, name: string): void
        /** Destroys the object and records an undo operation so that it can be recreated.
         * @param objectToUndo The object that will be destroyed.
         */
        static DestroyObjectImmediate(objectToUndo: Object1): void
        /** Adds a component to the game object and registers an undo operation for this action.
         * @param gameObject The game object you want to add the component to.
         * @param type The type of component you want to add.
         * @returns The newly added component. 
         */
        static AddComponent(gameObject: GameObject, type: any): Component
        /** Copies the state of the importer for the given asset path.
         * @param path Path of the asset importer to register for Undo.
         * @param name The name of the undo operation.
         */
        static RegisterImporterUndo(path: string, name: string): void
        /** Stores a copy of the order of the object's children on the undo stack.
         * @param objectToUndo The object whose child order should be recorded on the undo stack.
         * @param name The name of the undo operation.
         */
        static RegisterChildrenOrderUndo(objectToUndo: Object1, name: string): void
        /** Copy the states of a hierarchy of objects onto the undo stack.
         * @param objectToUndo The object used to determine a hierarchy of objects whose state changes need to be undone.
         * @param name The name of the undo operation.
         */
        static RegisterFullObjectHierarchyUndo(objectToUndo: Object1, name: string): void
        /** Records any changes done on the object after the RecordObject function.
         * @param objectToUndo The reference to the object that you will be modifying.
         * @param name The title of the action to appear in the undo history (i.e. visible in the undo menu).
         */
        static RecordObject(objectToUndo: Object1, name: string): void
        /** Records multiple undoable objects in a single call. This is the same as calling Undo.RecordObject multiple times.
         */
        static RecordObjects(objectsToUndo: Array<Object1>, name: string): void
        /** Removes all Undo operation for the identifier object registered using Undo.RegisterCompleteObjectUndo from the undo stack.
         */
        static ClearUndo(identifier: Object1): void
        static PerformUndo(): void
        static PerformRedo(): void
        static IncrementCurrentGroup(): void
        static GetCurrentGroup(): number
        static GetCurrentGroupName(): string
        /** Set the name of the current undo group.
         * @param name New name of the current undo group.
         */
        static SetCurrentGroupName(name: string): void
        static RevertAllInCurrentGroup(): void
        /** Performs all undo operations up to the group index without storing a redo operation in the process.
         */
        static RevertAllDownToGroup(group: number): void
        /** Collapses all undo operation up to group index together into one step.
         * @param groupIndex The group index to collapse undo operations to.
         */
        static CollapseUndoOperations(groupIndex: number): void
        static ClearAll(): void
        static FlushUndoRecordObjects(): void
        static undoRedoPerformed(op: "get"): () => void
        static undoRedoPerformed(op: "add" | "remove" | "set", fn?: () => void): void
        static undoRedoPerformed(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static willFlushUndoRecord(op: "get"): () => void
        static willFlushUndoRecord(op: "add" | "remove" | "set", fn?: () => void): void
        static willFlushUndoRecord(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        static postprocessModifications(op: "get"): (modifications: Array<UndoPropertyModification>) => Array<UndoPropertyModification>
        static postprocessModifications(op: "add" | "remove" | "set", fn?: (modifications: Array<UndoPropertyModification>) => Array<UndoPropertyModification>): void
        static postprocessModifications(op: "add" | "remove" | "set" | "get", fn?: (modifications: Array<UndoPropertyModification>) => Array<UndoPropertyModification>): (modifications: Array<UndoPropertyModification>) => Array<UndoPropertyModification> | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Describes which Unity systems consider the GameObject as static, and include the GameObject in their precomputations in the Unity Editor.
     */
    enum StaticEditorFlags {
        /** Include the GameObject when precomputing lighting data.
         */
        ContributeGI = 1,
        /** Include the GameObject when precomputing lighting data.
         */
        LightmapStatic = 1,
        /** Mark the GameObject as a Static Occluder in the occlusion culling system.
         */
        OccluderStatic = 2,
        /** Combine the GameObject's Mesh with other eligible Meshes, to potentially reduce runtime rendering costs.
         */
        BatchingStatic = 4,
        /** Include the GameObject when precomputing navigation data.
         */
        NavigationStatic = 8,
        /** Mark the GameObject as a Static Occludee in the occlusion culling system.
         */
        OccludeeStatic = 16,
        /** Attempt to generate an Off-Mesh Link that starts from this GameObject when precomputing navigation data.
         */
        OffMeshLinkGeneration = 32,
        /** Include this GameObject when when precomputing data for Reflection Probes whose Type property is set to Baked.
         */
        ReflectionProbeStatic = 64,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    /** Represents a managed reference object that has a missing type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ManagedReferenceMissingType extends ValueType {
        constructor()
        Equals(other: ManagedReferenceMissingType): boolean
        Equals(obj: Object): boolean
        CompareTo(other: ManagedReferenceMissingType): number
        /** Name of the Assembly where Unity expects to find the class. (Read Only)
         */
        readonly assemblyName: string
        /** Name of the class that is needed to instantiate the Managed Reference. (Read Only)
         */
        readonly className: string
        /** Namespace where Unity expects to find the class.  Namespaces are optional so this might contain an empty string. (Read Only)
         */
        readonly namespaceName: string
        /** The Managed Reference ID. (Read Only)
         */
        readonly referenceId: number
        /** String summarizing the content of the serialized data of the missing object. (Read Only)
         */
        readonly serializedData: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Utility functions related to Serialization.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SerializationUtility extends Object {
        constructor()
        /** Assigns a managed reference Id to an object that is referenced using SerializeReference.
         */
        static SetManagedReferenceIdForObject(obj: Object1, scriptObj: Object, refId: number): boolean
        /** Retrieves the managed reference Id for an object that is referenced using SerializeReference.
         */
        static GetManagedReferenceIdForObject(obj: Object1, scriptObj: Object): number
        /** Retrieves an object based on its managed reference Id.
         */
        static GetManagedReference(obj: Object1, id: number): Object
        /** Retrieves the list of managed reference Ids assigned to objects that are referenced using SerializeReference.
         */
        static GetManagedReferenceIds(obj: Object1): Array<number>
        /** This API returns true if one or more managed references is missing its type.
         */
        static HasManagedReferencesWithMissingTypes(obj: Object1): boolean
        /** Returns the list of managed references that could not be deserialized because of a missing type.
         */
        static GetManagedReferencesWithMissingTypes(obj: Object1): Array<ManagedReferenceMissingType>
        /** Removes all managed references that are missing their type.
         */
        static ClearAllManagedReferencesWithMissingTypes(obj: Object1): boolean
        /** Drop the serialized data associated with a specific managed reference object that is missing its type.
         */
        static ClearManagedReferenceWithMissingType(obj: Object1, id: number): boolean
        /** Special value, -1, used when the managed reference Id for an object is unknown, for example if GetManagedReferenceIdForObject is called with invalid arguments.
                
         */
        static readonly RefIdUnknown: number
        /** Special value, -2, used as the managed reference Id of any field decorated with SerializeReference that has no object assigned to it.
         */
        static readonly RefIdNull: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Sets the scope of a SettingsProvider. The Scope determines where it appears in the UI. For example, whether it appears with the Project settings in the Settings window, or in the Preferences window, or in both windows.
     */
    enum SettingsScope {
        /** The SettingsProvider appears only in the Preferences window.
         */
        User = 0,
        /** The SettingsProvider appears only in the Project Settings window.
         */
        Project = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    /** SettingsProvider is the configuration class that specifies how a Project setting or a preference should appear in the Settings or Preferences window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SettingsProvider extends Object {
        constructor(path: string, scopes: SettingsScope, keywords: IEnumerable<string>)
        /** Use this function to implement a handler for when the user clicks on the Settings in the Settings window. You can fetch a settings Asset or set up UIElements UI from this function.
         * @param searchContext Search context in the search box on the Settings window.
         * @param rootElement Root of the UIElements tree. If you add to this root, the SettingsProvider uses UIElements instead of calling SettingsProvider.OnGUI to build the UI. If you do not add to this VisualElement, then you must use the IMGUI to build the UI.
         */
        OnActivate(searchContext: string, rootElement: any): void
        OnDeactivate(): void
        /** Checks whether the SettingsProvider should appear when the user types something in the Settings window search box. SettingsProvider tries to match the search terms (even partially) to any of the SettingsProvider.keywords. The search is case insensitive.
         * @param searchContext Search terms that the user entered in the search box on the Settings window.
         * @returns True if the SettingsProvider matched the search term and if it should appear. 
         */
        HasSearchInterest(searchContext: string): boolean
        /** Use this function to draw the UI based on IMGUI. This assumes you haven't added any children to the rootElement passed to the OnActivate function.
         * @param searchContext Search context for the Settings window. Used to show or hide relevant properties.
         */
        OnGUI(searchContext: string): void
        OnTitleBarGUI(): void
        OnFooterBarGUI(): void
        OnInspectorUpdate(): void
        Repaint(): void
        /** Extract search keywords from from the serialized properties of a SerializedObject.
         * @param serializedObject Object to extract properties from.
         * @returns Returns the list of keywords. 
         */
        static GetSearchKeywordsFromSerializedObject(serializedObject: SerializedObject): IEnumerable<string>
        /** Extract search keywords from the serialized properties of an Asset at a specific path.
         * @param path Path of the Asset on disk.
         * @returns Returns the list of keywords. 
         */
        static GetSearchKeywordsFromPath(path: string): IEnumerable<string>
        /** Gets or sets the display name of the SettingsProvider as it appears in the Settings window. If not set, the Settings window uses last token of SettingsProvider.settingsPath instead.
         */
        label: string
        /** Gets Path used to place the SettingsProvider in the tree view of the Settings window. The path should be unique among all other settings paths and should use "/" as its separator.
         */
        readonly settingsPath: string
        /** Gets the Scope of the SettingsProvider. The Scope determines whether the SettingsProvider appears in the Preferences window (SettingsScope.User) or the Settings window (SettingsScope.Project).
         */
        readonly scope: SettingsScope
        /** Gets or sets the list of keywords to compare against what the user is searching for. When the user enters values in the search box on the Settings window, SettingsProvider.HasSearchInterest tries to match those keywords to this list.
         */
        keywords: IEnumerable<string>
        guiHandler(op: "get"): (obj: string) => void
        guiHandler(op: "add" | "remove" | "set", fn?: (obj: string) => void): void
        guiHandler(op: "add" | "remove" | "set" | "get", fn?: (obj: string) => void): (obj: string) => void | void
        titleBarGuiHandler(op: "get"): () => void
        titleBarGuiHandler(op: "add" | "remove" | "set", fn?: () => void): void
        titleBarGuiHandler(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        footerBarGuiHandler(op: "get"): () => void
        footerBarGuiHandler(op: "add" | "remove" | "set", fn?: () => void): void
        footerBarGuiHandler(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        activateHandler(op: "get"): (arg1: string, arg2: any) => void
        activateHandler(op: "add" | "remove" | "set", fn?: (arg1: string, arg2: any) => void): void
        activateHandler(op: "add" | "remove" | "set" | "get", fn?: (arg1: string, arg2: any) => void): (arg1: string, arg2: any) => void | void
        deactivateHandler(op: "get"): () => void
        deactivateHandler(op: "add" | "remove" | "set", fn?: () => void): void
        deactivateHandler(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
        hasSearchInterestHandler(op: "get"): (arg: string) => boolean
        hasSearchInterestHandler(op: "add" | "remove" | "set", fn?: (arg: string) => boolean): void
        hasSearchInterestHandler(op: "add" | "remove" | "set" | "get", fn?: (arg: string) => boolean): (arg: string) => boolean | void
        inspectorUpdateHandler(op: "get"): () => void
        inspectorUpdateHandler(op: "add" | "remove" | "set", fn?: () => void): void
        inspectorUpdateHandler(op: "add" | "remove" | "set" | "get", fn?: () => void): () => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** This class provides global APIs to interact with the Settings window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class SettingsService extends Object {
        /** Open the Project Settings window with the specified settings item already selected.
         * @param settingsPath Settings paths of the item to select (for example, 'ProjectPlayer' or 'ProjectQuality').
         * @returns Returns an instance to the Settings window. 
         */
        static OpenProjectSettings(settingsPath: string): EditorWindow
        /** Open the Preferences window with the specified settings item already selected.
         * @param settingsPath Settings path of the item to select (for example, 'PreferencesKeys' or 'Preferences2D').
         * @returns Returns an instance to the Settings window. 
         */
        static OpenUserPreferences(settingsPath: string): EditorWindow
        static NotifySettingsProviderChanged(): void
        static RepaintAllSettingsWindow(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Base class for PropertyDrawer and DecoratorDrawer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class GUIDrawer extends Object {
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    /** Base class to derive custom decorator drawers from.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class DecoratorDrawer extends GUIDrawer {
        /** Override this method to make your own GUI for the decorator.
See DecoratorDrawer for an example of how to use this.
         * @param position Rectangle on the screen to use for the decorator GUI.
         */
        OnGUI(position: Rect): void
        GetHeight(): number
        CanCacheInspectorGUI(): boolean
        /** The PropertyAttribute for the decorator. (Read Only)
         */
        readonly attribute: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect, GUIContent } from "UnityEngine";
    /** Base class to derive custom property drawers from. Use this to create custom drawers for your own Serializable classes or for script variables with custom PropertyAttributes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PropertyDrawer extends GUIDrawer {
        /** Override this method to make your own IMGUI based GUI for the property.
         * @param position Rectangle on the screen to use for the property GUI.
         * @param property The SerializedProperty to make the custom GUI for.
         * @param label The label of this property.
         */
        OnGUI(position: Rect, property: SerializedProperty, label: GUIContent): void
        /** Override this method to make your own UI Toolkit based GUI for the property.
         * @param property The SerializedProperty to make the custom GUI for.
         * @returns The element containing the custom GUI. 
         */
        CreatePropertyGUI(property: SerializedProperty): any
        /** Override this method to specify how tall the GUI for this field is in pixels.
         * @param property The SerializedProperty to make the custom GUI for.
         * @param label The label of this property.
         * @returns The height in pixels. 
         */
        GetPropertyHeight(property: SerializedProperty, label: GUIContent): number
        /** Override this method to determine whether the inspector GUI for your property can be cached.
         * @param property The SerializedProperty to make the custom GUI for.
         * @returns Whether the drawer's UI can be cached. 
         */
        CanCacheInspectorGUI(property: SerializedProperty): boolean
        /** The PropertyAttribute for the property. Not applicable for custom class drawers. (Read Only)
         */
        readonly attribute: any
        /** The reflection FieldInfo for the member this property represents. (Read Only)
         */
        readonly fieldInfo: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ModeService extends Object {
        static ChangeModeById(modeId: string): void
        static Update(): void
        static HasContextMenu(menuId: string): boolean
        static PopupContextMenu(menuId: string): void
        static readonly modeNames: Array<string>
        static readonly modeCount: number
        static readonly currentId: string
        static readonly currentIndex: number
        static modeChanged(op: "add" | "remove", fn: (obj: ModeService.ModeChangedArgs) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    namespace ModeService {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class ModeChangedArgs extends ValueType {
            constructor()
            prevIndex: number
            nextIndex: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    namespace SceneView {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class CameraMode extends ValueType {
            constructor()
            Equals(otherObject: Object): boolean
            GetHashCode(): number
            toString(): string
            static op_Equality(a: SceneView.CameraMode, z: SceneView.CameraMode): boolean
            static op_Inequality(a: SceneView.CameraMode, z: SceneView.CameraMode): boolean
            // js_op_overloading: static ==(a: SceneView.CameraMode, z: SceneView.CameraMode): boolean
            drawMode: DrawCameraMode
            name: string
            section: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace SceneView {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class SceneViewState extends Object {
            constructor(other: SceneView.SceneViewState)
            constructor()
            SetAllEnabled(value: boolean): void
            alwaysRefresh: boolean
            readonly fogEnabled: boolean
            readonly alwaysRefreshEnabled: boolean
            readonly skyboxEnabled: boolean
            readonly flaresEnabled: boolean
            readonly imageEffectsEnabled: boolean
            readonly particleSystemsEnabled: boolean
            readonly visualEffectGraphsEnabled: boolean
            readonly allEnabled: boolean
            fxEnabled: boolean
            showFog: boolean
            showSkybox: boolean
            showFlares: boolean
            showImageEffects: boolean
            showParticleSystems: boolean
            showVisualEffectGraphs: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace SceneView {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class CameraSettings extends Object {
            constructor()
            speed: number
            speedNormalized: number
            speedMin: number
            speedMax: number
            easingEnabled: boolean
            easingDuration: number
            accelerationEnabled: boolean
            fieldOfView: number
            nearClip: number
            farClip: number
            dynamicClip: boolean
            occlusionCulling: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    /** Use this class to highlight elements in the editor for use in in-editor tutorials and similar.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Highlighter extends Object {
        constructor()
        static Stop(): void
        /** Highlights an element in the editor.
         * @param windowTitle The title of the window the element is inside.
         * @param text The text to identify the element with.
         * @param mode Optional mode to specify how to search for the element.
         * @returns true if the requested element was found; otherwise false. 
         */
        static Highlight(windowTitle: string, text: string, mode: HighlightSearchMode): boolean
        /** Highlights an element in the editor.
         * @param windowTitle The title of the window the element is inside.
         * @param text The text to identify the element with.
         * @param mode Optional mode to specify how to search for the element.
         * @returns true if the requested element was found; otherwise false. 
         */
        static Highlight(windowTitle: string, text: string): boolean
        /** Call this method to create an identifiable rect that the Highlighter can find.
         * @param position The position to make highlightable.
         * @param identifier The identifier text of the rect.
         */
        static HighlightIdentifier(position: Rect, identifier: string): void
        /** The text of the current active highlight.
         */
        static readonly activeText: string
        /** The rect in screenspace of the current active highlight.
         */
        static readonly activeRect: Rect
        /** Is the current active highlight visible yet?
         */
        static readonly activeVisible: boolean
        /** Is there currently an active highlight?
         */
        static readonly active: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Used to specify how to find a given element in the editor to highlight.
     */
    enum HighlightSearchMode {
        /** Highlights nothing.
         */
        None = 0,
        /** Highlights the first element found using any of the search modes.
         */
        Auto = 1,
        /** Highlights an element with a given identifier text.
         */
        Identifier = 2,
        /** Highlights an entire editor control using its label text as identifier.
         */
        PrefixLabel = 3,
        /** Highlights an element containing text using the text as identifier.
         */
        Content = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    /** The lighting data asset used by the active Scene.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightingDataAsset extends Object {
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** This class is now obsolete. Use LightingSettings.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class LightmapEditorSettings extends Object {
        /** Determines how Unity will compress baked reflection cubemap.
         */
        static reflectionCubemapCompression: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array, ValueType } from "System";
    import { Object as Object1, Vector3, Behaviour } from "UnityEngine";
    /** Allows to control the lightmapping job.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Lightmapping extends Object {
        static ClearDiskCache(): void
        static BakeAsync(): boolean
        static Bake(): boolean
        static Cancel(): void
        static ForceStop(): void
        static Clear(): void
        static ClearLightingDataAsset(): void
        /** Calculates tetrahderons from positions using Delaunay Tetrahedralization.
         * @param positions An array of Light Probe positions.
         * @param outIndices An array that Unity populates with updated Light Probe indices.
         * @param outPositions An array that Unity populates with updated Light Probe positions.
         */
        static Tetrahedralize(positions: Array<Vector3>, outIndices: jsb.Out<Array<number>>, outPositions: jsb.Out<Array<Vector3>>): void
        /** Starts a synchronous bake job for the probe.
         * @param probe Target probe.
         * @param path The location where cubemap will be saved.
         * @returns Returns true if baking was succesful. 
         */
        static BakeReflectionProbe(probe: any, path: string): boolean
        /** Get how many chunks the terrain is divided into for GI baking.
         * @param terrain The terrain.
         * @param numChunksX Number of chunks in terrain width.
         * @param numChunksY Number of chunks in terrain length.
         */
        static GetTerrainGIChunks(terrain: any, numChunksX: jsb.Ref<number>, numChunksY: jsb.Ref<number>): void
        /** Fetches the Lighting Settings for the current Scene. Will return false if it is null.
         * @param settings See Lightmapping.lightingSettings.
         * @returns Returns true if there is an object, and false if it isn't. 
         */
        static TryGetLightingSettings(settings: jsb.Out<any>): boolean
        /** Applies the settings specified in the LightingSettings object to the SceneManagement.Scene object.
         * @param scene The SceneManagement.Scene object. If the Scene.isLoaded property is false, the method does not apply the settings.
         * @param lightingSettings The LightingSettings object.
         */
        static SetLightingSettingsForScene(scene: any, lightingSettings: any): void
        /** Applies the settings specified in the LightingSettings object to an array of SceneManagement.Scene objects.
         * @param scenes The array of SceneManagement.Scene objects. If the Scene.isLoaded property is false on a Scene object, the method does not apply the settings to that object.
         * @param lightingSettings The LightingSettings object.
         */
        static SetLightingSettingsForScenes(scenes: Array<any>, lightingSettings: any): void
        /** Gets the LightingSettings object of a SceneManagement.Scene object.
         * @param scene The SceneManagement.Scene object.
         * @returns The LightingSettings object if Scene.isLoaded is true. Otherwise returns null. 
         */
        static GetLightingSettingsForScene(scene: any): any
        /** Bakes an array of Scenes.
         * @param paths The path of the Scenes that should be baked.
         */
        static BakeMultipleScenes(paths: Array<string>): void
        /** This property is now obsolete. Use LightingSettings.autoGenerate.
         */
        static giWorkflowMode: Lightmapping.GIWorkflowMode
        /** This property is now obsolete. Use LightingSettings.realtimeGI.
         */
        static realtimeGI: boolean
        /** This property is now obsolete. Use LightingSettings.bakedGI.
         */
        static bakedGI: boolean
        /** Returns true when the bake job is running, false otherwise (Read Only).
         */
        static readonly isRunning: boolean
        /** Returns the current lightmapping build progress or 0 if Lightmapping.isRunning is false.
         */
        static readonly buildProgress: number
        /** The lighting data asset used by the active Scene.
         */
        static lightingDataAsset: LightingDataAsset
        /** The LightingSettings that will be used for the current Scene. Will throw an exception if it is null.
         */
        static lightingSettings: any
        /** Default LightingSettings that Unity uses for Scenes where lightingSettings is not assigned. (Read only)
         */
        static readonly lightingSettingsDefaults: any
        static bakeStarted(op: "add" | "remove", fn: () => void): void
        static lightingDataUpdated(op: "add" | "remove", fn: () => void): void
        static lightingDataCleared(op: "add" | "remove", fn: () => void): void
        static lightingDataAssetCleared(op: "add" | "remove", fn: () => void): void
        static bakeCompleted(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace Lightmapping {
        enum GIWorkflowMode {
            Iterative = 0,
            OnDemand = 1,
            Legacy = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    /** Configures how Unity bakes lighting and can be assigned to a LightingSettings instance or asset.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightmapParameters extends Object {
        constructor()
        /** Assignes itself to a LightingSettings instance or asset.
         */
        AssignToLightingSettings(lightingSettings: any): void
        /** Returns the assigned LightmapParameters for the specified LightingSettings.
         */
        static GetLightmapParametersForLightingSettings(lightingSettings: any): LightmapParameters
        /** Sets the LightmapParameters for the specified LightingSettings.
         */
        static SetLightmapParametersForLightingSettings(parameters: LightmapParameters, lightingSettings: any): void
        /** The texel resolution per meter used for real-time lightmaps. This value is multiplied by LightingSettings.indirectResolution.
         */
        resolution: number
        /** Controls the resolution at which Enlighten Realtime Global Illumination stores and can transfer input light.
         */
        clusterResolution: number
        /** The amount of data used for Enlighten Realtime Global Illumination texels. Specifies how detailed view of the Scene a texel has. Small values mean more averaged out lighting.
         */
        irradianceBudget: number
        /** The number of rays to cast for computing irradiance form factors.
         */
        irradianceQuality: number
        /** Maximum size of gaps that can be ignored for GI (multiplier on pixel size).
         */
        modellingTolerance: number
        /** Whether pairs of edges should be stitched together.
         */
        stitchEdges: boolean
        /** If enabled, the object appears transparent during GlobalIllumination lighting calculations.
         */
        isTransparent: boolean
        /** System tag is an integer identifier. It lets you force an object into a different Enlighten Realtime Global Illumination system even though all the other parameters are the same.
         */
        systemTag: number
        /** The radius (in texels) of the post-processing filter that blurs baked direct lighting.
         */
        blurRadius: number
        /** The maximum number of times to supersample a texel to reduce aliasing.
         */
        antiAliasingSamples: number
        /** The number of rays used for lights with an area. Allows for accurate soft shadowing.
         */
        directLightQuality: number
        /** The distance to offset the ray origin from the geometry when performing ray tracing, in modelling units. Unity applies the offset to all baked lighting: direct lighting, indirect lighting, environment lighting and ambient occlusion.
         */
        pushoff: number
        /** BakedLightmapTag is an integer that affects the assignment to baked lightmaps. Objects with different values for bakedLightmapTag are guaranteed to not be assigned to the same lightmap even if the other baking parameters are the same.
         */
        bakedLightmapTag: number
        /** If enabled, objects sharing the same lightmap parameters will be packed into LightmapParameters.maxLightmapCount lightmaps.
         */
        limitLightmapCount: boolean
        /** The maximum number of lightmaps created for objects sharing the same lightmap parameters. This property is ignored if LightmapParameters.limitLightmapCount is false.
         */
        maxLightmapCount: number
        /** The number of rays to cast for computing ambient occlusion.
         */
        AOQuality: number
        /** The maximum number of times to supersample a texel to reduce aliasing in AO.
         */
        AOAntiAliasingSamples: number
        /** The percentage of rays shot from a ray origin that must hit front faces to be considered usable.
         */
        backFaceTolerance: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType, Array } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    /** The Progress utility class reports the progress of asynchronous tasks to Unity.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Progress extends Object {
        static Start(name: string, description: string, options: Progress.Options, parentId: number): number
        static Finish(id: number, status: Progress.Status): void
        /** Finishes and removes an active progress indicator.
         * @param id The progress indicator's unique ID.
         * @param forceSynchronous When you set this parameter to true it forces this method to remove the progress indicator synchronously.
         * @returns -1 if the progress indicator is removed. Otherwise, returns the progress indicator's ID. 
         */
        static Remove(id: number, forceSynchronous: boolean): number
        /** Finishes and removes an active progress indicator.
         * @param id The progress indicator's unique ID.
         * @param forceSynchronous When you set this parameter to true it forces this method to remove the progress indicator synchronously.
         * @returns -1 if the progress indicator is removed. Otherwise, returns the progress indicator's ID. 
         */
        static Remove(id: number): number
        /** Reports a running progress indicator's current status.
         * @param id The progress indicator's unique ID.
         * @param progress A new progress value between 0 and 1.
         * @param description An updated description of the progress indicator. If the the progress status has not changed, or you do not set a description, this is null. To clear the current progress description, pass an empty string such as "".
         * @param currentStep An updated current step.
         * @param totalSteps An updated total number of steps, from start to finish.
         */
        static Report(id: number, currentStep: number, totalSteps: number, description: string): void
        /** Reports a running progress indicator's current status.
         * @param id The progress indicator's unique ID.
         * @param progress A new progress value between 0 and 1.
         * @param description An updated description of the progress indicator. If the the progress status has not changed, or you do not set a description, this is null. To clear the current progress description, pass an empty string such as "".
         * @param currentStep An updated current step.
         * @param totalSteps An updated total number of steps, from start to finish.
         */
        static Report(id: number, currentStep: number, totalSteps: number): void
        /** Reports a running progress indicator's current status.
         * @param id The progress indicator's unique ID.
         * @param progress A new progress value between 0 and 1.
         * @param description An updated description of the progress indicator. If the the progress status has not changed, or you do not set a description, this is null. To clear the current progress description, pass an empty string such as "".
         * @param currentStep An updated current step.
         * @param totalSteps An updated total number of steps, from start to finish.
         */
        static Report(id: number, progress: number, description: string): void
        /** Reports a running progress indicator's current status.
         * @param id The progress indicator's unique ID.
         * @param progress A new progress value between 0 and 1.
         * @param description An updated description of the progress indicator. If the the progress status has not changed, or you do not set a description, this is null. To clear the current progress description, pass an empty string such as "".
         * @param currentStep An updated current step.
         * @param totalSteps An updated total number of steps, from start to finish.
         */
        static Report(id: number, progress: number): void
        /** Cancels a runnning progress indicator, and invokes the cancel callback for the associated task.
         * @param id The progress indicator's unique ID.
         * @returns True if the associated task is cancelled, false if it cannot be cancelled. 
         */
        static Cancel(id: number): boolean
        static RegisterCancelCallback(id: number, callback: () => boolean): void
        /** Unregisters a previously registered progress cancellation callback.
         * @param id The progress indicator's unique ID.
         */
        static UnregisterCancelCallback(id: number): void
        /** Pauses a runnning progress indicator, and invokes the pause callback for its task.
         * @param id The progress indicator's unique ID.
         * @returns True if the task is paused, false if it cannot be paused. 
         */
        static Pause(id: number): boolean
        /** Resumes a paused progress indicator, and invokes the pause callback for the associated task.
         * @param id The progress indicator's unique ID.
         * @returns True if the task resumes, false if it cannot resume. 
         */
        static Resume(id: number): boolean
        static RegisterPauseCallback(id: number, callback: (arg: boolean) => boolean): void
        /** Unregisters a previously registered progress pause callback.
         * @param id The progress indicator's unique ID.
         */
        static UnregisterPauseCallback(id: number): void
        static GetCount(): number
        static GetCountPerStatus(): Array<number>
        /** Gets a progress indicator's progress.
         * @param id The progress indicator's unique ID.
         * @returns The current progress. 
         */
        static GetProgress(id: number): number
        /** Gets the current step for a progress indicator.
         * @param id The progress indicator's unique ID.
         * @returns The current step. 
         */
        static GetCurrentStep(id: number): number
        /** Gets the total number of steps, from start to finish, for a progress indicator.
         * @param id The progress indicator's unique ID.
         * @returns The number of steps. 
         */
        static GetTotalSteps(id: number): number
        /** Gets a progress indicator's name.
         * @param id The progress indicator's unique ID.
         * @returns The matching progress indicator's name. 
         */
        static GetName(id: number): string
        /** Gets a progress indicator's description.
         * @param id The progress indicator's unique ID.
         * @returns The description, if one exists. 
         */
        static GetDescription(id: number): string
        /** Sets the progress indicator's description. To clear the description pass null.
         * @param id The progress indicator's unique ID.
         * @param description The progress indicator's new description.
         */
        static SetDescription(id: number, description: string): void
        /** Gets the timestamp of when the progress indicator started.
         * @param id The progress indicator's unique ID.
         * @returns The progress indicator's start timestamp. 
         */
        static GetStartDateTime(id: number): number
        /** Gets the time that the progress indicator last changed, or finished.
         * @param id The progress indicator's unique ID.
         * @returns The timestamp of the progress indicator's last update. 
         */
        static GetUpdateDateTime(id: number): number
        /** Gets the unique ID of the progress indicator's parent, if any.
         * @param id The progress indicator's unique ID.
         * @returns The unique ID of the progress indicator's parent. If the progress indicator is not a child of any other progress indicators, returns -1. 
         */
        static GetParentId(id: number): number
        /** Finds a progress indicator's unique ID using its index in the set of all available progress indicators.
         * @param index The valid index for a progress indicator.
         * @returns The progress indicator's unique ID, or -1 if the unique ID is not available. 
         */
        static GetId(index: number): number
        /** Indicates whether you can cancel the progress indicator's associated task.
         * @param id The progress indicator's unique ID.
         * @returns True if you can cancel the task, false otherwise. 
         */
        static IsCancellable(id: number): boolean
        /** Indicates whether you can pause the progress indicator's task.
         * @param id The progress indicator's unique ID.
         * @returns True if you can pause the task, false otherwise. 
         */
        static IsPausable(id: number): boolean
        /** Gets the progress indicator's status.
         * @param id The progress indicator's unique ID.
         * @returns The progress indicator's current status. 
         */
        static GetStatus(id: number): Progress.Status
        /** Gets the options that you specified when you started the progress indicator.
         * @param id The progress indicator's unique ID.
         * @returns The progress indicator's option flags. 
         */
        static GetOptions(id: number): Progress.Options
        static SetTimeDisplayMode(id: number, displayMode: Progress.TimeDisplayMode): void
        /** Sets the progress indicator's remaining time, in seconds.
         * @param id The progress indicator's unique ID.
         * @param seconds The progress indicator's remaining time, in seconds.
         */
        static SetRemainingTime(id: number, seconds: number): void
        /** Sets a progress indicator's priority.
         * @param id The progress indicator's unique ID.
         * @param priority The priority.
         */
        static SetPriority(id: number, priority: number): void
        static SetPriority(id: number, priority: Progress.Priority): void
        /** Get a progress indicator's time display mode.
         * @param id The progress indicator's unique ID.
         * @returns The progress indicator's time display mode. 
         */
        static GetTimeDisplayMode(id: number): Progress.TimeDisplayMode
        /** Checks whether a progress indicator with the specified ID exists.
         * @param id The unique ID to search for.
         * @returns True if the progress indicator exists, false otherwise. 
         */
        static Exists(id: number): boolean
        /** Gets a progress indicator's remaining time, in seconds.
         * @param id The progress indicator's unique ID.
         * @returns The number of seconds remaining. 
         */
        static GetRemainingTime(id: number): number
        /** Gets a progress indicator's priority.
         * @param id The progress indicator's unique ID.
         * @returns The priority. 
         */
        static GetPriority(id: number): number
        /** Resets the computation of a progress indicator's remaining time.
         * @param id The progress indicator's unique ID.
         */
        static ClearRemainingTime(id: number): void
        /** Sets the label that displays a progress indicator's steps.
         * @param id The progress indicator's unique ID.
         * @param label The steps label.
         */
        static SetStepLabel(id: number, label: string): void
        /** Gets the label that displays a progress indicator's steps.
         * @param id The progress indicator's unique ID.
         * @returns The step label. 
         */
        static GetStepLabel(id: number): string
        /** Opens the progress window for background tasks.
         * @param shouldReposition To place the window in the bottom right corner of the main Editor window, pass True. To restore the last window position, pass False.
         */
        static ShowDetails(shouldReposition: boolean): void
        static EnumerateItems(): any
        /** Gets information about a progress indicator.
         * @param id The progress indicator's unique ID.
         * @returns The progress indicator's data structure. 
         */
        static GetProgressById(id: number): Progress.Item
        static GetRunningProgressCount(): number
        /** Returns true if there is at least one running progress indicator, false otherwise.
         */
        static readonly running: boolean
        /** Returns the global average progression of all running tasks.
         */
        static readonly globalProgress: number
        /** Returns the maximum time remaining for all running progress indicators.
         */
        static readonly globalRemainingTime: any
        static added(op: "add" | "remove", fn: (obj: Array<Progress.Item>) => void): void
        static updated(op: "add" | "remove", fn: (obj: Array<Progress.Item>) => void): void
        static removed(op: "add" | "remove", fn: (obj: Array<Progress.Item>) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, DateTime, ValueType } from "System";
    namespace Progress {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Item extends Object {
            Report(newCurrentStep: number, newTotalSteps: number, newDescription: string): void
            Report(newCurrentStep: number, newTotalSteps: number): void
            Report(newProgress: number, newDescription: string): void
            Report(newProgress: number): void
            Cancel(): boolean
            Pause(): boolean
            Resume(): boolean
            Finish(finishedStatus: Progress.Status): void
            Remove(): number
            RegisterCancelCallback(callback: () => boolean): void
            UnregisterCancelCallback(): void
            RegisterPauseCallback(callback: (arg: boolean) => boolean): void
            UnregisterPauseCallback(): void
            SetDescription(newDescription: string): void
            SetTimeDisplayMode(mode: Progress.TimeDisplayMode): void
            SetRemainingTime(seconds: number): void
            SetPriority(priority: number): void
            SetPriority(priority: Progress.Priority): void
            ClearRemainingTime(): void
            SetStepLabel(label: string): void
            protected constructor()
            readonly name: string
            readonly description: string
            readonly id: number
            readonly progress: number
            readonly currentStep: number
            readonly totalSteps: number
            readonly stepLabel: string
            readonly parentId: number
            readonly startTime: DateTime
            readonly updateTime: DateTime
            readonly status: Progress.Status
            readonly options: Progress.Options
            readonly timeDisplayMode: Progress.TimeDisplayMode
            readonly priority: number
            readonly remainingTime: any
            readonly finished: boolean
            readonly running: boolean
            readonly paused: boolean
            readonly responding: boolean
            readonly cancellable: boolean
            readonly pausable: boolean
            readonly indefinite: boolean
            readonly elapsedTime: number
            readonly exists: boolean
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace Progress {
        enum Status {
            Running = 0,
            Succeeded = 1,
            Failed = 2,
            Canceled = 3,
            Paused = 4,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace Progress {
        enum Options {
            None = 0,
            Sticky = 1,
            Indefinite = 2,
            Synchronous = 4,
            Managed = 8,
            Unmanaged = 16,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace Progress {
        enum TimeDisplayMode {
            NoTimeShown = 0,
            ShowRunningTime = 1,
            ShowRemainingTime = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace Progress {
        enum Priority {
            Unresponsive = 0,
            Idle = 1,
            Low = 2,
            Normal = 6,
            High = 10,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Defines Cubemap convolution mode.
     */
    enum TextureImporterCubemapConvolution {
        /** No convolution needed. This Cubemap texture represents mirror reflection or Skybox.
         */
        None = 0,
        /** Specular convolution (aka Prefiltered Environment Map).
         */
        Specular = 1,
        /** Diffuse convolution (aka irradiance Cubemap).
         */
        Diffuse = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** RGBM encoding mode for HDR textures in TextureImporter.
     */
    enum TextureImporterRGBMMode {
        /** Do RGBM encoding when source data is HDR in TextureImporter.
         */
        Auto = 0,
        /** Do RGBM encoding in TextureImporter.
         */
        On = 1,
        /** Do not perform RGBM encoding in TextureImporter.
         */
        Off = 2,
        /** Source texture is already RGBM encoded in TextureImporter.
         */
        Encoded = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Camera, Color, Behaviour, Rect, GUIStyle, Texture, Texture2D, GameObject, Object as Object1, Vector3, Quaternion, Material, Transform, Matrix4x4 } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PreviewRenderUtility extends Object {
        constructor(renderFullScene: boolean, pixelPerfect: boolean)
        constructor(renderFullScene: boolean)
        constructor()
        Cleanup(): void
        BeginPreview(r: Rect, previewBackground: GUIStyle): void
        BeginStaticPreview(r: Rect): void
        GetScaleFactor(width: number, height: number): number
        EndPreview(): Texture
        EndAndDrawPreview(r: Rect): void
        EndStaticPreview(): Texture2D
        AddSingleGO(go: GameObject): void
        InstantiatePrefabInScene(prefab: GameObject): GameObject
        DrawMesh(mesh: any, pos: Vector3, scale: Vector3, rot: Quaternion, mat: Material, subMeshIndex: number, customProperties: any, probeAnchor: Transform, useLightProbe: boolean): void
        DrawMesh(mesh: any, pos: Vector3, rot: Quaternion, mat: Material, subMeshIndex: number, customProperties: any, probeAnchor: Transform, useLightProbe: boolean): void
        DrawMesh(mesh: any, m: Matrix4x4, mat: Material, subMeshIndex: number, customProperties: any, probeAnchor: Transform, useLightProbe: boolean): void
        DrawMesh(mesh: any, pos: Vector3, rot: Quaternion, mat: Material, subMeshIndex: number, customProperties: any, probeAnchor: Transform): void
        DrawMesh(mesh: any, pos: Vector3, rot: Quaternion, mat: Material, subMeshIndex: number, customProperties: any): void
        DrawMesh(mesh: any, matrix: Matrix4x4, mat: Material, subMeshIndex: number, customProperties: any): void
        DrawMesh(mesh: any, pos: Vector3, rot: Quaternion, mat: Material, subMeshIndex: number): void
        DrawMesh(mesh: any, matrix: Matrix4x4, mat: Material, subMeshIndex: number): void
        Render(allowScriptableRenderPipeline: boolean, updatefov: boolean): void
        readonly camera: Camera
        cameraFieldOfView: number
        ambientColor: Color
        readonly lights: Array<any>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    import { Vector2, Camera } from "UnityEngine";
    namespace CameraEditor {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Settings extends Object {
            constructor(so: SerializedObject)
            OnEnable(): void
            Update(): void
            ApplyModifiedProperties(): void
            DrawClearFlags(): void
            DrawBackgroundColor(): void
            DrawCullingMask(): void
            DrawProjection(): void
            DrawClippingPlanes(): void
            DrawNormalizedViewPort(): void
            DrawDepth(): void
            DrawRenderingPath(): void
            DrawTargetTexture(deferred: boolean): void
            DrawOcclusionCulling(): void
            DrawHDR(): void
            DrawMSAA(): void
            DrawDynamicResolution(): void
            DrawVR(): void
            DrawMultiDisplay(): void
            DrawTargetEye(): void
            static DrawCameraWarnings(camera: Camera): void
            static readonly ApertureFormatNames: IEnumerable<string>
            static readonly ApertureFormatValues: any
            readonly clearFlags: SerializedProperty
            readonly backgroundColor: SerializedProperty
            readonly normalizedViewPortRect: SerializedProperty
            readonly sensorSize: SerializedProperty
            readonly lensShift: SerializedProperty
            readonly focalLength: SerializedProperty
            readonly gateFit: SerializedProperty
            readonly verticalFOV: SerializedProperty
            readonly orthographic: SerializedProperty
            readonly orthographicSize: SerializedProperty
            readonly depth: SerializedProperty
            readonly cullingMask: SerializedProperty
            readonly renderingPath: SerializedProperty
            readonly occlusionCulling: SerializedProperty
            readonly targetTexture: SerializedProperty
            readonly HDR: SerializedProperty
            readonly allowMSAA: SerializedProperty
            readonly allowDynamicResolution: SerializedProperty
            readonly stereoConvergence: SerializedProperty
            readonly stereoSeparation: SerializedProperty
            readonly nearClippingPlane: SerializedProperty
            readonly farClippingPlane: SerializedProperty
            readonly fovAxisMode: SerializedProperty
            readonly targetDisplay: SerializedProperty
            readonly targetEye: SerializedProperty
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect, GUIStyle, Material, Object as Object1 } from "UnityEngine";
    /** Abstract class to derive from for defining custom GUI for shader properties and for extending the material preview.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ShaderGUI extends Object {
        /** To define a custom shader GUI use the methods of materialEditor to render controls for the properties array.
         * @param materialEditor The MaterialEditor that are calling this OnGUI (the 'owner').
         * @param properties Material properties of the current selected shader.
         */
        OnGUI(materialEditor: any, properties: Array<MaterialProperty>): void
        /** Override for extending the rendering of the Preview area or completly replace the preview (by not calling base.OnMaterialPreviewGUI).
         * @param materialEditor The MaterialEditor that are calling this method (the 'owner').
         * @param r Preview rect.
         * @param background Style for the background.
         */
        OnMaterialPreviewGUI(materialEditor: any, r: Rect, background: GUIStyle): void
        OnMaterialInteractivePreviewGUI(materialEditor: any, r: Rect, background: GUIStyle): void
        /** Override for extending the functionality of the toolbar of the preview area or completly replace the toolbar by not calling base.OnMaterialPreviewSettingsGUI.
         * @param materialEditor The MaterialEditor that are calling this method (the 'owner').
         */
        OnMaterialPreviewSettingsGUI(materialEditor: any): void
        /** This method is called when the ShaderGUI is being closed.
         */
        OnClosed(material: Material): void
        /** This method is called when a new shader has been selected for a Material.
         * @param material The material the newShader should be assigned to.
         * @param oldShader Previous shader.
         * @param newShader New shader to assign to the material.
         */
        AssignNewShaderToMaterial(material: Material, oldShader: any, newShader: any): void
        /** When the user loads a Material using this ShaderGUI into memory or changes a value in the Inspector, the Editor calls this method.
         * @param material The material to validate.
         */
        ValidateMaterial(material: Material): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, GUIContent, Rect, GUIStyle } from "UnityEngine";
    /** Base Class to derive from when creating Custom Previews.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ObjectPreview extends Object {
        constructor()
        Cleanup(): void
        /** Called when the Preview gets created with the objects being previewed.
         * @param targets The objects being previewed.
         */
        Initialize(targets: Array<Object1>): void
        MoveNextTarget(): boolean
        ResetTarget(): void
        HasPreviewGUI(): boolean
        GetPreviewTitle(): GUIContent
        /** Implement to create your own custom preview for the preview area of the inspector, primary editor headers and the object selector.
         * @param r Rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnPreviewGUI(r: Rect, background: GUIStyle): void
        /** Implement to create your own interactive custom preview. Interactive custom previews are used in the preview area of the inspector and the object selector.
         * @param r Rectangle in which to draw the preview.
         * @param background Background image.
         */
        OnInteractivePreviewGUI(r: Rect, background: GUIStyle): void
        OnPreviewSettings(): void
        GetInfoString(): string
        /** This is the first entry point for Preview Drawing.
         * @param previewArea The available area to draw the preview.
         */
        DrawPreview(previewArea: Rect): void
        ReloadPreviewInstances(): void
        /** The object currently being previewed.
         */
        readonly target: Object1
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Tells an Editor class which run-time type it's an editor for when the given RenderPipeline is activated.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CustomEditorForRenderPipelineAttribute extends Object {
        constructor(inspectedType: any, renderPipeline: any, editorForChildClasses: boolean)
        constructor(inspectedType: any, renderPipeline: any)
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect, GUIContent } from "UnityEngine";
    /** Base class to derive custom material property drawers from.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class MaterialPropertyDrawer extends Object {
        OnGUI(position: Rect, prop: MaterialProperty, label: GUIContent, editor: any): void
        /** Override this method to make your own GUI for the property.
         * @param position Rectangle on the screen to use for the property GUI.
         * @param prop The MaterialProperty to make the custom GUI for.
         * @param label The label of this property.
         * @param editor Current material editor.
         */
        OnGUI(position: Rect, prop: MaterialProperty, label: string, editor: any): void
        /** Override this method to specify how tall the GUI for this property is in pixels.
         * @param prop The MaterialProperty to make the custom GUI for.
         * @param label The label of this property.
         * @param editor Current material editor.
         */
        GetPropertyHeight(prop: MaterialProperty, label: string, editor: any): number
        /** Apply extra initial values to the material.
         * @param prop The MaterialProperty to apply values for.
         */
        Apply(prop: MaterialProperty): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1, Texture2D, Rect, GUIStyle } from "UnityEngine";
    /** Use this class to render an interactive preview of a mesh.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MeshPreview extends Object {
        constructor(target: any)
        Dispose(): void
        /** Creates a texture preview to override Editor.RenderStaticPreview. The current mesh will be drawn.
         * @param width The width to render the texture.
         * @param height The height to render the texture.
         * @returns Returns a rendered texture of the current mesh with default settings. 
         */
        RenderStaticPreview(width: number, height: number): Texture2D
        /** Call this from an Editor.OnPreviewGUI or ObjectPreview.OnPreviewGUI to draw a mesh preview.
         * @param rect Rectangle in which to draw the preview.
         * @param background The background style.
         */
        OnPreviewGUI(rect: Rect, background: GUIStyle): void
        OnPreviewSettings(): void
        /** Returns a short summary of the Mesh attributes (ex, does this mesh contain positions, normals, tangents, etc...).
         * @param mesh The Mesh to build a summary phrase for.
         * @returns A short summary of the mesh attributes. 
         */
        static GetInfoString(mesh: any): string
        /** The Mesh to display in the preview space.
         */
        mesh: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The class used to render the Light Editor when a Light is selected in the Unity Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightEditor extends Editor {
        constructor()
        OnInspectorGUI(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Behaviour, Texture } from "UnityEngine";
    namespace LightEditor {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Settings extends Object {
            constructor(so: SerializedObject)
            OnEnable(): void
            OnDestroy(): void
            Update(): void
            DrawLightType(): void
            DrawRange(): void
            DrawSpotAngle(): void
            DrawInnerAndOuterSpotAngle(): void
            DrawArea(): void
            DrawColor(): void
            DrawLightmapping(): void
            DrawIntensity(): void
            DrawBounceIntensity(): void
            DrawCookie(): void
            DrawCookieSize(): void
            DrawHalo(): void
            DrawFlare(): void
            DrawRenderMode(): void
            DrawCullingMask(): void
            DrawRenderingLayerMask(): void
            ApplyModifiedProperties(): void
            DrawShadowsType(): void
            DrawBakedShadowRadius(): void
            DrawBakedShadowAngle(): void
            DrawRuntimeShadow(): void
            readonly lightType: SerializedProperty
            readonly lightShape: SerializedProperty
            readonly range: SerializedProperty
            readonly spotAngle: SerializedProperty
            readonly innerSpotAngle: SerializedProperty
            readonly cookieSize: SerializedProperty
            readonly color: SerializedProperty
            readonly intensity: SerializedProperty
            readonly bounceIntensity: SerializedProperty
            readonly colorTemperature: SerializedProperty
            readonly useColorTemperature: SerializedProperty
            readonly cookieProp: SerializedProperty
            readonly shadowsType: SerializedProperty
            readonly shadowsStrength: SerializedProperty
            readonly shadowsResolution: SerializedProperty
            readonly shadowsBias: SerializedProperty
            readonly shadowsNormalBias: SerializedProperty
            readonly shadowsNearPlane: SerializedProperty
            readonly halo: SerializedProperty
            readonly flare: SerializedProperty
            readonly renderMode: SerializedProperty
            readonly cullingMask: SerializedProperty
            readonly renderingLayerMask: SerializedProperty
            readonly lightmapping: SerializedProperty
            readonly areaSizeX: SerializedProperty
            readonly areaSizeY: SerializedProperty
            readonly bakedShadowRadiusProp: SerializedProperty
            readonly bakedShadowAngleProp: SerializedProperty
            readonly isRealtime: boolean
            readonly isMixed: boolean
            readonly isCompletelyBaked: boolean
            readonly isBakedOrMixed: boolean
            readonly isAreaLightType: boolean
            readonly light: any
            readonly cookie: Texture
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { GameObject } from "UnityEngine";
    namespace PrefabUtility {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class EditPrefabContentsScope extends ValueType {
            constructor(assetPath: string)
            Dispose(): void
            readonly assetPath: string
            readonly prefabContentsRoot: GameObject
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Defines a single modified property.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PropertyModification extends Object {
        constructor()
        /** Object that will be modified.
         */
        target: Object1
        /** Property path of the property being modified (Matches as SerializedProperty.propertyPath).
         */
        propertyPath: string
        /** The value being applied.
         */
        value: string
        /** The value being applied when it is an object reference (which can not be represented as a string).
         */
        objectReference: Object1
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum used to determine how a Prefab should be unpacked.
     */
    enum PrefabUnpackMode {
        /** Use this mode to only unpack the outermost layer of a Prefab.
         */
        OutermostRoot = 0,
        /** Use this to strip away all Prefab information from a Prefab instance.
         */
        Completely = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum SaveType {
        Binary = 0,
        Text = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SearchableEditorWindow extends EditorWindow {
        constructor()
        OnEnable(): void
        OnDisable(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace SearchableEditorWindow {
        enum SearchMode {
            All = 0,
            Name = 1,
            Type = 2,
            Label = 3,
            AssetBundleName = 4,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace SearchableEditorWindow {
        enum SearchModeHierarchyWindow {
            All = 0,
            Name = 1,
            Type = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, Texture2D } from "UnityEngine";
    import { EndNameEditAction } from "UnityEditor.ProjectWindowCallback";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ProjectWindowUtil extends Object {
        constructor()
        static CreateNewGUISkin(): void
        static CreateAsset(asset: Object1, pathName: string): void
        static CreateFolder(): void
        static CreateScene(): void
        static CreateAssetWithContent(filename: string, content: string, icon: Texture2D): void
        static CreateScriptAssetFromTemplateFile(templatePath: string, defaultNewFileName: string): void
        static ShowCreatedAsset(o: Object1): void
        static StartNameEditingIfProjectWindowExists(instanceID: number, endAction: EndNameEditAction, pathName: string, icon: Texture2D, resourceFile: string): void
        static GetAncestors(instanceID: number): Array<number>
        static IsFolder(instanceID: number): boolean
        static GetContainingFolder(path: string): string
        static GetBaseFolders(folders: Array<string>): Array<string>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Camera, Vector2, Vector3 } from "UnityEngine";
    /** Project points from world to screen space.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CameraProjectionCache extends ValueType {
        constructor(camera: Camera)
        /** Transforms position from world space into screen space using the cached camera projection and viewport.
         * @param worldPoint A point in world space.
         * @returns The converted point in screen space. 
         */
        WorldToScreenPoint(worldPoint: Vector3): Vector2
        /** Converts a world space point to a 2D GUI position.
         * @param worldPoint A point in world space.
         * @returns A point in GUI space. 
         */
        WorldToGUIPoint(worldPoint: Vector3): Vector2
        /** Converts a point from GUI position to screen space relative to the cached camera viewport.
         * @param guiPoint A point in GUI space to convert to screen space.
         * @returns guiPoint in screen space relative to the cached camera viewport. 
         */
        GUIToScreenPoint(guiPoint: Vector2): Vector2
        /** Converts a point from screen space to GUI position relative to the viewport at the time the CameraProjectionCache was created.
         * @param screenPoint A point in screen space.
         * @returns screenPoint converted to GUI space relative to the cached camera viewport. 
         */
        ScreenToGUIPoint(screenPoint: Vector2): Vector2
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** An attribute to mark an extension class for the Lighting Explorer. Supports one extension per render pipeline.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightingExplorerExtensionAttribute extends Object {
        constructor(renderPipeline: any)
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ILightingExplorerExtension {
        GetContentTabs(): Array<LightingExplorerTab>
        OnEnable(): void
        OnDisable(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Create custom tabs for the Lighting Explorer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightingExplorerTab extends Object {
        constructor(title: string, objects: () => Array<Object1>, columns: () => Array<LightingExplorerTableColumn>, showFilterGUI: boolean)
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { GUIContent, Rect } from "UnityEngine";
    /** This is used when defining how a column should look and behave in the Lighting Explorer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LightingExplorerTableColumn extends Object {
        constructor(type: LightingExplorerTableColumn.DataType, headerContent: GUIContent, propertyName: string, width: number, onGUIDelegate: (r: Rect, prop: SerializedProperty, dependencies: Array<SerializedProperty>) => void, compareDelegate: (lhs: SerializedProperty, rhs: SerializedProperty) => number, copyDelegate: (target: SerializedProperty, source: SerializedProperty) => void, dependencyIndices: Array<number>)
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace LightingExplorerTableColumn {
        enum DataType {
            Name = 0,
            Checkbox = 1,
            Enum = 2,
            Int = 3,
            Float = 4,
            Color = 5,
            Custom = 20,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Object as Object1, GameObject } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class SceneModeUtility extends Object {
        static SearchForType(type: any): void
        static SearchBar(...types: any[]): any
        static StaticFlagField(label: string, property: SerializedProperty, flag: number): boolean
        static SetStaticFlags(targetObjects: Array<Object1>, changedFlags: number, flagValue: boolean): boolean
        static GetObjects(gameObjects: Array<Object1>, includeChildren: boolean): Array<GameObject>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    /** Default definition for the Lighting Explorer. Can be overridden completely or partially.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DefaultLightingExplorerExtension extends Object implements ILightingExplorerExtension {
        constructor()
        GetContentTabs(): Array<LightingExplorerTab>
        OnEnable(): void
        OnDisable(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Base class for the Inspector that overrides the Environment section of the Lighting window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class LightingWindowEnvironmentSection extends Object {
        OnEnable(): void
        OnDisable(): void
        OnInspectorGUI(): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Object } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ObjectReferenceKeyframe extends ValueType {
        constructor()
        time: number
        value: Object
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { AnimationCurve } from "UnityEngine";
    /** An AnimationClipCurveData object contains all the information needed to identify a specific curve in an AnimationClip. The curve animates a specific property of a component  material attached to a game object  animated bone.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationClipCurveData extends Object {
        constructor(binding: EditorCurveBinding)
        constructor()
        /** The path of the game object / bone being animated.
         */
        path: string
        /** The type of the component / material being animated.
         */
        type: any
        /** The name of the property being animated.
         */
        propertyName: string
        /** The actual animation curve.
         */
        curve: AnimationCurve
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { AnimationClip, GameObject, Animation, Object as Object1, AnimationCurve, Transform } from "UnityEngine";
    /** Editor utility functions for modifying animation clips.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationUtility extends Object {
        constructor()
        /** Retrieves an array of animation clips associated with a GameObject or component.
         */
        static GetAnimationClips(gameObject: GameObject): Array<AnimationClip>
        /** Sets the array of animation clips to be referenced in the Animation component.
         */
        static SetAnimationClips(animation: Animation, clips: Array<AnimationClip>): void
        /** Retrieves the animatable bindings for a specific GameObject.
         */
        static GetAnimatableBindings(targetObject: GameObject, root: GameObject): Array<EditorCurveBinding>
        static GetEditorCurveValueType(root: GameObject, binding: EditorCurveBinding): any
        static GetFloatValue(root: GameObject, binding: EditorCurveBinding, data: jsb.Out<number>): boolean
        static GetObjectReferenceValue(root: GameObject, binding: EditorCurveBinding, data: jsb.Out<Object1>): boolean
        /** Retrieves the animated object that the binding points to.
         */
        static GetAnimatedObject(root: GameObject, binding: EditorCurveBinding): Object1
        static PropertyModificationToEditorCurveBinding(modification: PropertyModification, gameObject: GameObject, binding: jsb.Out<EditorCurveBinding>): any
        /** Retrieves the float curve bindings in an animation clip.
         */
        static GetCurveBindings(clip: AnimationClip): Array<EditorCurveBinding>
        /** Retrieves the object reference curve bindings stored in the animation clip.
         */
        static GetObjectReferenceCurveBindings(clip: AnimationClip): Array<EditorCurveBinding>
        /** Retrieves the object reference curve that the binding points to.
         * @returns Returns an array of keyframes. 
         */
        static GetObjectReferenceCurve(clip: AnimationClip, binding: EditorCurveBinding): Array<ObjectReferenceKeyframe>
        /** Adds, modifies, or removes an object reference curve in an animation clip.
         * @param clip The animation clip to modify.
         * @param binding The bindings that define the paths and the properties of each curve.
         * @param keyframes Array of Object reference values over time. Setting this to null will remove the curve.
         */
        static SetObjectReferenceCurve(clip: AnimationClip, binding: EditorCurveBinding, keyframes: Array<ObjectReferenceKeyframe>): void
        /** Adds, modifies, or removes object references curve in an animation clip.
         * @param clip The animation clip to modify.
         * @param bindings The bindings that define the paths and the properties of each curve.
         * @param keyframes Array of Object reference arrays, one per binding.
         */
        static SetObjectReferenceCurves(clip: AnimationClip, bindings: Array<EditorCurveBinding>, keyframes: Array<Array<ObjectReferenceKeyframe>>): void
        /** Retrieves the float curve that the binding points to.
         */
        static GetEditorCurve(clip: AnimationClip, binding: EditorCurveBinding): AnimationCurve
        /** Adds, modifies, or removes an editor float curve in an animation clip.
         * @param clip The animation clip to modify.
         * @param binding The binding that defines the path and the properties of the curve.
         * @param curve The curve to add. Set to null to remove the curve.
         */
        static SetEditorCurve(clip: AnimationClip, binding: EditorCurveBinding, curve: AnimationCurve): void
        /** Adds, modifies, or removes multiple editor float curves in an animation clip.
         * @param clip The animation clip to modify.
         * @param binding The binding that defines the path and the properties of each curve.
         * @param curves The curves to add. Setting curves in the array to null will remove these curves from the clip.
         */
        static SetEditorCurves(clip: AnimationClip, bindings: Array<EditorCurveBinding>, curves: Array<AnimationCurve>): void
        /** Retrieves the left tangent mode of the keyframe at a specific index.
         * @param curve Curve to query.
         * @param index Keyframe index.
         * @returns Returns the tangent mode. 
         */
        static GetKeyLeftTangentMode(curve: AnimationCurve, index: number): AnimationUtility.TangentMode
        /** Retrieves the right tangent mode of the keyframe at a specific index.
         * @param curve Curve to query.
         * @param index Keyframe index.
         * @returns Returns the tangent mode. 
         */
        static GetKeyRightTangentMode(curve: AnimationCurve, index: number): AnimationUtility.TangentMode
        /** Retrieves the broken tangent flag for a specfic keyframe.
         * @param curve Curve to query.
         * @param index Keyframe index.
         * @returns Broken flag at specified index. 
         */
        static GetKeyBroken(curve: AnimationCurve, index: number): boolean
        static SetKeyLeftTangentMode(curve: AnimationCurve, index: number, tangentMode: AnimationUtility.TangentMode): void
        static SetKeyRightTangentMode(curve: AnimationCurve, index: number, tangentMode: AnimationUtility.TangentMode): void
        /** Change the specified keyframe broken tangent flag.
         * @param curve The curve to modify.
         * @param index Keyframe index.
         * @param broken Broken flag.
         */
        static SetKeyBroken(curve: AnimationCurve, index: number, broken: boolean): void
        /** Retrieves all animation events associated with an animation clip.
         */
        static GetAnimationEvents(clip: AnimationClip): Array<any>
        /** Replaces all animation events in the animation clip.
         */
        static SetAnimationEvents(clip: AnimationClip, events: Array<any>): void
        /** Retrieves the path from the root transform to the target transform.
         * @returns Returns a string representing the path in the transform hierarchy. 
         */
        static CalculateTransformPath(targetTransform: Transform, root: Transform): string
        static GetAnimationClipSettings(clip: AnimationClip): AnimationClipSettings
        static SetAnimationClipSettings(clip: AnimationClip, srcClipInfo: AnimationClipSettings): void
        /** Sets the additive reference pose from referenceClip at time for animation clip clip.
         * @param clip The animation clip to use.
         * @param referenceClip The animation clip containing the reference pose.
         * @param time The time that when the reference pose occurs in referenceClip.
         */
        static SetAdditiveReferencePose(clip: AnimationClip, referenceClip: AnimationClip, time: number): void
        static ConstrainToPolynomialCurve(curve: AnimationCurve): void
        static onCurveWasModified(op: "get"): (clip: AnimationClip, binding: EditorCurveBinding, type: AnimationUtility.CurveModifiedType) => void
        static onCurveWasModified(op: "add" | "remove" | "set", fn?: (clip: AnimationClip, binding: EditorCurveBinding, type: AnimationUtility.CurveModifiedType) => void): void
        static onCurveWasModified(op: "add" | "remove" | "set" | "get", fn?: (clip: AnimationClip, binding: EditorCurveBinding, type: AnimationUtility.CurveModifiedType) => void): (clip: AnimationClip, binding: EditorCurveBinding, type: AnimationUtility.CurveModifiedType) => void | void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace AnimationUtility {
        enum CurveModifiedType {
            CurveDeleted = 0,
            CurveModified = 1,
            ClipModified = 2,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace AnimationUtility {
        enum TangentMode {
            Free = 0,
            Auto = 1,
            Linear = 2,
            Constant = 3,
            ClampedAuto = 4,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    /** AnimationMode uses AnimationModeDriver to identify the animation driver.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationModeDriver extends ScriptableObject {
        constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { Color, Object as Object1, GameObject, AnimationClip } from "UnityEngine";
    /** AnimationMode is used by the AnimationWindow to store properties modified
      by the AnimationClip playback.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationMode extends Object {
        constructor()
        /** Checks whether the specified property is in Animation mode and is being animated.
         * @param target The object to determine if it contained the animation.
         * @param propertyPath The name of the animation to search for.
         * @returns Whether the property search is found or not. 
         */
        static IsPropertyAnimated(target: Object1, propertyPath: string): boolean
        /** Stops the Animation mode and reverts any properties that were animated while in Animation mode.
         * @param driver An AnimationModeDriver object must be specified if one was specified when the Animation mode was started (StartAnimationMode.)
         */
        static StopAnimationMode(driver: AnimationModeDriver): void
        static StopAnimationMode(): void
        /** Checks whether the Editor is in Animation mode.
         * @param driver An AnimationModeDriver object that tests if AnimationMode has been locked specifically for this driver.
         */
        static InAnimationMode(driver: AnimationModeDriver): boolean
        static InAnimationMode(): boolean
        /** Starts the Animation mode.
         * @param driver Specify an AnimationModeDriver object to lock the AnimationMode to a driver.
         */
        static StartAnimationMode(driver: AnimationModeDriver): void
        static StartAnimationMode(): void
        static BeginSampling(): void
        static EndSampling(): void
        /** Samples the AnimationClip for the GameObject and also records modified properties when in Animation mode.
         * @param gameObject The root GameObject for the animation.
         * @param clip The AnimationClip to sample.
         * @param time The time at which to sample.
         * @returns Returns true when the Editor is in Animation mode. Returns false otherwise. 
         */
        static SampleAnimationClip(gameObject: GameObject, clip: AnimationClip, time: number): void
        static SamplePlayableGraph(graph: any, index: number, time: number): void
        /** Marks a property as currently being animated.
         * @param binding Description of the animation clip curve being modified.
         * @param modification Object property being modified.
         * @param keepPrefabOverride Indicates whether to retain modifications when the targeted object is an instance of a Prefab.
         */
        static AddPropertyModification(binding: EditorCurveBinding, modification: PropertyModification, keepPrefabOverride: boolean): void
        /** Marks a property defined by an EditorCurveBinding as currently being animated.
         * @param gameObject The GameObject being modified.
         * @param binding The binding for the property being modified.
         */
        static AddEditorCurveBinding(gameObject: GameObject, binding: EditorCurveBinding): void
        /** The color used to show that a property is currently being animated.
         */
        static readonly animatedPropertyColor: Color
        /** The color used to show that an animated property automatically records changes in the animation clip.
         */
        static readonly recordedPropertyColor: Color
        /** The color used to show that an animated property has been modified.
         */
        static readonly candidatePropertyColor: Color
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { AnimationClip } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationClipSettings extends Object {
        constructor()
        additiveReferencePoseClip: AnimationClip
        additiveReferencePoseTime: number
        startTime: number
        stopTime: number
        orientationOffsetY: number
        level: number
        cycleOffset: number
        hasAdditiveReferencePose: boolean
        loopTime: boolean
        loopBlend: boolean
        loopBlendOrientation: boolean
        loopBlendPositionY: boolean
        loopBlendPositionXZ: boolean
        keepOriginalOrientation: boolean
        keepOriginalPositionY: boolean
        keepOriginalPositionXZ: boolean
        heightFromFeet: boolean
        mirror: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    /** Defines how a curve is attached to an object that it controls.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorCurveBinding extends ValueType {
        constructor()
        GetHashCode(): number
        Equals(other: Object): boolean
        Equals(other: EditorCurveBinding): boolean
        static op_Equality(lhs: EditorCurveBinding, rhs: EditorCurveBinding): boolean
        static op_Inequality(lhs: EditorCurveBinding, rhs: EditorCurveBinding): boolean
        /** Creates a preconfigured binding for a float curve.
         * @param inPath The transform path to the object to animate.
         * @param inType The type of the object to animate.
         * @param inPropertyName The name of the property to animate on the object.
         */
        static FloatCurve(inPath: string, inType: any, inPropertyName: string): EditorCurveBinding
        /** Creates a preconfigured binding for a curve that points to an Object.
         * @param inPath The transform path to the object to animate.
         * @param inType The type of the object to animate.
         * @param inPropertyName The name of the property to animate on the object.
         */
        static PPtrCurve(inPath: string, inType: any, inPropertyName: string): EditorCurveBinding
        /** Creates a preconfigured binding for a curve where values should not be interpolated.
         * @param inPath The transform path to the object to animate.
         * @param inType The type of the object to animate.
         * @param inPropertyName The name of the property to animate on the object.
         */
        static DiscreteCurve(inPath: string, inType: any, inPropertyName: string): EditorCurveBinding
        // js_op_overloading: static ==(lhs: EditorCurveBinding, rhs: EditorCurveBinding): boolean
        readonly isPPtrCurve: boolean
        readonly isDiscreteCurve: boolean
        /** The type of the property to be animated.
         */
        type: any
        /** The transform path of the object that is animated.
         */
        path: string
        /** The name of the property to be animated.
         */
        propertyName: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Vector2, Rect } from "UnityEngine";
    /** Use this class to instantiate a SceneViewCameraWindow window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneViewCameraWindow extends PopupWindowContent {
        constructor(sceneView: SceneView)
        GetWindowSize(): Vector2
        /** A callback used for drawing the GUI controls of the SceneViewCameraWindow window.
         * @param rect The rectangle where the GUI controls are drawn.
         */
        OnGUI(rect: Rect): void
        static additionalSettingsGui(op: "add" | "remove", fn: (obj: SceneView) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect, Vector2 } from "UnityEngine";
    /** Class used to implement content for a popup window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PopupWindowContent extends Object {
        /** Callback for drawing GUI controls for the popup window.
         * @param rect The rectangle to draw the GUI inside.
         */
        OnGUI(rect: Rect): void
        GetWindowSize(): Vector2
        OnOpen(): void
        OnClose(): void
        /** The EditorWindow that contains the popup content.
         */
        readonly editorWindow: EditorWindow
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Drawing modes for Handles.DrawCamera.
     */
    enum DrawCameraMode {
        /** Draw the camera textured with selection wireframe and no background clearing.
         */
        Textured = 0,
        /** Draw the camera in wireframe and no background clearing.
         */
        Wireframe = 1,
        /** Draw the camera where all objects have a wireframe overlay. and no background clearing.
         */
        TexturedWire = 2,
        /** The camera is set to draw directional light shadow map cascades.
         */
        ShadowCascades = 3,
        /** The camera is set to draw color coded render paths.
         */
        RenderPaths = 4,
        /** The camera is set to display the alpha channel of the rendering.
         */
        AlphaChannel = 5,
        /** The camera is set to display Scene overdraw, with brighter colors indicating more overdraw.
         */
        Overdraw = 6,
        /** The camera is set to display the texture resolution, with a red tint indicating resolution that is too high, and a blue tint indicating texture sizes that could be higher.
         */
        Mipmaps = 7,
        /** Draw diffuse color of Deferred Shading G-buffer.
         */
        DeferredDiffuse = 8,
        /** Draw specular color of Deferred Shading G-buffer.
         */
        DeferredSpecular = 9,
        /** Draw smoothness value of Deferred Shading G-buffer.
         */
        DeferredSmoothness = 10,
        /** Draw world space normal of Deferred Shading G-buffer.
         */
        DeferredNormal = 11,
        /** Draw objects with different colors for each real-time chart (UV island).
         */
        RealtimeCharting = 12,
        /** Draw objects with different color for each GI system.
         */
        Systems = 13,
        /** Draw objects with the Enlighten Realtime Global Illumination albedo component only.
         */
        RealtimeAlbedo = 14,
        /** Draw objects with the Enlighten Realtime Global Illumination emission component only.
         */
        RealtimeEmissive = 15,
        /** Draw objects with the Enlighten Realtime Global Illumination indirect light only.
         */
        RealtimeIndirect = 16,
        /** Draw objects with the Enlighten Realtime Global Illumination  directionality component only.
         */
        RealtimeDirectionality = 17,
        /** Draw objects with the baked lightmap only.
         */
        BakedLightmap = 18,
        /** Draw with different colors for each cluster.
         */
        Clustering = 19,
        /** Draw lit clusters.
         */
        LitClustering = 20,
        /** The camera is set to draw a physically based, albedo validated rendering.
         */
        ValidateAlbedo = 21,
        /** The camera is set to draw a physically based, metal or specular validated rendering.
         */
        ValidateMetalSpecular = 22,
        /** The camera is set to display colored ShadowMasks, coloring light gizmo with the same color.
         */
        ShadowMasks = 23,
        /** The camera is set to show in red static lights that fall back to 'static' because more than four light volumes are overlapping.
         */
        LightOverlap = 24,
        /** Draw objects with the baked albedo component only.
         */
        BakedAlbedo = 25,
        /** Draw objects with the baked emission component only.
         */
        BakedEmissive = 26,
        /** Draw objects with the baked directionality component only.
         */
        BakedDirectionality = 27,
        /** Draw objects with baked texel validity only.
         */
        BakedTexelValidity = 28,
        /** Draw objects with baked indices only.
         */
        BakedIndices = 29,
        /** Draw objects with different colors for each baked chart (UV island).
         */
        BakedCharting = 30,
        /** The camera is set to display SpriteMask and SpriteRenderer with SpriteRenderer.maskInteraction set.
         */
        SpriteMask = 31,
        /** Draw objects with overlapping lightmap texels highlighted.
         */
        BakedUVOverlap = 32,
        /** The camera is set to run in texture streaming debug mode.
         */
        TextureStreaming = 33,
        /** Draw objects with visible lightmap texels highlighted.
         */
        BakedLightmapCulling = 34,
        /** Draw Mesh Renderers and Terrains in different colors to show their StaticEditorFlags.ContributeGI  / ReceiveGI properties. With default colors:

Yellow means 'ContributeGI' is off.
Blue means that 'ContributeGI' is on and the object receives GI from lightmaps. Additional resources: ReceiveGI.Lightmaps
Red means that 'ContributeGI' is on, but that the object receives GI from Light Probes instead. Additional resources: ReceiveGI.LightProbes.

All colors can be adjusted under Preferences > Colors.
         */
        GIContributorsReceivers = 35,
        /** A custom mode defined by the user.
         */
        UserDefined = -2147483648,
        /** Draw objects with baked GI only. This value has been deprecated. Please use DrawCameraMode.BakedLightmap.
         */
        Baked = -18,
        /** Draw objects with directionality for Enlighten Realtime Global Illumination. This value has been deprecated. Please use DrawCameraMode.RealtimeDirectionality.
         */
        Directionality = -17,
        /** Draw objects with Enlighten Realtime Global Illumination only. This value has been deprecated. Please use DrawCameraMode.RealtimeIndirect.
         */
        Irradiance = -16,
        /** Draw objects with the emission component only. This value has been deprecated. Please use DrawCameraMode.RealtimeEmissive.
         */
        Emissive = -15,
        /** Draw objects with the albedo component only. This value has been deprecated. Please use DrawCameraMode.RealtimeAlbedo.
         */
        Albedo = -14,
        /** Draw objects with different colors for each real-time chart (UV island).
         */
        Charting = -12,
        /** Draw the camera like it would be drawn in-game. This uses the clear flags of the camera.
         */
        Normal = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Quaternion, Matrix4x4, Ray, Vector3 } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MathUtils extends Object {
        constructor()
        static GetQuatLength(q: Quaternion): number
        static GetQuatConjugate(q: Quaternion): Quaternion
        static OrthogonalizeMatrix(m: Matrix4x4): Matrix4x4
        static QuaternionNormalize(q: jsb.Ref<Quaternion>): void
        static QuaternionFromMatrix(m: Matrix4x4): Quaternion
        static GetQuatLog(q: Quaternion): Quaternion
        static GetQuatExp(q: Quaternion): Quaternion
        static GetQuatSquad(t: number, q0: Quaternion, q1: Quaternion, a0: Quaternion, a1: Quaternion): Quaternion
        static GetSquadIntermediate(q0: Quaternion, q1: Quaternion, q2: Quaternion): Quaternion
        static Ease(t: number, k1: number, k2: number): number
        static Slerp(p: Quaternion, q: Quaternion, t: number): Quaternion
        static IntersectRayTriangle(ray: Ray, v0: Vector3, v1: Vector3, v2: Vector3, bidirectional: boolean): Object
        static ClosestPtSegmentRay(p1: Vector3, q1: Vector3, ray: Ray, squaredDist: jsb.Out<number>, s: jsb.Out<number>, closestRay: jsb.Out<Vector3>): Vector3
        static IntersectRaySphere(ray: Ray, sphereOrigin: Vector3, sphereRadius: number, t: jsb.Ref<number>, q: jsb.Ref<Vector3>): boolean
        static ClosestPtRaySphere(ray: Ray, sphereOrigin: Vector3, sphereRadius: number, t: jsb.Ref<number>, q: jsb.Ref<Vector3>): boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Evaluates simple math expressions; supports int  float and operators: + - *  % ^ ( ).
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ExpressionEvaluator extends Object {
        constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector3 } from "UnityEngine";
    /** Control the behavior of handle snapping in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorSnapSettings extends Object {
        static ResetSnapSettings(): void
        /** Gets or sets whether grid snapping is enabled.
         */
        static gridSnapEnabled: boolean
        /** Gets or sets the increment that translation handles snap to.
         */
        static move: Vector3
        /** Gets or sets the increment that rotation handles snap to.
         */
        static rotate: number
        /** Gets or sets the increment that scale handles snap to.
         */
        static scale: number
        static gridSnapEnabledChanged(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Additional resources: Undo.postprocessModifications.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class UndoPropertyModification extends ValueType {
        constructor()
        /** Indicates whether to retain modifications when the targeted object is an instance of a Prefab.
         */
        keepPrefabOverride: boolean
        /** 
                  The previous value of the modified property.
                  Additional resources: PropertyModification .
                
         */
        previousValue: PropertyModification
        /** 
                  The current value of the modified property.
                  Additional resources: PropertyModification.
                
         */
        currentValue: PropertyModification
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** This enumeration describes the different kind of changes that can be tracked in an ObjectChangeEventStream. Each event has a corresponding type in ObjectChangeEvents.
     */
    enum ObjectChangeKind {
        /** Indicates an uninitialized value.
         */
        None = 0,
        /** A change of this type indicates that an open scene has been changed ("dirtied") without any more specific information available. This happens for example when EditorSceneManager.MarkSceneDirty is used.
         */
        ChangeScene = 1,
        /** A change of this type indicates that a GameObject has been created, possibly with additional objects below it in the hierarchy. This happens for example when Undo.RegisterCreatedObjectUndo is used with a GameObject.
         */
        CreateGameObjectHierarchy = 2,
        /** A change of this type indicates that the structure of a GameObject has changed and any GameObject in the hierarchy below it might have changed. This happens for example when Undo.RegisterFullObjectHierarchyUndo is used.
         */
        ChangeGameObjectStructureHierarchy = 3,
        /** A change of this type indicates that the structure of a GameObject has changed. This happens when a component is added to or removed from the GameObject using Undo.AddComponent or Undo.DestroyObjectImmediate.
         */
        ChangeGameObjectStructure = 4,
        /** A change of this type indicates that the parent of a GameObject has changed. This happens when Undo.SetTransformParent or SceneManager.MoveGameObjectToScene is used.
         */
        ChangeGameObjectParent = 5,
        /** A change of this type indicates that a property of a GameObject or Component has changed. This happens for example when Undo.RecordObject is used with an instance of a Component.
         */
        ChangeGameObjectOrComponentProperties = 6,
        /** A change of this type indicates that a GameObject and the entire hierarchy below it has been destroyed. This happens for example when Undo.DestroyObjectImmediate is used with an GameObject.
         */
        DestroyGameObjectHierarchy = 7,
        /** A change of this type indicates that an asset object has been created. This happens for example when Undo.RegisterCreatedObjectUndo is used with an instance of an asset (e.g. Texture).
         */
        CreateAssetObject = 8,
        /** A change of this type indicates that an asset object has been destroyed. This happens for example when Undo.DestroyObjectImmediate is used with an instance of an asset (e.g. Texture).
         */
        DestroyAssetObject = 9,
        /** A change of this type indicates that a property of an asset object in memory has changed. This happens for example when Undo.RecordObject is used with an instance of an asset (e.g. Texture).
         */
        ChangeAssetObjectProperties = 10,
        /** A change of this type indicates that prefab instances in an open scene have been updated due to a change to the source prefab.
         */
        UpdatePrefabInstances = 11,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Exposes events that allow you to track undoable changes to objects in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ObjectChangeEvents extends Object {
        static changesPublished(op: "add" | "remove", fn: (stream: jsb.Ref<ObjectChangeEventStream>) => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that the parent of a GameObject has changed. This happens when Undo.SetTransformParent or SceneManager.MoveGameObjectToScene is used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeGameObjectParentEventArgs extends ValueType {
        constructor(instanceId: number, previousScene: any, previousParentInstanceId: number, newScene: any, newParentInstanceId: number)
        /** The instance ID of the GameObject whose parent changed. Note that this is not the instance ID of the Transform component.
         */
        readonly instanceId: number
        /** The instance ID of the GameObject that was the previous parent of the target. Note that this is not the instance ID of its Transform.
         */
        readonly previousParentInstanceId: number
        /** The instance ID of the GameObject that is the new parent of the target. Note that this is not the instance ID of its Transform.
         */
        readonly newParentInstanceId: number
        /** The scene containing the previous parent. This is useful to detect whether a GameObject was moved to another scene.
         */
        readonly previousScene: any
        /** The Scene containing the new parent. This is useful to detect whether a GameObject was moved to another scene or moved to the root of a scene.
         */
        readonly newScene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that an open scene has been changed ("dirtied") without any more specific information available. This happens for example when EditorSceneManager.MarkSceneDirty is used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeSceneEventArgs extends ValueType {
        constructor(scene: any)
        /** The Scene that was changed.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that a GameObject has been created, possibly with additional objects below it in the hierarchy. This happens for example when Undo.RegisterCreatedObjectUndo is used with a GameObject.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CreateGameObjectHierarchyEventArgs extends ValueType {
        constructor(instanceId: number, scene: any)
        /** The instance ID of the GameObject that has been created.
         */
        readonly instanceId: number
        /** The scene containing the GameObject that has been created.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that the structure of a GameObject has changed and any GameObject in the hierarchy below it might have changed. This happens for example when Undo.RegisterFullObjectHierarchyUndo is used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeGameObjectStructureHierarchyEventArgs extends ValueType {
        constructor(instanceId: number, scene: any)
        /** The instance ID of the GameObject that has been changed.
         */
        readonly instanceId: number
        /** The scene containing the GameObject that has been changed.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that the structure of a GameObject has changed. This happens when a component is added to or removed from the GameObject using Undo.AddComponent or Undo.DestroyObjectImmediate.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeGameObjectStructureEventArgs extends ValueType {
        constructor(instanceId: number, scene: any)
        /** The instance ID of the GameObject that has been changed.
         */
        readonly instanceId: number
        /** The Scene containing the GameObject that has been changed.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that a property of a GameObject or Component has changed. This happens for example when Undo.RecordObject is used with an instance of a Component.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeGameObjectOrComponentPropertiesEventArgs extends ValueType {
        constructor(instanceId: number, scene: any)
        /** The instance ID of the modified GameObject or Component.
         */
        readonly instanceId: number
        /** The Scene that contains the GameObject associated with the change. If a Component is changed, this is the GameObject to which the component belongs.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that a GameObject and the entire hierarchy below it has been destroyed. This happens for example when Undo.DestroyObjectImmediate is used with an GameObject.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DestroyGameObjectHierarchyEventArgs extends ValueType {
        constructor(instanceId: number, parentInstanceId: number, scene: any)
        constructor(instanceId: number, scene: any)
        /** The instance ID of the GameObject that has been destroyed.
         */
        readonly instanceId: number
        /** The instance ID for the parent GameObject of the GameObject that has been destroyed.
         */
        readonly parentInstanceId: number
        /** The scene containing the GameObject that has been destroyed.
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that an asset object has been created. This happens for example when Undo.RegisterCreatedObjectUndo is used with an instance of an asset (e.g. Texture).
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CreateAssetObjectEventArgs extends ValueType {
        constructor(guid: GUID, instanceId: number, scene: any)
        /** The GUID of the new asset.
         */
        readonly guid: GUID
        /** The instance ID of the modified asset.
         */
        readonly instanceId: number
        /** The Scene that contains the new asset. This is usually an invalid scene unless the asset is explicitly associated in a scene (e.g. RenderSettings).
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that an asset object has been destroyed. This happens for example when Undo.DestroyObjectImmediate is used with an instance of an asset (e.g. Texture).
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DestroyAssetObjectEventArgs extends ValueType {
        constructor(guid: GUID, instanceId: number, scene: any)
        /** The GUID of the removed asset.
         */
        readonly guid: GUID
        /** The instance ID of the modified asset.
         */
        readonly instanceId: number
        /** The scene that contained the asset. This is usually an invalid scene unless the asset is explicitly associated in a scene (e.g. RenderSettings).
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** A change of this type indicates that a property of an asset object in memory has changed. This happens for example when Undo.RecordObject is used with an instance of an asset (e.g. Texture).
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChangeAssetObjectPropertiesEventArgs extends ValueType {
        constructor(guid: GUID, instanceId: number, scene: any)
        /** The GUID of the changed asset.
         */
        readonly guid: GUID
        /** The instance ID of the modified asset.
         */
        readonly instanceId: number
        /** The Scene that contains the modified asset. This is usually an invalid scene unless the asset is explicitly associated in a scene (e.g. RenderSettings).
         */
        readonly scene: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    /** Represents a stream of events that describes the changes applied to objects in memory over the course of a frame.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ObjectChangeEventStream extends ValueType {
        constructor()
        /** Returns the type of the event at the specified index.
         * @param eventIdx The index of the event whose type should be returned.
         * @returns The type of the event at the specified index. 
         */
        GetEventType(eventIdx: number): ObjectChangeKind
        /** Retrieves the event data at the given index as a ChangeSceneEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         */
        GetChangeSceneEvent(eventIdx: number, data: jsb.Out<ChangeSceneEventArgs>): void
        /** Retrieves the event data at the given index as a CreateGameObjectHierarchyEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetCreateGameObjectHierarchyEvent(eventIdx: number, data: jsb.Out<CreateGameObjectHierarchyEventArgs>): void
        /** Retrieves the event data at the given index as a DestroyGameObjectHierarchyEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetDestroyGameObjectHierarchyEvent(eventIdx: number, data: jsb.Out<DestroyGameObjectHierarchyEventArgs>): void
        /** Retrieves the event data at the given index as a ChangeGameObjectStructureHierarchyEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetChangeGameObjectStructureHierarchyEvent(eventIdx: number, data: jsb.Out<ChangeGameObjectStructureHierarchyEventArgs>): void
        /** Retrieves the event data at the given index as a ChangeGameObjectStructureEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetChangeGameObjectStructureEvent(eventIdx: number, data: jsb.Out<ChangeGameObjectStructureEventArgs>): void
        /** Retrieves the event data at the given index as a ChangeGameObjectParentEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetChangeGameObjectParentEvent(eventIdx: number, data: jsb.Out<ChangeGameObjectParentEventArgs>): void
        /** Retrieves the event data at the given index as a ChangeAssetObjectPropertiesEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetChangeGameObjectOrComponentPropertiesEvent(eventIdx: number, data: jsb.Out<ChangeGameObjectOrComponentPropertiesEventArgs>): void
        /** Retrieves the event data at the given index as a CreateAssetObjectEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetCreateAssetObjectEvent(eventIdx: number, data: jsb.Out<CreateAssetObjectEventArgs>): void
        /** Retrieves the event data at the given index as a DestroyAssetObjectEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetDestroyAssetObjectEvent(eventIdx: number, data: jsb.Out<DestroyAssetObjectEventArgs>): void
        /** Retrieves the event data at the given index as a ChangeAssetObjectPropertiesEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetChangeAssetObjectPropertiesEvent(eventIdx: number, data: jsb.Out<ChangeAssetObjectPropertiesEventArgs>): void
        /** Retrieves the event data at the given index as a UpdatePrefabInstancesEventArgs. Throws an exception if the event type requested does not match the event stored in the stream.
         * @param eventIdx The index of the event to get the data for.
         * @param data The data associated with the event.
         */
        GetUpdatePrefabInstancesEvent(eventIdx: number, data: jsb.Out<any>): void
        /** Creates a copy of this stream with the specified allocator.
         * @param allocator The allocator to use to allocate the memory for the copy.
         * @returns A copy of the stream that contains the same events, but in a separate memory lcoation. 
         */
        Clone(allocator: any): ObjectChangeEventStream
        Dispose(): void
        /** The number of events in the stream.
         */
        readonly length: number
        /** Indicates whether the ObjectChangeEventStream has an allocated memory buffer.
         */
        readonly isCreated: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    namespace ObjectChangeEventStream {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Builder extends ValueType {
            constructor(allocator: any)
            ToStream(allocator: any): ObjectChangeEventStream
            Dispose(): void
            PushChangeSceneEvent(data: jsb.Ref<ChangeSceneEventArgs>): void
            PushCreateGameObjectHierarchyEvent(data: jsb.Ref<CreateGameObjectHierarchyEventArgs>): void
            PushDestroyGameObjectHierarchyEvent(data: jsb.Ref<DestroyGameObjectHierarchyEventArgs>): void
            PushChangeGameObjectStructureHierarchyEvent(data: jsb.Ref<ChangeGameObjectStructureHierarchyEventArgs>): void
            PushChangeGameObjectStructureEvent(data: jsb.Ref<ChangeGameObjectStructureEventArgs>): void
            PushChangeGameObjectParentEvent(data: jsb.Ref<ChangeGameObjectParentEventArgs>): void
            PushChangeGameObjectOrComponentPropertiesEvent(data: jsb.Ref<ChangeGameObjectOrComponentPropertiesEventArgs>): void
            PushCreateAssetObjectEvent(data: jsb.Ref<CreateAssetObjectEventArgs>): void
            PushDestroyAssetObjectEvent(data: jsb.Ref<DestroyAssetObjectEventArgs>): void
            PushChangeAssetObjectPropertiesEvent(data: jsb.Ref<ChangeAssetObjectPropertiesEventArgs>): void
            PushUpdatePrefabInstancesEvent(data: jsb.Ref<any>): void
            readonly eventCount: number
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Component } from "UnityEngine";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IApplyRevertPropertyContextMenuItemProvider {
        TryGetRevertMethodForFieldName(property: SerializedProperty, revertMethod: jsb.Out<any>): boolean
        TryGetApplyMethodForFieldName(property: SerializedProperty, applyMethod: jsb.Out<any>): boolean
        GetSourceTerm(): string
        /** Returns the component specific name to be used in the apply menu item.
         */
        GetSourceName(comp: Component): string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Rect } from "UnityEngine";
    /** Class used to display popup windows that inherit from PopupWindowContent.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PopupWindow extends EditorWindow {
        /** Show a popup with the given PopupWindowContent.
         * @param activatorRect The rect of the button that opens the popup.
         * @param windowContent The content to show in the popup window.
         */
        static Show(activatorRect: Rect, windowContent: PopupWindowContent): void
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Texture2D, Object as Object1 } from "UnityEngine";
    /** Utility for fetching asset previews by instance ID of assets, See AssetPreview.GetAssetPreview. Since previews are loaded asynchronously methods are provided for requesting if all previews have been fully loaded, see AssetPreview.IsLoadingAssetPreviews. Loaded previews are stored in a cache, the size of the cache can be controlled by calling [AssetPreview.SetPreviewTextureCacheSize].
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetPreview extends Object {
        constructor()
        /** Returns a preview texture for an asset.
         */
        static GetAssetPreview(asset: Object1): Texture2D
        /** Loading previews is asynchronous so it is useful to know if a specific asset preview is in the process of being loaded so client code e.g can repaint while waiting for the loading to finish.
         * @param instanceID InstanceID of the assset that a preview has been requested for by: AssetPreview.GetAssetPreview().
         */
        static IsLoadingAssetPreview(instanceID: number): boolean
        static IsLoadingAssetPreviews(): boolean
        /** Set the asset preview cache to a size that can hold all visible previews on the screen at once.
         * @param size The number of previews that can be loaded into the cache before the least used previews are being unloaded.
         */
        static SetPreviewTextureCacheSize(size: number): void
        /** Returns the thumbnail for an object (like the ones you see in the project view).
         */
        static GetMiniThumbnail(obj: Object1): Texture2D
        /** Returns the thumbnail for the type.
         */
        static GetMiniTypeThumbnail(type: any): Texture2D
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace AssetDatabase {
        enum RefreshImportMode {
            InProcess = 0,
            OutOfProcessPerQueue = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Enum } from "System";
    /** Use IHVImageFormatImporter to modify Texture2D import settings for Textures in IHV (Independent Hardware Vendor) formats such as .DDS and .PVR from Editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class IHVImageFormatImporter extends AssetImporter {
        constructor()
        /** Is texture data readable from scripts.
         */
        isReadable: boolean
        /** Filtering mode of the texture.
         */
        filterMode: any
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** Enable mipmap streaming for this texture.
         */
        streamingMipmaps: boolean
        /** Relative priority for this texture when reducing memory size in order to hit the memory budget.
         */
        streamingMipmapsPriority: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array, Enum } from "System";
    import { Object, Color } from "UnityEngine";
    /** AssetImportor for importing SpeedTree model assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SpeedTreeImporter extends AssetImporter {
        constructor()
        GenerateMaterials(): void
        /** Search the project for matching materials and use them instead of the internal materials.
         * @param materialFolderPath The path to search for matching materials.
         * @returns Returns true if any materials have been remapped, otherwise false. 
         */
        SearchAndRemapMaterials(materialFolderPath: string): boolean
        /** Tells if the SPM file has been previously imported.
         */
        readonly hasImported: boolean
        /** Returns the folder path where generated materials will be placed in.
         */
        readonly materialFolderPath: string
        /** Material import location options.
         */
        materialLocation: SpeedTreeImporter.MaterialLocation
        /** Returns true if the asset is a SpeedTree v8 asset.
         */
        readonly isV8: boolean
        /** Returns the default SpeedTree shader for the active render pipeline (either v7 or v8 according to the asset version).
         */
        readonly defaultShader: any
        /** Returns the default SpeedTree billboard shader for the active render pipeline, or null if the asset is a SpeedTree v8 asset.
         */
        readonly defaultBillboardShader: any
        /** How much to scale the tree model compared to what is in the .spm file.
         */
        scaleFactor: number
        /** Gets and sets a default main color.
         */
        mainColor: Color
        /** Gets and sets a default Hue variation color and amount (in alpha).
         */
        hueVariation: Color
        /** Gets and sets a default alpha test reference values.
         */
        alphaTestRef: number
        /** Tells if there is a billboard LOD.
         */
        readonly hasBillboard: boolean
        /** Enables smooth LOD transitions.
         */
        enableSmoothLODTransition: boolean
        /** Indicates if the cross-fade LOD transition, applied to the last mesh LOD and the billboard, should be animated.
         */
        animateCrossFading: boolean
        /** Proportion of the last 3D mesh LOD region width which is used for cross-fading to billboard tree.
         */
        billboardTransitionCrossFadeWidth: number
        /** Proportion of the billboard LOD region width which is used for fading out the billboard.
         */
        fadeOutWidth: number
        /** Gets and sets an array of floats of each LOD's screen height value.
         */
        LODHeights: Array<number>
        /** Gets and sets an array of booleans to enable shadow casting for each LOD.
         */
        castShadows: Array<boolean>
        /** Gets and sets an array of booleans to enable shadow receiving for each LOD.
         */
        receiveShadows: Array<boolean>
        /** Gets and sets an array of booleans to enable Light Probe lighting for each LOD.
         */
        useLightProbes: Array<boolean>
        reflectionProbeUsages: Array<any>
        /** Gets and sets an array of booleans to enable normal mapping for each LOD.
         */
        enableBump: Array<boolean>
        /** Gets and sets an array of booleans to enable Hue variation effect for each LOD.
         */
        enableHue: Array<boolean>
        /** Gets and sets an array of booleans to enable Subsurface effect for each LOD (affects only SpeedTree v8 assets).
         */
        enableSubsurface: Array<boolean>
        /** Returns the best-possible wind quality on this asset (configured in SpeedTree modeler).
         */
        readonly bestWindQuality: number
        /** Gets and sets an array of integers of the wind qualities on each LOD. Values will be clampped by bestWindQuality internally.
         */
        windQualities: Array<number>
        /** Gets an array of name strings for wind quality value.
         */
        static readonly windQualityNames: Array<string>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace SpeedTreeImporter {
        enum MaterialLocation {
            External = 0,
            InPrefab = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { TextAsset } from "UnityEngine";
    /** Shader include file asset.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderInclude extends TextAsset {
        constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Texture } from "UnityEngine";
    import { Array } from "System";
    /** Shader importer lets you modify shader import settings from Editor scripts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ShaderImporter extends AssetImporter {
        constructor()
        GetShader(): any
        /** Sets the default textures for each texture material property.
         */
        SetDefaultTextures(name: Array<string>, textures: Array<Texture>): void
        /** Gets the default texture assigned to the shader importer for the shader property with given name.
         */
        GetDefaultTexture(name: string): Texture
        /** Sets the non-modifiable textures for each texture material property.
         */
        SetNonModifiableTextures(name: Array<string>, textures: Array<Texture>): void
        /** Gets the non-modifiable texture assigned to the shader importer for the shader property with given name.
         */
        GetNonModifiableTexture(name: string): Texture
        /** The preprocessor that Unity uses to compile this shader.
         */
        preprocessorOverride: PreprocessorOverride
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { Object as Object1 } from "UnityEngine";
    namespace AssetImporter {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class SourceAssetIdentifier extends ValueType {
            constructor(type: any, name: string)
            constructor(asset: Object1)
            type: any
            name: string
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Define compute shader import settings in the Unity Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ComputeShaderImporter extends AssetImporter {
        constructor()
        /** The preprocessor that Unity uses to compile this compute shader.
         */
        preprocessorOverride: PreprocessorOverride
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Imported texture format for TextureImporter.
     */
    enum TextureImporterFormat {
        /** TextureFormat.Alpha8 texture format.
         */
        Alpha8 = 1,
        /** TextureFormat.ARGB4444 texture format.
         */
        ARGB16 = 2,
        /** TextureFormat.RGB24 texture format.
         */
        RGB24 = 3,
        /** TextureFormat.RGBA32 texture format.
         */
        RGBA32 = 4,
        /** TextureFormat.ARGB32 texture format.
         */
        ARGB32 = 5,
        /** TextureFormat.RGB565 texture format.
         */
        RGB16 = 7,
        /** TextureFormat.R16 texture format.
         */
        R16 = 9,
        /** TextureFormat.DXT1 (BC1) compressed texture format.
         */
        DXT1 = 10,
        /** TextureFormat.DXT5 (BC3) compressed texture format.
         */
        DXT5 = 12,
        /** TextureFormat.RGBA4444 texture format.
         */
        RGBA16 = 13,
        /** TextureFormat.RHalf half-precision floating point texture format.
         */
        RHalf = 15,
        /** TextureFormat.RGHalf half-precision floating point texture format.
         */
        RGHalf = 16,
        /** TextureFormat.RGBAHalf half-precision floating point texture format.
         */
        RGBAHalf = 17,
        /** TextureFormat.RFloat floating point texture format.
         */
        RFloat = 18,
        /** TextureFormat.RGFloat floating point texture format.
         */
        RGFloat = 19,
        /** TextureFormat.RGBAFloat floating point RGBA texture format.
         */
        RGBAFloat = 20,
        /** TextureFormat.RGB9e5Float packed unsigned floating point texture format with shared exponent.
         */
        RGB9E5 = 22,
        /** TextureFormat.BC6H compressed HDR texture format.
         */
        BC6H = 24,
        /** TextureFormat.BC7 compressed texture format.
         */
        BC7 = 25,
        /** TextureFormat.BC4 compressed texture format.
         */
        BC4 = 26,
        /** TextureFormat.BC5 compressed texture format.
         */
        BC5 = 27,
        /** DXT1 (BC1) compressed texture format using Crunch compression for smaller storage sizes.
         */
        DXT1Crunched = 28,
        /** DXT5 (BC3) compressed texture format using Crunch compression for smaller storage sizes.
         */
        DXT5Crunched = 29,
        /** PowerVR/iOS TextureFormat.PVRTC_RGB2 compressed texture format.
         */
        PVRTC_RGB2 = 30,
        /** PowerVR/iOS TextureFormat.PVRTC_RGBA2 compressed texture format.
         */
        PVRTC_RGBA2 = 31,
        /** PowerVR/iOS TextureFormat.PVRTC_RGB4 compressed texture format.
         */
        PVRTC_RGB4 = 32,
        /** PowerVR/iOS TextureFormat.PVRTC_RGBA4 compressed texture format.
         */
        PVRTC_RGBA4 = 33,
        /** ETC (GLES2.0) 4 bits/pixel compressed RGB texture format.
         */
        ETC_RGB4 = 34,
        ATC_RGB4 = 35,
        ATC_RGBA8 = 36,
        /** ETC2EAC compressed 4 bits  pixel unsigned R texture format.
         */
        EAC_R = 41,
        /** ETC2EAC compressed 4 bits  pixel signed R texture format.
         */
        EAC_R_SIGNED = 42,
        /** ETC2EAC compressed 8 bits  pixel unsigned RG texture format.
         */
        EAC_RG = 43,
        /** ETC2EAC compressed 4 bits  pixel signed RG texture format.
         */
        EAC_RG_SIGNED = 44,
        /** ETC2 compressed 4 bits / pixel RGB texture format.
         */
        ETC2_RGB4 = 45,
        /** ETC2 compressed 4 bits / pixel RGB + 1-bit alpha texture format.
         */
        ETC2_RGB4_PUNCHTHROUGH_ALPHA = 46,
        /** ETC2 compressed 8 bits / pixel RGBA texture format.
         */
        ETC2_RGBA8 = 47,
        /** ASTC compressed RGB(A) texture format, 4x4 block size.
         */
        ASTC_RGB_4x4 = 48,
        /** ASTC compressed RGB(A) texture format, 4x4 block size.
         */
        ASTC_4x4 = 48,
        /** ASTC compressed RGB(A) texture format, 5x5 block size.
         */
        ASTC_RGB_5x5 = 49,
        /** ASTC compressed RGB(A) texture format, 5x5 block size.
         */
        ASTC_5x5 = 49,
        /** ASTC compressed RGB(A) texture format, 6x6 block size.
         */
        ASTC_RGB_6x6 = 50,
        /** ASTC compressed RGB(A) texture format, 6x6 block size.
         */
        ASTC_6x6 = 50,
        /** ASTC compressed RGB(A) texture format, 8x8 block size.
         */
        ASTC_RGB_8x8 = 51,
        /** ASTC compressed RGB(A) texture format, 8x8 block size.
         */
        ASTC_8x8 = 51,
        /** ASTC compressed RGB(A) texture format, 10x10 block size.
         */
        ASTC_10x10 = 52,
        /** ASTC compressed RGB(A) texture format, 10x10 block size.
         */
        ASTC_RGB_10x10 = 52,
        /** ASTC compressed RGB(A) texture format, 12x12 block size.
         */
        ASTC_12x12 = 53,
        /** ASTC compressed RGB(A) texture format, 12x12 block size.
         */
        ASTC_RGB_12x12 = 53,
        /** ASTC compressed RGBA texture format, 4x4 block size.
         */
        ASTC_RGBA_4x4 = 54,
        /** ASTC compressed RGBA texture format, 5x5 block size.
         */
        ASTC_RGBA_5x5 = 55,
        /** ASTC compressed RGBA texture format, 6x6 block size.
         */
        ASTC_RGBA_6x6 = 56,
        /** ASTC compressed RGBA texture format, 8x8 block size.
         */
        ASTC_RGBA_8x8 = 57,
        /** ASTC compressed RGBA texture format, 10x10 block size.
         */
        ASTC_RGBA_10x10 = 58,
        /** ASTC compressed RGBA texture format, 12x12 block size.
         */
        ASTC_RGBA_12x12 = 59,
        /** ETC (Nintendo 3DS) 4 bits/pixel compressed RGB texture format.
         */
        ETC_RGB4_3DS = 60,
        /** ETC (Nintendo 3DS) 8 bits/pixel compressed RGBA texture format.
         */
        ETC_RGBA8_3DS = 61,
        /** TextureFormat.RG16 texture format.
         */
        RG16 = 62,
        /** TextureFormat.R8 texture format.
         */
        R8 = 63,
        /** ETC_RGB4 compressed texture format using Crunch compression for smaller storage sizes.
         */
        ETC_RGB4Crunched = 64,
        /** ETC2_RGBA8 compressed color with alpha channel texture format using Crunch compression for smaller storage sizes.
         */
        ETC2_RGBA8Crunched = 65,
        /** ASTC compressed RGB(A) HDR texture format, 4x4 block size.
         */
        ASTC_HDR_4x4 = 66,
        /** ASTC compressed RGB(A) HDR texture format, 5x5 block size.
         */
        ASTC_HDR_5x5 = 67,
        /** ASTC compressed RGB(A) HDR texture format, 6x6 block size.
         */
        ASTC_HDR_6x6 = 68,
        /** ASTC compressed RGB(A) HDR texture format, 8x8 block size.
         */
        ASTC_HDR_8x8 = 69,
        /** ASTC compressed RGB(A) HDR texture format, 10x10 block size.
         */
        ASTC_HDR_10x10 = 70,
        /** ASTC compressed RGB(A) HDR texture format, 12x12 block size.
         */
        ASTC_HDR_12x12 = 71,
        /** TextureFormat.RG32 texture format.
         */
        RG32 = 72,
        /** TextureFormat.RGB48 texture format.
         */
        RGB48 = 73,
        /** TextureFormat.RGBA64 texture format.
         */
        RGBA64 = 74,
        /** Choose a compressed HDR format automatically.
         */
        AutomaticCompressedHDR = -7,
        /** Choose an HDR format automatically.
         */
        AutomaticHDR = -6,
        /** Choose a crunched format automatically.
         */
        AutomaticCrunched = -5,
        /** Choose a Truecolor format automatically.
         */
        AutomaticTruecolor = -3,
        /** Choose a 16 bit format automatically.
         */
        Automatic16bit = -2,
        /** Choose a compressed format automatically.
         */
        AutomaticCompressed = -1,
        /** Choose a compressed format automatically.
         */
        Automatic = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Mip map filter for TextureImporter.
     */
    enum TextureImporterMipFilter {
        /** Box mipmap filter.
         */
        BoxFilter = 0,
        /** Kaiser mipmap filter.
         */
        KaiserFilter = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Cubemap generation mode for TextureImporter.
     */
    enum TextureImporterGenerateCubemap {
        /** Do not generate cubemap (default).
         */
        None = 0,
        /** Generate cubemap from spheremap texture.
         */
        Spheremap = 1,
        /** Generate cubemap from cylindrical texture.
         */
        Cylindrical = 2,
        SimpleSpheremap = 3,
        NiceSpheremap = 4,
        /** Generate cubemap from vertical or horizontal cross texture.
         */
        FullCubemap = 5,
        /** Automatically determine type of cubemap generation from the source image.
         */
        AutoCubemap = 6,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Scaling mode for non power of two textures in TextureImporter.
     */
    enum TextureImporterNPOTScale {
        /** Keep non power of two textures as is.
         */
        None = 0,
        /** Scale to nearest power of two.
         */
        ToNearest = 1,
        /** Scale to larger power of two.
         */
        ToLarger = 2,
        /** Scale to smaller power of two.
         */
        ToSmaller = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Normal map filtering mode for TextureImporter.
     */
    enum TextureImporterNormalFilter {
        /** Standard normal map filter.
         */
        Standard = 0,
        /** Sobel normal map filter.
         */
        Sobel = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Select how the alpha of the imported texture is generated.
     */
    enum TextureImporterAlphaSource {
        /** No Alpha will be used.
         */
        None = 0,
        /** Use Alpha from the input texture if one is provided.
         */
        FromInput = 1,
        /** Generate Alpha from image gray scale.
         */
        FromGrayScale = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Selects which Color/Alpha channel TextureImporterType|Single Channel Textures uses.
     */
    enum TextureImporterSingleChannelComponent {
        /** Use the Alpha channel.
         */
        Alpha = 0,
        /** Use the red Color channel.
         */
        Red = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Select this to set basic parameters depending on the purpose of your texture.
     */
    enum TextureImporterType {
        /** This is the most common setting used for all the textures in general.
         */
        Default = 0,
        /** Select this to turn the color channels into a format suitable for real-time normal mapping.
         */
        NormalMap = 1,
        /** Use this if your texture is going to be used on any HUD/GUI Controls.
         */
        GUI = 2,
        /** This sets up your texture with the basic parameters used for the Cookies of your lights.
         */
        Cookie = 4,
        /** This sets up your texture with the parameters used by the lightmap.
         */
        Lightmap = 6,
        /** Use this if your texture is going to be used as a cursor.
         */
        Cursor = 7,
        /** Select this if you will be using your texture for Sprite graphics.
         */
        Sprite = 8,
        /** Use this for texture containing a single channel.
         */
        SingleChannel = 10,
        /** Use this for textures that contain shadowmask data.
         */
        Shadowmask = 11,
        /** Use this for textures that contain directional lightmap data.
         */
        DirectionalLightmap = 12,
        /** This is the most common setting used for all the textures in general.
         */
        Image = -2147483648,
        HDRI = -9,
        Advanced = -5,
        Cubemap = -3,
        Reflection = -3,
        Bump = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Select the kind of compression you want for your texture.
     */
    enum TextureImporterCompression {
        /** Texture will not be compressed.
         */
        Uncompressed = 0,
        /** Texture will be compressed using a standard format depending on the platform (DXT, ASTC, ...).
         */
        Compressed = 1,
        /** Texture will be compressed using a high quality format depending on the platform and availability (BC7, ASTC4x4, ...).
         */
        CompressedHQ = 2,
        /** Texture will be compressed using a low quality but high performance, high compression format depending on the platform and availability (2bpp PVRTC, ASTC8x8, ...).
         */
        CompressedLQ = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** For Texture to be scaled down choose resize algorithm. ( Applyed only when Texture dimension is bigger than Max Size ).
     */
    enum TextureResizeAlgorithm {
        /** Default high quality resize algorithm.
         */
        Mitchell = 0,
        /** Might provide better result than Mitchell for some noise textures preserving more sharp details.
         */
        Bilinear = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The shape of the imported texture.
     */
    enum TextureImporterShape {
        /** Import the texture as a 2D texture (default).
         */
        Texture2D = 1,
        /** Import the texture as a Cubemap.
         */
        TextureCube = 2,
        /** Import the texture as a 2D Array texture.
         */
        Texture2DArray = 4,
        /** Import the texture as a 3D texture.
         */
        Texture3D = 8,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Texture importer modes for Sprite import.
     */
    enum SpriteImportMode {
        /** Graphic is not a Sprite.
         */
        None = 0,
        /** Sprite is a single image section extracted automatically from the texture.
         */
        Single = 1,
        /** Sprites are multiple image sections extracted from the texture.
         */
        Multiple = 2,
        /** Sprite has it own mesh outline defined.
         */
        Polygon = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Rect, Vector2, Vector4 } from "UnityEngine";
    /** Editor data used in producing a Sprite.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SpriteMetaData extends ValueType {
        constructor()
        /** Name of the Sprite.
         */
        name: string
        /** Bounding rectangle of the sprite's graphic within the atlas image.
         */
        rect: Rect
        /** Edge-relative alignment of the sprite graphic.
         */
        alignment: number
        /** The pivot point of the Sprite, relative to its bounding rectangle.
         */
        pivot: Vector2
        /** Edge border size for a sprite (in pixels).
         */
        border: Vector4
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    import { Vector2, Vector4 } from "UnityEngine";
    /** Stores settings of a TextureImporter.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TextureImporterSettings extends Object {
        constructor()
        /** Copy parameters into another TextureImporterSettings object.
         * @param target TextureImporterSettings object to copy settings to.
         */
        CopyTo(target: TextureImporterSettings): void
        ApplyTextureType(type: TextureImporterType): void
        /** Test texture importer settings for equality.
         */
        static Equal(a: TextureImporterSettings, b: TextureImporterSettings): boolean
        /** Which type of texture are we dealing with here.
         */
        textureType: TextureImporterType
        /** The shape of the imported texture.
         */
        textureShape: TextureImporterShape
        /** Mipmap filtering mode.
         */
        mipmapFilter: TextureImporterMipFilter
        /** Generate mipmaps for the texture?
         */
        mipmapEnabled: boolean
        /** Whether this texture stores data in sRGB (also called gamma) color space.
         */
        sRGBTexture: boolean
        /** Fade out mip levels to gray color?
         */
        fadeOut: boolean
        /** Enable this to avoid colors seeping out to the edge of the lower Mip levels. Used for light cookies.
         */
        borderMipmap: boolean
        /** Enables or disables coverage-preserving alpha mipmapping.
         */
        mipMapsPreserveCoverage: boolean
        /** Returns or assigns the alpha test reference value.
         */
        alphaTestReferenceValue: number
        /** Mip level where texture begins to fade out to gray.
         */
        mipmapFadeDistanceStart: number
        /** Mip level where texture is faded out to gray completely.
         */
        mipmapFadeDistanceEnd: number
        /** Convert heightmap to normal map?
         */
        convertToNormalMap: boolean
        /** Amount of bumpyness in the heightmap.
         */
        heightmapScale: number
        /** Normal map filtering mode.
         */
        normalMapFilter: TextureImporterNormalFilter
        /** Select how the alpha of the imported texture is generated.
         */
        alphaSource: TextureImporterAlphaSource
        /** Color or Alpha component TextureImporterType|Single Channel Textures uses.
         */
        singleChannelComponent: TextureImporterSingleChannelComponent
        /** The number of rows in the source image for a Texture2DArray or Texture3D.
         */
        flipbookRows: number
        /** The number of columns in the source image for a Texture2DArray or Texture3D.
         */
        flipbookColumns: number
        /** Is texture data readable from scripts.
         */
        readable: boolean
        /** Enable mipmap streaming for this texture.
         */
        streamingMipmaps: boolean
        /** Relative priority for this texture when reducing memory size in order to hit the memory budget.
         */
        streamingMipmapsPriority: number
        /** Enable if the texture is purposed solely for use with a Texture Stack for Virtual Texturing.
         */
        vtOnly: boolean
        /** Scaling mode for non power of two textures.
         */
        npotScale: TextureImporterNPOTScale
        /** Cubemap generation mode.
         */
        generateCubemap: TextureImporterGenerateCubemap
        /** Convolution mode.
         */
        cubemapConvolution: TextureImporterCubemapConvolution
        seamlessCubemap: boolean
        /** Filtering mode of the texture.
         */
        filterMode: any
        /** Anisotropic filtering level of the texture.
         */
        aniso: number
        /** Mipmap bias of the texture.
         */
        mipmapBias: number
        /** Texture coordinate wrapping mode.
         */
        wrapMode: any
        /** Texture U coordinate wrapping mode.
         */
        wrapModeU: any
        /** Texture V coordinate wrapping mode.
         */
        wrapModeV: any
        /** Texture W coordinate wrapping mode for Texture3D.
         */
        wrapModeW: any
        /** If the alpha channel of your texture represents transparency, enable this property to dilate the color channels of visible texels into fully transparent areas. This effectively adds padding around transparent areas that prevents filtering artifacts from forming on their edges. Unity does not support this property for HDR textures.

This property makes the color data of invisible texels undefined. Disable this property to preserve invisible texels' original color data.
         */
        alphaIsTransparency: boolean
        /** Ignore the Gamma attribute in PNG files. This property does not effect other file formats.
         */
        ignorePngGamma: boolean
        /** Sprite texture import mode.
         */
        spriteMode: number
        /** The number of pixels in the sprite that correspond to one unit in world space.
         */
        spritePixelsPerUnit: number
        /** The tessellation detail to be used for generating the mesh for the associated sprite if the SpriteMode is set to Single. For Multiple sprites, use the SpriteEditor to specify the value per sprite.
Valid values are in the range [0-1], with higher values generating a tighter mesh. A default of -1 will allow Unity to determine the value automatically.
         */
        spriteTessellationDetail: number
        /** The number of blank pixels to leave between the edge of the graphic and the mesh.
         */
        spriteExtrude: number
        /** SpriteMeshType defines the type of Mesh that TextureImporter generates for a Sprite.
         */
        spriteMeshType: any
        /** Edge-relative alignment of the sprite graphic.
         */
        spriteAlignment: number
        /** Pivot point of the Sprite relative to its graphic's rectangle.
         */
        spritePivot: Vector2
        /** Border sizes of the generated sprites.
         */
        spriteBorder: Vector4
        /** Generates a default physics shape for a Sprite if a physics shape has not been set by the user.
         */
        spriteGenerateFallbackPhysicsShape: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** Stores platform specifics settings of a TextureImporter.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TextureImporterPlatformSettings extends Object {
        constructor()
        /** Copy parameters into another TextureImporterPlatformSettings object.
         * @param target TextureImporterPlatformSettings object to copy settings to.
         */
        CopyTo(target: TextureImporterPlatformSettings): void
        /** Name of the build target.
         */
        name: string
        /** Set to true in order to override the Default platform parameters by those provided in the TextureImporterPlatformSettings structure.
         */
        overridden: boolean
        /** Maximum texture size.
         */
        maxTextureSize: number
        /** For Texture to be scaled down choose resize algorithm. ( Applyed only when Texture dimension is bigger than Max Size ).
         */
        resizeAlgorithm: TextureResizeAlgorithm
        /** Format of imported texture.
         */
        format: TextureImporterFormat
        /** Compression of imported texture.
         */
        textureCompression: TextureImporterCompression
        /** The quality of Crunch texture compression. The range is 0 through 100. A higher quality means larger textures and longer compression times.
         */
        compressionQuality: number
        /** Use crunch compression when available.
         */
        crunchedCompression: boolean
        /** Allows Alpha splitting on the imported texture when needed (for example ETC1 compression for textures with transparency).
         */
        allowsAlphaSplitting: boolean
        /** Override for ETC2 decompression fallback on Android devices that don't support ETC2.
         */
        androidETC2FallbackOverride: any
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Use this class to retrieve information about the currently selected project and the current Unity ID that is logged in.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CloudProjectSettings extends Object {
        constructor()
        static RefreshAccessToken(refresh: (obj: boolean) => void): void
        /** The user ID of the currently logged-in Unity ID account (Read Only).
         */
        static readonly userId: string
        /** The user name of the currently logged in Unity ID account (Read Only).
         */
        static readonly userName: string
        static readonly accessToken: string
        /** A unique cloud project identifier. It is unique for every project (Read Only).
         */
        static readonly projectId: string
        /** The name of the project entry in the dashboard associated with this project (Read Only).
         */
        static readonly projectName: string
        /** The ID of the organization that this project belongs to. (Read Only)
         */
        static readonly organizationId: string
        /** The name of the organization that this project belongs to. (Read Only)
         */
        static readonly organizationName: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum GameViewSizeGroupType {
        Standalone = 0,
        WebPlayer = 1,
        iOS = 2,
        Android = 3,
        PS3 = 4,
        WiiU = 5,
        Tizen = 6,
        WP8 = 7,
        N3DS = 8,
        HMD = 9,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum CommandHint {
        None = 0,
        Event = 1,
        Menu = 2,
        Shortcut = 4,
        Shelf = 8,
        UI = 1048576,
        OnGUI = 3145728,
        UIElements = 5242880,
        Validate = 1073741824,
        UserDefined = -2147483648,
        Undefined = -1,
        Any = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CommandExecuteContext extends Object {
        constructor()
        readonly data: Object
        args: Array<Object>
        result: Object
        hint: CommandHint
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class CommandService extends Object {
        static GetCommandLabel(commandId: string): string
        static RegisterCommand(id: string, label: string, handler: (context: CommandExecuteContext) => void, hint: CommandHint): void
        static RegisterCommand(id: string, handler: (context: CommandExecuteContext) => void, hint: CommandHint): void
        static UnregisterCommand(id: string): boolean
        static Exists(id: string): boolean
        static Execute(id: string, hint: CommandHint): Object
        static Execute(id: string, hint: CommandHint, ...args: Object[]): Object
        static Execute(id: string): Object
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Material, Object as Object1, Texture } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorMaterialUtility extends Object {
        constructor()
        static ResetDefaultTextures(material: Material, overrideSetTextures: boolean): void
        static IsBackgroundMaterial(material: Material): boolean
        static SetShaderDefaults(shader: any, name: Array<string>, textures: Array<Texture>): void
        static SetShaderNonModifiableDefaults(shader: any, name: Array<string>, textures: Array<Texture>): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Texture2D } from "UnityEngine";
    /** Icon slot container.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PlatformIcon extends Object {
        /** Retrieve the texture which is currently assigned to the specified layer.
         * @param layer Cannot be larger than PlatformIcon.maxLayerCount.
         */
        GetTexture(layer: number): Texture2D
        GetTextures(): Array<Texture2D>
        /** Assign a texture to the specified layer.
         * @param layer Cannot be larger than PlatformIcon.maxLayerCount.
         */
        SetTexture(texture: Texture2D, layer: number): void
        /** Assign all available icon layers.
         * @param textures Must be an array of size PlatformIcon.maxLayerCount.
         */
        SetTextures(...textures: Texture2D[]): void
        toString(): string
        protected constructor()
        /** The number of texture layers the icon slot currently contains.
         */
        layerCount: number
        /** The maximum number of texture layers required by the icon slot.
         */
        readonly maxLayerCount: number
        /** The minimum number of texture layers required by the icon slot.
         */
        readonly minLayerCount: number
        /** The width of the icon in pixels.
         */
        readonly width: number
        /** The height of the icon in pixels.
         */
        readonly height: number
        /** The PlatformIconKind is specific to the target platform.
         */
        readonly kind: PlatformIconKind
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Icon kind wrapper.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PlatformIconKind extends Object {
        Equals(obj: Object): boolean
        GetHashCode(): number
        toString(): string
        protected constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Texture2D, Object as Object1 } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetStoreAsset extends Object {
        constructor()
        Dispose(): void
        readonly Preview: Object1
        readonly HasLivePreview: boolean
        id: number
        name: string
        displayName: string
        staticPreviewURL: string
        dynamicPreviewURL: string
        className: string
        price: string
        packageID: number
        previewImage: Texture2D
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { IEnumerable } from "System.Collections.Generic";
    import { Object } from "UnityEngine";
    import { Object as Object1 } from "System";
    /** AssetSettingsProvider is a specialization of the SettingsProvider class that converts legacy settings to Unified Settings. Legacy settings include any settings that used the Inspector to modify themselves, such as the *.asset files under the ProjectSettings folder. Under the hood, AssetSettingsProvider creates an Editor for specific Assets and builds the UI for the Settings window by wrapping the Editor.OnInspectorGUI function.

Internally we use this class to wrap our existing settings.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AssetSettingsProvider extends SettingsProvider {
        constructor(settingsWindowPath: string, editorCreator: () => Editor, keywords: IEnumerable<string>)
        constructor(settingsWindowPath: string, settingsGetter: () => Object)
        /** Overrides SettingsProvider.OnActivate for this AssetSettingsProvider.
         * @param searchContext Search context in the search box on the Settings window.
         * @param rootElement Root of the UIElements tree. If you add to this root, the SettingsProvider uses UIElements instead of calling SettingsProvider.OnGUI to build the UI. If you do not add to this VisualElement, then you must use the IMGUI to build the UI.
         */
        OnActivate(searchContext: string, rootElement: any): void
        OnDeactivate(): void
        /** Overrides SettingsProvider.OnGUI for this AssetSettingsProvider.
         * @param searchContext Search context for the Settings window. Used to show or hide relevant properties.
         */
        OnGUI(searchContext: string): void
        OnTitleBarGUI(): void
        OnFooterBarGUI(): void
        static CreateProviderFromAssetPath(settingsWindowPath: string, assetPath: string, keywords: IEnumerable<string>): AssetSettingsProvider
        static CreateProviderFromObject(settingsWindowPath: string, settingsObj: Object, keywords: IEnumerable<string>): AssetSettingsProvider
        static CreateProviderFromResourcePath(settingsWindowPath: string, resourcePath: string, keywords: IEnumerable<string>): AssetSettingsProvider
        /** Editor providing UI to modify the settings.
         */
        readonly settingsEditor: Editor
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum BodyPart {
        Avatar = 0,
        Body = 1,
        Head = 2,
        LeftArm = 3,
        LeftFingers = 4,
        RightArm = 5,
        RightFingers = 6,
        LeftLeg = 7,
        RightLeg = 8,
        Last = 9,
        None = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    enum BoneState {
        None = 0,
        NotFound = 1,
        Duplicate = 2,
        InvalidHierarchy = 3,
        BoneLenghtIsZero = 4,
        Valid = 5,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { AnimationClip } from "UnityEngine";
    /** Use the AnimationWindow class to select and edit Animation clips.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AnimationWindow extends EditorWindow implements IHasCustomMenu {
        AddItemsToMenu(menu: GenericMenu): void
        protected constructor()
        /** The animation clip selected in the Animation window.
         */
        animationClip: AnimationClip
        /** This property toggles previewing in the Animation window.
         */
        previewing: boolean
        /** True if Animation window can enable preview mode. False otherwise. (Read Only)
         */
        readonly canPreview: boolean
        /** This property toggles recording in the Animation window.
         */
        recording: boolean
        /** True if Animation window can enable recording mode. False otherwise. (Read Only)
         */
        readonly canRecord: boolean
        /** This property toggles animation playback in the Animation window.
         */
        playing: boolean
        /** The time value at which the Animation window playhead is located.
         */
        time: number
        /** The frame number at which the Animation window playhead is located.
         */
        frame: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Color, Rect } from "UnityEngine";
    /** Antialiased curve rendering functionality used by audio tools in the editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AudioCurveRendering extends Object {
        constructor()
        static BeginCurveFrame(r: Rect): Rect
        static EndCurveFrame(): void
        static DrawCurveFrame(r: Rect): Rect
        static DrawCurveBackground(r: Rect): void
        static DrawFilledCurve(r: Rect, eval: (x: number) => number, curveColor: Color): void
        static DrawFilledCurve(r: Rect, eval: (x: number, col: jsb.Out<Color>) => number): void
        static DrawMinMaxFilledCurve(r: Rect, eval: (x: number, col: jsb.Out<Color>, minValue: jsb.Out<number>, maxValue: jsb.Out<number>) => void): void
        static DrawSymmetricFilledCurve(r: Rect, eval: (x: number, col: jsb.Out<Color>) => number): void
        static DrawCurve(r: Rect, eval: (x: number) => number, curveColor: Color): void
        static DrawGradientRect(r: Rect, c1: Color, c2: Color, blend: number, horizontal: boolean): void
        static readonly kAudioOrange: Color
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class IAudioEffectPluginGUI extends Object {
        OnGUI(plugin: IAudioEffectPlugin): boolean
        readonly Name: string
        readonly Description: string
        readonly Vendor: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class IAudioEffectPlugin extends Object {
        SetFloatParameter(name: string, value: number): boolean
        GetFloatParameter(name: string, value: jsb.Out<number>): boolean
        GetFloatParameterInfo(name: string, minRange: jsb.Out<number>, maxRange: jsb.Out<number>, defaultValue: jsb.Out<number>): boolean
        GetFloatBuffer(name: string, data: jsb.Out<Array<number>>, numsamples: number): boolean
        GetSampleRate(): number
        IsPluginEditableAndEnabled(): boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Enum for Tools.viewTool.
     */
    enum ViewTool {
        /** The orbit tool is selected.
         */
        Orbit = 0,
        /** The pan tool is selected.
         */
        Pan = 1,
        /** The zoom tool is selected.
         */
        Zoom = 2,
        /** The FPS tool is selected.
         */
        FPS = 3,
        /** View tool is not selected.
         */
        None = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Where is the tool handle placed.
     */
    enum PivotMode {
        /** The tool handle is at the graphical center of the selection.
         */
        Center = 0,
        /** The tool handle is on the pivot point of the active object.
         */
        Pivot = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** How is the tool handle oriented.
     */
    enum PivotRotation {
        /** The tool handle is oriented from the active object.
         */
        Local = 0,
        /** The tool handle is aligned along the global axes.
         */
        Global = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Which tool is active in the editor.
     */
    enum Tool {
        /** The view tool is active - Use Tools.viewTool to find out which view tool we're talking about.
         */
        View = 0,
        /** The move tool is active.
         */
        Move = 1,
        /** The rotate tool is active.
         */
        Rotate = 2,
        /** The scale tool is active.
         */
        Scale = 3,
        /** The rect tool is active.
         */
        Rect = 4,
        /** The transform tool is active.
         */
        Transform = 5,
        /** Any tool that is not one of the built-in tools.
         */
        Custom = 6,
        /** No tool is active. Set this to implement your own in-inspector toolbar (like the terrain editor does).
         */
        None = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Vector3, Rect, Quaternion } from "UnityEngine";
    /** Class used to manipulate the tools used in Unity's Scene View.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Tools extends ScriptableObject {
        constructor()
        /** The tool that is currently selected for the Scene View.
         */
        static current: Tool
        /** The option that is currently active for the View tool in the Scene view.
         */
        static viewTool: ViewTool
        /** Returns true if the active tool is a view or navigation tool.
         */
        static readonly viewToolActive: boolean
        /** The position of the tool handle in world space.
         */
        static readonly handlePosition: Vector3
        /** The rectangle used for the rect tool.
         */
        static readonly handleRect: Rect
        /** The rotation of the rect tool handle in world space.
         */
        static readonly handleRectRotation: Quaternion
        /** Are we in Center or Pivot mode.
         */
        static pivotMode: PivotMode
        /** Is the rect handle in blueprint mode?
         */
        static rectBlueprintMode: boolean
        /** The rotation of the tool handle in world space.
         */
        static handleRotation: Quaternion
        /** What's the rotation of the tool handle.
         */
        static pivotRotation: PivotRotation
        /** Hides the Tools(Move, Rotate, Resize) on the Scene view.
         */
        static hidden: boolean
        /** Which layers are visible in the Scene view.
         */
        static visibleLayers: number
        static lockedLayers: number
        static pivotModeChanged(op: "add" | "remove", fn: () => void): void
        static pivotRotationChanged(op: "add" | "remove", fn: () => void): void
        static viewToolChanged(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    /** Base class for implementing sysroots and toolchains for IL2CPP
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Sysroot extends Object {
        Initialize(): boolean
        GetIl2CppArguments(): IEnumerable<string>
        /** Returns name of the sysroot
         */
        readonly Name: string
        /** Returns name of the host platform
         */
        readonly HostPlatform: string
        /** Returns name of the host architecture
         */
        readonly HostArch: string
        /** Returns name of the target platform
         */
        readonly TargetPlatform: string
        /** Returns name of the target architecture
         */
        readonly TargetArch: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for removing assets
     */
    enum RemoveAssetOptions {
        /** The asset should be moved to trash.
         */
        MoveAssetToTrash = 0,
        /** Delete the asset without moving it to the trash.
         */
        DeleteAssets = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Asset path to GUID options.
     */
    enum AssetPathToGUIDOptions {
        /** Return a GUID if the asset exists, or has recently been deleted.
         */
        IncludeRecentlyDeletedAssets = 0,
        /** Return a GUID only if the asset exists on disk.
         */
        OnlyExistingAssets = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Struct used for AssetDatabase.cacheServerConnectionChanged.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CacheServerConnectionChangedParameters extends ValueType {
        constructor()
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Video codec to use when importing video clips.
     */
    enum VideoCodec {
        /** Choose the codec that supports hardware decoding on the target platform.
         */
        Auto = 0,
        /** Encode video with the H.264 codec.
         */
        H264 = 1,
        /** Encode video using the vp8 codec.
         */
        VP8 = 2,
        /** Encode video with the H.265 codec.
         */
        H265 = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Bit rate after the clip is transcoded.
     */
    enum VideoBitrateMode {
        /** Low value, safe for slower internet connections or clips where visual quality is not critical.
         */
        Low = 0,
        /** Typical bit rate supported by internet connections.
         */
        Medium = 1,
        /** High value, possibly exceeding typical internet connection capabilities.
         */
        High = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options for the encoder profile.
     */
    enum VideoEncodingProfile {
        /** Encode video with the baseline profile.
         */
        H264Baseline = 0,
        /** Encode video using the main profile.
         */
        H264Main = 1,
        /** Encode video with the high profile.
         */
        H264High = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Describes how the fields in the image, if any, should be interpreted.
     */
    enum VideoDeinterlaceMode {
        /** Clip is not interlaced.
         */
        Off = 0,
        /** First field is in the even lines.
         */
        Even = 1,
        /** First field is in the odd lines.
         */
        Odd = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** How the video clip's images will be resized during transcoding.
     */
    enum VideoResizeMode {
        /** Same width and height as the source.
         */
        OriginalSize = 0,
        /** 3/4 width and height.
         */
        ThreeQuarterRes = 1,
        /** Half width and height.
         */
        HalfRes = 2,
        /** Quarter width and height.
         */
        QuarterRes = 3,
        /** Fit source in a 1024x1024 rectangle.
         */
        Square1024 = 4,
        /** Fit source in a 512x512 rectangle.
         */
        Square512 = 5,
        /** Fit source in a 256x256 rectangle.
         */
        Square256 = 6,
        /** Resulting size will be driven by VideoClipImporter.customWidth and VideoClipImporter.customHeight.
         */
        CustomSize = 7,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Controls the imported clip's internal resize to save space at the cost of blurrier images.
     */
    enum VideoSpatialQuality {
        /** Scales width and height by 1/2.
         */
        LowSpatialQuality = 0,
        /** Scales width and height by 3/4.
         */
        MediumSpatialQuality = 1,
        /** No resize performed.
         */
        HighSpatialQuality = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Methods to compensate for aspect ratio discrepancies between the source resolution and the wanted encoding size.
     */
    enum VideoEncodeAspectRatio {
        /** Perform no operation.
         */
        NoScaling = 0,
        /** Stretch the source to fill the target resolution without preserving the aspect ratio.
         */
        Stretch = 5,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Importer settings that can have platform-specific values.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VideoImporterTargetSettings extends Object {
        constructor()
        /** Controls whether the movie file will be transcoded during import. When transcoding is not enabled, the file will be imported in its original format.
         */
        enableTranscoding: boolean
        /** Codec that the resulting VideoClip will use.
         */
        codec: VideoCodec
        /** How to resize the images when going into the imported clip.
         */
        resizeMode: VideoResizeMode
        /** How the aspect ratio discrepancies, if any, will be handled if the chosen import resolution has a different ratio than the source.
         */
        aspectRatio: VideoEncodeAspectRatio
        /** Width of the transcoded clip when the resizeMode is set to custom.
         */
        customWidth: number
        /** Height of the transcoded clip when the resizeMode is set to custom.
         */
        customHeight: number
        /** Bit rate type for the transcoded clip.
         */
        bitrateMode: VideoBitrateMode
        /** Controls an internal image resize, resulting in blurrier images but smaller image dimensions and file size.
         */
        spatialQuality: VideoSpatialQuality
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    import { Texture2D } from "UnityEngine";
    /** Represents a plugin importer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PluginImporter extends AssetImporter {
        constructor()
        ClearSettings(): void
        /** Sets compatibility with Any Platform.
         * @param enable Determines whether the plugin is compatible with Any Platform.
         */
        SetCompatibleWithAnyPlatform(enable: boolean): void
        GetCompatibleWithAnyPlatform(): boolean
        /** Exclude platform from compatible platforms when Any Platform is set to true.
         * @param platformName Target platform.
         */
        SetExcludeFromAnyPlatform(platformName: string, excludedFromAny: boolean): void
        /** Exclude platform from compatible platforms when Any Platform is set to true.
         * @param platformName Target platform.
         */
        SetExcludeFromAnyPlatform(platform: BuildTarget, excludedFromAny: boolean): void
        /** Is platform excluded when Any Platform set to true.
         * @param platform Target platform.
         */
        GetExcludeFromAnyPlatform(platformName: string): boolean
        /** Is platform excluded when Any Platform set to true.
         * @param platform Target platform.
         */
        GetExcludeFromAnyPlatform(platform: BuildTarget): boolean
        SetIncludeInBuildDelegate(includeInBuildDelegate: (path: string) => boolean): void
        /** Exclude Editor from compatible platforms when Any Platform is set to true.
         */
        SetExcludeEditorFromAnyPlatform(excludedFromAny: boolean): void
        GetExcludeEditorFromAnyPlatform(): boolean
        /** Sets compatibility with any editor.
         * @param enable Is plugin compatible with editor.
         */
        SetCompatibleWithEditor(enable: boolean): void
        GetCompatibleWithEditor(buildTargetGroup: string, buildTarget: string): boolean
        GetCompatibleWithEditor(): boolean
        GetIsOverridable(): boolean
        ShouldIncludeInBuild(): boolean
        /** Sets compatibility with the specified platform.
         * @param platform Target platform.
         * @param enable Is plugin compatible with specified platform.
         * @param platformName Target platform.
         */
        SetCompatibleWithPlatform(platform: BuildTarget, enable: boolean): void
        /** Sets compatibility with the specified platform.
         * @param platform Target platform.
         * @param enable Is plugin compatible with specified platform.
         * @param platformName Target platform.
         */
        SetCompatibleWithPlatform(platformName: string, enable: boolean): void
        /** Is plugin compatible with specified platform.
         * @param platform Target platform.
         */
        GetCompatibleWithPlatform(platform: BuildTarget): boolean
        /** Is plugin compatible with specified platform.
         * @param platform Target platform.
         */
        GetCompatibleWithPlatform(platformName: string): boolean
        /** Sets platform specific data.
         * @param platform Target platform.
         * @param key Key value for data.
         * @param value Data.
         */
        SetPlatformData(platform: BuildTarget, key: string, value: string): void
        /** Sets platform specific data.
         * @param platform Target platform.
         * @param key Key value for data.
         * @param value Data.
         */
        SetPlatformData(platformName: string, key: string, value: string): void
        /** Get platform specific data.
         * @param platform Target platform.
         * @param key Key value for data.
         */
        GetPlatformData(platform: BuildTarget, key: string): string
        /** Get platform specific data.
         * @param platform Target platform.
         * @param key Key value for data.
         */
        GetPlatformData(platformName: string, key: string): string
        /** Sets editor specific data.
         * @param key Key value for data.
         * @param value Data.
         */
        SetEditorData(key: string, value: string): void
        /** Returns editor specific data for specified key.
         * @param key Key value for data.
         */
        GetEditorData(key: string): string
        /** Sets the custom icon to associate with a MonoScript imported by a managed plugin.
         * @param className The fully qualified class name of a MonoScript imported by this managed plugin.
         * @param icon The custom icon to associate with the imported MonoScript. When the value is null, Unity restores the default icon.
         */
        SetIcon(className: string, icon: Texture2D): void
        /** Gets the custom icon to associate with a MonoScript at import time.
         * @param className The fully qualified class name of a MonoScript imported by this plugin.
         * @returns Returns the custom icon that will be associated with the imported MonoScript. If no custom icon will be associated with the imported MonoScript, returns null. 
         */
        GetIcon(className: string): Texture2D
        static GetImporters(buildTargetGroup: string, buildTarget: string): Array<PluginImporter>
        static GetImporters(buildTargetGroup: BuildTargetGroup, buildTarget: BuildTarget): Array<PluginImporter>
        /** Returns all plugin importers for specfied platform.
         * @param platform Target platform.
         * @param platformName Name of the target platform.
         */
        static GetImporters(platformName: string): Array<PluginImporter>
        /** Returns all plugin importers for specfied platform.
         * @param platform Target platform.
         * @param platformName Name of the target platform.
         */
        static GetImporters(platform: BuildTarget): Array<PluginImporter>
        static GetAllImporters(): Array<PluginImporter>
        /** Allows you to specify a list of #define directives which controls whether your plug-in should be included.
         */
        DefineConstraints: Array<string>
        /** Is a native plugin loaded during startup or on demand?
         */
        isPreloaded: boolean
        /** Is plugin native or managed? Note: C++ libraries with CLR support are treated as native plugins, because Unity cannot load such libraries. You can still access them via P/Invoke.
         */
        readonly isNativePlugin: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    import { Object, Texture2D } from "UnityEngine";
    /** Represents a C# script in the project.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MonoImporter extends AssetImporter {
        constructor()
        /** Sets default references for this MonoScript.
         * @param name An array of names of public fields in the imported MonoScript. The type of each field must be derived from UnityEngine.Object.
         * @param target An array of objects to use as default values. The size of the array must match the size of the names array. The array can include null values.
         */
        SetDefaultReferences(name: Array<string>, target: Array<Object>): void
        GetScript(): MonoScript
        /** Gets the default value for a reference field in the imported MonoScript.
         * @param name The name of a public field in the imported MonoScript.
         * @returns The Unity object to use as a default value for the given reference field. 
         */
        GetDefaultReference(name: string): Object
        /** Sets a custom icon to associate with the imported MonoScript.
         * @param icon The custom icon to associate with the imported MonoScript. When the value is null, Unity restores the default icon.
         */
        SetIcon(icon: Texture2D): void
        GetIcon(): Texture2D
        static GetAllRuntimeMonoScripts(): Array<MonoScript>
        /** Sets the execution order for a MonoScript. This method forces Unity to reimport the MonoImporter for the target script.
         * @param script The script to set the execution order for.
         * @param order The execution order for the given MonoScript.
         */
        static SetExecutionOrder(script: MonoScript, order: number): void
        /** Gets the execution order for a MonoScript.
         * @param script The script to retrieve the execution order for.
         * @returns Returns the execution order for the given MonoScript. 
         */
        static GetExecutionOrder(script: MonoScript): number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** The sample rate setting used within the AudioImporter. This defines the sample rate conversion of audio on import.
     */
    enum AudioSampleRateSetting {
        /** Do not change the sample rate of the imported audio file. The sample rate will be preserved for the imported AudioClip.
         */
        PreserveSampleRate = 0,
        /** Let Unity deduce the optimal sample rate for the AudioClip being imported. The audio file will be analysed and a minimal sample rate chosen while still preserving audio quality.
         */
        OptimizeSampleRate = 1,
        /** Override the sample rate of the imported audio file with a custom value.
         */
        OverrideSampleRate = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    /** This structure contains a collection of settings used to define how an AudioClip should be imported.

This  structure is used with the AudioImporter to define how the AudioClip should be imported and treated during loading within the Scene.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AudioImporterSampleSettings extends ValueType {
        constructor()
        /** LoadType defines how the imported AudioClip data should be loaded.
         */
        loadType: any
        /** Defines how the sample rate is modified (if at all) of the importer audio file.
         */
        sampleRateSetting: AudioSampleRateSetting
        /** Target sample rate to convert to when samplerateSetting is set to OverrideSampleRate.
         */
        sampleRateOverride: number
        /** CompressionFormat defines the compression type that the audio file is encoded to. Different compression types have different performance and audio artifact characteristics.
         */
        compressionFormat: any
        /** Audio compression quality (0-1)

Amount of compression. The value roughly corresponds to the ratio between the resulting and the source file sizes.
         */
        quality: number
        conversionMode: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** Represents an Android asset pack directory in a project.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AndroidAssetPackImporter extends AssetImporter {
        constructor()
        static GetAllImporters(): Array<AndroidAssetPackImporter>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Options to control the optimization of mesh data during asset import.
     */
    enum MeshOptimizationFlags {
        /** Optimize the order of polygons in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        PolygonOrder = 1,
        /** Optimize the order of vertices in the mesh to make better use of the GPUs internal caches to improve rendering performance.
         */
        VertexOrder = 2,
        /** Perform maximum optimization of the mesh data, enables all optimization options.
         */
        Everything = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** AnimationClip mask options for ModelImporterClipAnimation.
     */
    enum ClipAnimationMaskType {
        /** A mask containing all the transform in the file will be created internally.
         */
        CreateFromThisModel = 0,
        /** Use a mask from your project to specify which transforms animation should be imported.
         */
        CopyFromOther = 1,
        /** No Mask. All the animation will be imported.
         */
        None = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { AnimationCurve } from "UnityEngine";
    /** Stores a curve and its name that will be used to create additional curves during the import process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ClipAnimationInfoCurve extends ValueType {
        constructor()
        /** The name of the animation curve.
         */
        name: string
        /** The animation curve.
         */
        curve: AnimationCurve
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { WrapMode, Object as Object1 } from "UnityEngine";
    /** Animation clips to split animation into.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ModelImporterClipAnimation extends Object {
        constructor()
        /** Copy the current masking settings from the clip to an AvatarMask.
         * @param mask AvatarMask to which the masking values will be saved.
         */
        ConfigureMaskFromClip(mask: jsb.Ref<any>): void
        /** Copy the mask settings from an AvatarMask to the clip configuration.
         * @param mask AvatarMask from which the mask settings will be imported.
         */
        ConfigureClipFromMask(mask: any): void
        Equals(o: Object): boolean
        GetHashCode(): number
        /** Take name.
         */
        takeName: string
        /** Clip name.
         */
        name: string
        /** First frame of the clip.
         */
        firstFrame: number
        /** Last frame of the clip.
         */
        lastFrame: number
        /** The wrap mode of the animation.
         */
        wrapMode: WrapMode
        /** Is the clip a looping animation?
         */
        loop: boolean
        /** Offset in degrees to the root rotation.
         */
        rotationOffset: number
        /** Offset to the vertical root position.
         */
        heightOffset: number
        /** Offset to the cycle of a looping animation, if a different time in it is desired to be the start.
         */
        cycleOffset: number
        /** Enable to make the clip loop.
         */
        loopTime: boolean
        /** Enable to make the motion loop seamlessly.
         */
        loopPose: boolean
        /** Enable to make root rotation be baked into the movement of the bones. Disable to make root rotation be stored as root motion.
         */
        lockRootRotation: boolean
        /** Enable to make vertical root motion be baked into the movement of the bones. Disable to make vertical root motion be stored as root motion.
         */
        lockRootHeightY: boolean
        /** Enable to make horizontal root motion be baked into the movement of the bones. Disable to make horizontal root motion be stored as root motion.
         */
        lockRootPositionXZ: boolean
        /** Keeps the vertical position as it is authored in the source file.
         */
        keepOriginalOrientation: boolean
        /** Keeps the vertical position as it is authored in the source file.
         */
        keepOriginalPositionY: boolean
        /** Keeps the vertical position as it is authored in the source file.
         */
        keepOriginalPositionXZ: boolean
        /** Keeps the feet aligned with the root transform position.
         */
        heightFromFeet: boolean
        /** Mirror left and right in this clip.
         */
        mirror: boolean
        /** Define mask type.
         */
        maskType: ClipAnimationMaskType
        /** The AvatarMask used to mask transforms during the import process.
         */
        maskSource: any
        /** AnimationEvents that will be added during the import process.
         */
        events: Array<any>
        /** Additionnal curves that will be that will be added during the import process.
         */
        curves: Array<ClipAnimationInfoCurve>
        /** Returns true when the source AvatarMask has changed. This only happens when  ModelImporterClipAnimation.maskType is set to ClipAnimationMaskType.CopyFromOther
To force a reload of the mask, simply set  ModelImporterClipAnimation.maskSource to the desired AvatarMask.
         */
        readonly maskNeedsUpdating: boolean
        /** The additive reference pose frame.
         */
        additiveReferencePoseFrame: number
        /** Enable to defines an additive reference pose.
         */
        hasAdditiveReferencePose: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Material naming options for ModelImporter.
     */
    enum ModelImporterMaterialName {
        /** Use material names in the form <textureName>.mat.
         */
        BasedOnTextureName = 0,
        /** Use a material name of the form <materialName>.mat.
         */
        BasedOnMaterialName = 1,
        /** Use material names in the form <modelFileName>-<materialName>.mat.
         */
        BasedOnModelNameAndMaterialName = 2,
        /** <textureName>.mat or <modelFileName>-<materialName>.mat material name.
         */
        BasedOnTextureName_Or_ModelNameAndMaterialName = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Material search options for ModelImporter.
     */
    enum ModelImporterMaterialSearch {
        /** Search in local Materials folder.
         */
        Local = 0,
        /** Recursive-up search in Materials folders.
         */
        RecursiveUp = 1,
        /** Search in all project.
         */
        Everywhere = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Material import options for ModelImporter.
     */
    enum ModelImporterMaterialLocation {
        /** Extract the materials and textures from the model.
         */
        External = 0,
        /** Unity imports materials as sub-assets.
         */
        InPrefab = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Material import options for ModelImporter.
     */
    enum ModelImporterMaterialImportMode {
        /** The model importer does not import materials.
         */
        None = 0,
        ImportStandard = 1,
        LegacyImport = 1,
        /** Enables the PreprocessMaterialDescription AssetPostprocessor on the current importer.
         */
        ImportViaMaterialDescription = 2,
        /** Enables the PreprocessMaterialDescription AssetPostprocessor on the current importer.
         */
        Import = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Tangent space generation options for ModelImporter.
     */
    enum ModelImporterTangentSpaceMode {
        /** Import normals/tangents from file.
         */
        Import = 0,
        /** Calculate tangents.
         */
        Calculate = 1,
        /** Strip normals/tangents.
         */
        None = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Normal generation options for ModelImporter.
     */
    enum ModelImporterNormals {
        /** Import vertex normals from model file (default).
         */
        Import = 0,
        /** Calculate vertex normals.
         */
        Calculate = 1,
        /** Do not import vertex normals.
         */
        None = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Normal generation options for ModelImporter.
     */
    enum ModelImporterNormalCalculationMode {
        /** The normals are unweighted. This option uses the legacy algorithm for handling hard edges.
         */
        Unweighted_Legacy = 0,
        /** The normals are not weighted.
         */
        Unweighted = 1,
        /** The normals are weighted by the face area.
         */
        AreaWeighted = 2,
        /** The normals are weighted by the vertex angle on each face.
         */
        AngleWeighted = 3,
        /** The normals are weighted by both the face area and the vertex angle on each face.
         */
        AreaAndAngleWeighted = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Source of smoothing information for calculation of normals in ModelImporter.
     */
    enum ModelImporterNormalSmoothingSource {
        /** Use smoothing groups if they are present in the Model file, otherwise use angle (default).
         */
        PreferSmoothingGroups = 0,
        /** Use smoothing groups to determine which edges are smooth and which are hard.
         */
        FromSmoothingGroups = 1,
        /** Use the angle between adjacent faces to determine if an edge is smooth or hard.
         */
        FromAngle = 2,
        /** Do not create hard edges.
         */
        None = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Vertex tangent generation options for ModelImporter.
     */
    enum ModelImporterTangents {
        /** Import vertex tangents from model file.
         */
        Import = 0,
        /** Calculate tangents with legacy algorithm.
         */
        CalculateLegacy = 1,
        /** Do not import vertex tangents.
         */
        None = 2,
        /** Calculate tangents using MikkTSpace (default).
         */
        CalculateMikk = 3,
        /** Calculate tangents with legacy algorithm, with splits across UV charts.
         */
        CalculateLegacyWithSplitTangents = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Mesh compression options for ModelImporter.
     */
    enum ModelImporterMeshCompression {
        /** No mesh compression (default).
         */
        Off = 0,
        /** Low amount of mesh compression.
         */
        Low = 1,
        /** Medium amount of mesh compression.
         */
        Medium = 2,
        /** High amount of mesh compression.
         */
        High = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Format of the imported mesh index buffer data.
     */
    enum ModelImporterIndexFormat {
        /** Use 16 or 32 bit index buffer depending on mesh size.
         */
        Auto = 0,
        /** Use 16 bit index buffer.
         */
        UInt16 = 1,
        /** Use 32 bit index buffer.
         */
        UInt32 = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Animation compression options for ModelImporter.
     */
    enum ModelImporterAnimationCompression {
        /** No animation compression.
         */
        Off = 0,
        /** Perform keyframe reduction.
         */
        KeyframeReduction = 1,
        /** Perform keyframe reduction and compression.
         */
        KeyframeReductionAndCompression = 2,
        /** Perform keyframe reduction and choose the best animation curve representation at runtime to reduce memory footprint (default).
         */
        Optimal = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Animation generation options for ModelImporter. These options relate to the legacy Animation system, they should only be used when ModelImporter.animationType==ModelImporterAnimationType.Legacy.
     */
    enum ModelImporterGenerateAnimations {
        /** Do not generate animations.
         */
        None = 0,
        /** Generate animations in the root objects of the animation package.
         */
        InOriginalRoots = 1,
        /** Generate animations in the objects that animate.
         */
        InNodes = 2,
        /** Generate animations in the transform root objects.
         */
        InRoot = 3,
        /** Default animation import mode (All animations are stored in the root object).
         */
        GenerateAnimations = 4,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Animation mode for ModelImporter.
     */
    enum ModelImporterAnimationType {
        /** Generate no animation data.
         */
        None = 0,
        /** Generate a legacy animation type.
         */
        Legacy = 1,
        /** Generate a generic animator.
         */
        Generic = 2,
        /** Generate a human animator.
         */
        Human = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Humanoid Oversampling available multipliers.
     */
    enum ModelImporterHumanoidOversampling {
        /** Default Humanoid Oversampling multiplier = 1 which is equivalent to no oversampling.
         */
        X1 = 1,
        /** Humanoid Oversampling samples at 2 times the sampling rate found in the imported file.
         */
        X2 = 2,
        /** Humanoid Oversampling samples at 4 times the sampling rate found in the imported file.
         */
        X4 = 4,
        /** Humanoid Oversampling samples at 8 times the sampling rate found in the imported file.
         */
        X8 = 8,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Methods for handling margins during lightmap UV generation in ModelImporter.
     */
    enum ModelImporterSecondaryUVMarginMethod {
        /** Specify pack margin manually.
         */
        Manual = 0,
        /** Calculate suitable lightmap UV margins based on expected lightmap resolution and object scale.
         */
        Calculate = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Set the Avatar generation mode for ModelImporter.
     */
    enum ModelImporterAvatarSetup {
        /** Disable Avatar creation for this model.
         */
        NoAvatar = 0,
        /** Create the Avatar from this model and save it as a sub-asset.
         */
        CreateFromThisModel = 1,
        /** Copy the Avatar from another model.
         */
        CopyFromOther = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Skin weights options for ModelImporter.
     */
    enum ModelImporterSkinWeights {
        /** Import the standard number of bones per vertex (currently 4).
         */
        Standard = 0,
        /** Import a custom number of bones per vertex.
         */
        Custom = 1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Behaviour } from "UnityEngine";
    /** This provides an auto dispose Localization system. This can be called recursively.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class LocalizationGroup extends Object {
        constructor(behaviour: Behaviour)
        constructor(type: any)
        constructor(obj: Object)
        constructor()
        Dispose(): void
        /** A current group name for the localization.
         */
        readonly locGroupName: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Displays the Physics Debug Visualization options.

The Physics Debug Visualization is only displayed if this window is visible.

Additional resources: PhysicsVisualizationSettings.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PhysicsDebugWindow extends EditorWindow {
        constructor()
        OnEnable(): void
        OnDisable(): void
        static ShowWindow(): PhysicsDebugWindow
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Color, Vector2, GameObject, Camera } from "UnityEngine";
    /** This class contains the settings controlling the Physics Debug Visualization.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PhysicsVisualizationSettings extends Object {
        static Reset(): void
        static GetShowStaticColliders(): boolean
        /** Should the Colliders without a Rigidbody component be considered by the display filter.
         */
        static SetShowStaticColliders(show: boolean): void
        static GetShowTriggers(): boolean
        /** Should the triggers be considered by the display filter.
         */
        static SetShowTriggers(show: boolean): void
        static GetShowRigidbodies(): boolean
        /** Should any Rigidbodies be considered by the display filter.
         */
        static SetShowRigidbodies(show: boolean): void
        static GetShowKinematicBodies(): boolean
        /** Should the kinematic Rigidbodies be considered by the display filter.
         */
        static SetShowKinematicBodies(show: boolean): void
        static GetShowArticulationBodies(): boolean
        /** Should Articulation Bodies be shown by the Physics Visualizer.
         * @param show Value to set.
         */
        static SetShowArticulationBodies(show: boolean): void
        static GetShowSleepingBodies(): boolean
        /** Should sleeping Rigidbodies and Articulation Bodies be considered by the display filter.
         */
        static SetShowSleepingBodies(show: boolean): void
        /** Should the given layer be considered by the display filter.
         */
        static GetShowCollisionLayer(layer: number): boolean
        /** Should the given layer be considered by the display filter.
         */
        static SetShowCollisionLayer(layer: number, show: boolean): void
        static GetShowCollisionLayerMask(): number
        /** Should the mask representing the layers be considered by the display filter.
         */
        static SetShowCollisionLayerMask(mask: number): void
        static GetShowBoxColliders(): boolean
        /** Should BoxColliders be shown.
         */
        static SetShowBoxColliders(show: boolean): void
        static GetShowSphereColliders(): boolean
        /** Should SphereColliders be shown.
         */
        static SetShowSphereColliders(show: boolean): void
        static GetShowCapsuleColliders(): boolean
        /** Should CapsuleColliders be shown.
         */
        static SetShowCapsuleColliders(show: boolean): void
        static GetShowMeshColliders(colliderType: PhysicsVisualizationSettings.MeshColliderType): boolean
        static SetShowMeshColliders(colliderType: PhysicsVisualizationSettings.MeshColliderType, show: boolean): void
        static GetShowTerrainColliders(): boolean
        /** Should TerrainColliders be shown.
         */
        static SetShowTerrainColliders(show: boolean): void
        static GetShowPhysicsSceneMask(): number
        /** Should the scene mask be considered by the display filter.
         */
        static SetShowPhysicsSceneMask(mask: number): void
        static InitDebugDraw(): void
        static DeinitDebugDraw(): void
        static ClearMouseHighlight(): void
        static HasMouseHighlight(): boolean
        /** Updates the mouse-over highlight at the given mouse position in screen space.
         */
        static UpdateMouseHighlight(screenPos: Vector2): void
        static PickClosestGameObject(cam: Camera, layers: number, position: Vector2, ignore: Array<GameObject>, filter: Array<GameObject>, materialIndex: jsb.Out<number>): GameObject
        /** Enables or disables all filtering items.
         */
        static SetShowForAllFilters(selected: boolean): void
        /** Shows extra options used to develop and debug the physics visualization.
         */
        static devOptions: boolean
        /** Dirty marker used for refreshing the GUI.
         */
        static readonly dirtyCount: number
        /** Should the PhysicsDebugWindow display the collision geometry.
         */
        static showCollisionGeometry: boolean
        /** Enables the mouse-over highlighting and mouse selection modes.
         */
        static enableMouseSelect: boolean
        /** Controls whether the SceneView or the GameView camera is used. Not shown in the UI.
         */
        static useSceneCam: boolean
        /** Colliders within this distance will be displayed.
         */
        static viewDistance: number
        /** Maximum number of mesh tiles available to draw all Terrain Colliders.
         */
        static terrainTilesMax: number
        /** Forcing the drawing of Colliders on top of any other geometry, regardless of depth.
         */
        static forceOverdraw: boolean
        /** Color for Colliders that do not have a Rigidbody component.
         */
        static staticColor: Color
        /** Color for Rigidbodies, primarily active ones.
         */
        static rigidbodyColor: Color
        /** Color for kinematic Rigidbodies.
         */
        static kinematicColor: Color
        /** Color for Articulation Bodies.
         */
        static articulationBodyColor: Color
        /** Color for Colliders that are Triggers.
         */
        static triggerColor: Color
        /** Color for Rigidbodies that are controlled by the physics simulator, but are not currently being simulated.
         */
        static sleepingBodyColor: Color
        /** Alpha amount used for transparency blending.
         */
        static baseAlpha: number
        /** Used to disinguish neighboring Colliders.
         */
        static colorVariance: number
        static dotAlpha: number
        static forceDot: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PhysicsVisualizationSettings {
        enum FilterWorkflow {
            HideSelectedItems = 0,
            ShowSelectedItems = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace PhysicsVisualizationSettings {
        enum MeshColliderType {
            Convex = 0,
            NonConvex = 1,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Vector3 } from "UnityEngine";
    /** Structure to hold camera data extracted from a SketchUp file.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SketchUpImportCamera extends ValueType {
        constructor()
        /** The position of the camera.
         */
        position: Vector3
        /** The position the camera is looking at.
         */
        lookAt: Vector3
        /** Up vector of the camera.
         */
        up: Vector3
        /** Field of view of the camera.
         */
        fieldOfView: number
        /** Aspect ratio of the camera.
         */
        aspectRatio: number
        /** The orthogonal projection size of the camera. This value only make sense if SketchUpImportCamera.isPerspective is false.
         */
        orthoSize: number
        /** The far clipping plane distance.
         */
        nearPlane: number
        /** The near clipping plane distance.
         */
        farPlane: number
        /** Indicate if the camera is using a perspective or orthogonal projection.
         */
        isPerspective: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Structure to hold scene data extracted from a SketchUp file.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SketchUpImportScene extends ValueType {
        constructor()
        /** The camera data of the SketchUp scene.
         */
        camera: SketchUpImportCamera
        /** The name of the SketchUp scene.
         */
        name: string
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    /** Derives from AssetImporter to handle importing of SketchUp files.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SketchUpImporter extends ModelImporter {
        constructor()
        GetScenes(): Array<SketchUpImportScene>
        GetDefaultCamera(): SketchUpImportCamera
        /** Retrieves the latitude Geo Coordinate imported from the SketchUp file.
         */
        readonly latitude: number
        /** Retrieves the longitude Geo Coordinate imported from the SketchUp file.
         */
        readonly longitude: number
        /** Retrieves the north correction value imported from the SketchUp file.
         */
        readonly northCorrection: number
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Behaviour, Rect, GUIStyle, Texture2D, Object } from "UnityEngine";
    import { Array } from "System";
    /** The default Inspector class for Terrain Layer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TerrainLayerInspector extends Editor {
        constructor()
        /** Applies the custom UI for the Terrain Layer object.
         * @param customUI The custom UI object.
         * @param terrain The Terrain object.
         */
        ApplyCustomUI(customUI: ITerrainLayerCustomUI, terrain: any): void
        OnInspectorGUI(): void
        HasPreviewGUI(): boolean
        /** Draws the default Terrain Layer preview GUI.
         */
        OnPreviewGUI(r: Rect, background: GUIStyle): void
        /** Draws the default Terrain Layer static preview.
         */
        RenderStaticPreview(assetPath: string, subAssets: Array<Object>, width: number, height: number): Texture2D
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Behaviour } from "UnityEngine";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ITerrainLayerCustomUI {
        /** Draws the custom GUI for the terrain layer.
         * @param terrainLayer The TerrainLayer object.
         * @param terrain The Terrain object on which the TerrainLayer object, specified by the terrainLayer parameter, is selected.
         * @returns Return false to have Unity draw the default TerrainLayer inspector. Otherwise draw the custom GUI and return true. 
         */
        OnTerrainLayerGUI(terrainLayer: any, terrain: any): boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Behaviour, Object as Object1, Texture2D } from "UnityEngine";
    /** A set of helper functions for using terrain layers.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TerrainLayerUtility extends Object {
        /** Helper function to show the layer selection window for selecting terrain layers in inspector.
         * @param terrain Terrain tile.
         * @param activeTerrainLayer Currently selected terrain layer index.
         * @returns Newly selected terrain layer index. 
         */
        static ShowTerrainLayersSelectionHelper(terrain: any, activeTerrainLayer: number): number
        /** This helper function shows the Terrain Layer Inspector GUI nested inside the current Inspector GUI.
         * @param terrain The Terrain from which the Terrain Layer originates.
         * @param terrainLayer The Terrain Layer object to show the Inspector for.
         * @param terrainLayerEditor Reference to a variable of type Editor in which Unity caches the Terrain Layer Inspector object.
         * @param customGUI The custom Terrain Layer GUI object.
         */
        static ShowTerrainLayerGUI(terrain: any, terrainLayer: any, terrainLayerEditor: jsb.Ref<Editor>, customGUI: ITerrainLayerCustomUI): void
        /** Checks whether the texture is a valid TerrainLayer diffuse texture. If it detects that the texture is not valid, it displays a warning message that identifies the issue.
         * @param texture The texture to validate.
         */
        static ValidateDiffuseTextureUI(texture: Texture2D): void
        /** Checks whether the texture is correctly imported as a normal map texture.
         * @param texture The texture to check.
         * @returns True if texture is correctly imported, otherwise false. 
         */
        static CheckNormalMapTextureType(texture: Texture2D): boolean
        /** Checks whether the texture is a valid TerrainLayer normal map texture. If it detects that the texture is not valid, it displays a warning message that identifies the issue.
         * @param texture The texture to validate.
         * @param normalMapTextureType The return value from the CheckNormalMapTextureType method indicating whether the texture is imported as a normal map.
         */
        static ValidateNormalMapTextureUI(texture: Texture2D, normalMapTextureType: boolean): void
        /** Checks whether the texture is a valid TerrainLayer mask map texture. If it detects that the texture is not valid, it displays a warning message that identifies the issue.
         * @param texture The texture to validate.
         */
        static ValidateMaskMapTextureUI(texture: Texture2D): void
        /** Displays the tiling settings UI.
         * @param terrainLayer The terrain layer that contains the tiling settings to display.
         * @param tileSize The tile size property to display.
         * @param tileOffset The tile offset property to display.
         */
        static TilingSettingsUI(tileSize: SerializedProperty, tileOffset: SerializedProperty): void
        /** Displays the tiling settings UI.
         * @param terrainLayer The terrain layer that contains the tiling settings to display.
         * @param tileSize The tile size property to display.
         * @param tileOffset The tile offset property to display.
         */
        static TilingSettingsUI(terrainLayer: any): void
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Texture case constants for TrueTypeFontImporter.
     */
    enum FontTextureCase {
        /** Import basic ASCII character set.
         */
        ASCII = 0,
        /** Only import upper case ASCII character set.
         */
        ASCIIUpperCase = 1,
        /** Only import lower case ASCII character set.
         */
        ASCIILowerCase = 2,
        /** Custom set of characters.
         */
        CustomSet = 3,
        /** Render characters into font texture at runtime as needed.
         */
        Dynamic = -2,
        /** Import a set of Unicode characters common for latin scripts.
         */
        Unicode = -1,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Font rendering mode constants for TrueTypeFontImporter.
     */
    enum FontRenderingMode {
        /** Use Anti-Aliased Font rendering. When using dynamic fonts, this is the mode which is fastest in rendering font textures.
         */
        Smooth = 0,
        /** Use Anti-Aliased Font rendering with hinting. This forces character lines to run along pixel boundaries.
         */
        HintedSmooth = 1,
        /** Use hinted font rendering without anti-aliasing. This is the crispest font rendering option, and may be most readable for small font sizes.
         */
        HintedRaster = 2,
        /** Use the OS default font rendering mode. This mode is only available for dynamic fonts, as static fonts are generated at build time.
         */
        OSDefault = 3,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    /** Method used for calculating a font's ascent.
     */
    enum AscentCalculationMode {
        /** Legacy bounding box method.
         */
        Legacy2x = 0,
        /** Ascender method.
         */
        FaceAscender = 1,
        /** Bounding box method.
         */
        FaceBoundingBox = 2,
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Array } from "System";
    import { Object } from "UnityEngine";
    /** AssetImporter for importing Fonts.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TrueTypeFontImporter extends AssetImporter {
        constructor()
        /** Create an editable copy of the font asset at path.
         */
        GenerateEditableFont(path: string): any
        /** Font size to use for importing the characters.
         */
        fontSize: number
        /** If this is enabled, the actual font will be embedded into the asset for Dynamic fonts.
         */
        includeFontData: boolean
        /** Calculation mode for determining font's ascent.
         */
        ascentCalculationMode: AscentCalculationMode
        /** A custom set of characters to be included in the Font Texture.
         */
        customCharacters: string
        /** Spacing between character images in the generated texture in pixels. This is useful if you want to render text using a shader which samples pixels outside of the character area (like an outline shader).
         */
        characterSpacing: number
        /** Border pixels added to character images for padding. This is useful if you want to render text using a shader which needs to render outside of the character area (like an outline shader).
         */
        characterPadding: number
        /** Font rendering mode to use for this font.
         */
        fontRenderingMode: FontRenderingMode
        /** Set this property to true if you want to round the internal advance width of the font to the nearest integer.
         */
        shouldRoundAdvanceValue: boolean
        /** The internal font name of the TTF file.
         */
        readonly fontTTFName: string
        /** Use this to adjust which characters should be imported.
         */
        fontTextureCase: FontTextureCase
        /** References to other fonts to be used looking for fallbacks.
         */
        fontReferences: Array<any>
        /** An array of font names, to be used when includeFontData is set to false.
         */
        fontNames: Array<string>
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { ScriptableObject, Vector3 } from "UnityEngine";
    import { Enum } from "System";
    /** GridPalette stores settings for Palette assets when shown in the Palette window.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GridPalette extends ScriptableObject {
        constructor()
        /** Determines the Transparency Sorting Mode of Renderers in the Palette.
         */
        transparencySortMode: any
        /** Determines the sorting axis if the Transparency Sort Mode is set to Custom Axis.
         */
        transparencySortAxis: Vector3
        /** Determines the sizing of cells for a Palette.
         */
        cellSizing: GridPalette.CellSizing
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    namespace GridPalette {
        enum CellSizing {
            Automatic = 0,
            Manual = 100,
        }
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** Editor API for the EditorAnalytics feature.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorAnalytics extends Object {
        /** This API is used for registering an Editor Analytics event. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param ver Event version number.
         * @param maxEventPerHour Hourly limit for this event name.
         * @param maxItems Maximum number of items in this event.
         * @param vendorKey Vendor key name.
         */
        static RegisterEventWithLimit(eventName: string, maxEventPerHour: number, maxItems: number, vendorKey: string, ver: number): any
        /** This API is used for registering an Editor Analytics event. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param ver Event version number.
         * @param maxEventPerHour Hourly limit for this event name.
         * @param maxItems Maximum number of items in this event.
         * @param vendorKey Vendor key name.
         */
        static RegisterEventWithLimit(eventName: string, maxEventPerHour: number, maxItems: number, vendorKey: string): any
        /** This API is used to send an Editor Analytics event. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param parameters Additional event data.
         * @param ver Event version number.
         */
        static SendEventWithLimit(eventName: string, parameters: Object, ver: number): any
        /** This API is used to send an Editor Analytics event. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param parameters Additional event data.
         * @param ver Event version number.
         */
        static SendEventWithLimit(eventName: string, parameters: Object): any
        /** Use this API to set the event end point URL. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param ver Event version number.
         * @param endPoint Event end point URL.
         */
        static SetEventWithLimitEndPoint(eventName: string, endPoint: string, ver: number): any
        /** Use the API to set the event property. Note: This API is for internal use only and is likely change in the future. Do not use in user code.
         * @param eventName Name of the event.
         * @param ver Event version number.
         * @param eventPriority Event priority.
         */
        static SetEventWithLimitPriority(eventName: string, eventPriority: any, ver: number): any
        /** Returns true when EditorAnalytics is enabled.
         */
        static enabled: boolean
    }
}
declare module "UnityEditor" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Provides access to Editor Analytics session information.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorAnalyticsSessionInfo extends Object {
        /** A random, unique GUID identifying the current Editor session.
         */
        static readonly id: number
        /** The number of Editor sessions that have occurred since the current instance of the Unity Editor was installed.
         */
        static readonly sessionCount: number
        /** The length of the current session, in milliseconds.
         */
        static readonly elapsedTime: number
        /** The total time, in milliseconds, that the Editor has been in focus during the current session.
         */
        static readonly focusedElapsedTime: number
        /** The total time, in milliseconds, that the Editor has been in playmode during the current session.
         */
        static readonly playbackElapsedTime: number
        /** The total time, in milliseconds, that the user interacted with the Editor since the beginning of the current session.
         */
        static readonly activeElapsedTime: number
        /** A random GUID uniquely identifying an Editor installation.
         */
        static readonly userId: string
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    /** Enum that represents the events a RoleProvider can receive.
     */
    enum ProcessEvent {
        UMP_EVENT_UNDEFINED = 0,
        Undefined = 0,
        UMP_EVENT_CREATE = 1,
        Create = 1,
        UMP_EVENT_INITIALIZE = 2,
        Initialize = 2,
        /** Domain reload occurs.
         */
        UMP_EVENT_AFTER_DOMAIN_RELOAD = 3,
        /** Domain reload occurs.
         */
        AfterDomainReload = 3,
        UMP_EVENT_SHUTDOWN = 4,
        Shutdown = 4,
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    /** The type of the current process. It can be a Unity master instance, or a secondary instance connected to the master.
     */
    enum ProcessLevel {
        UMP_UNDEFINED = 0,
        Undefined = 0,
        /** The current process is a main instance of UnityEditor.
         */
        UMP_MASTER = 1,
        /** The current process is a main instance of UnityEditor.
         */
        Main = 1,
        UMP_SLAVE = 2,
        Slave = 2,
        Secondary = 2,
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    /** Describes the state of a specifc UnityEditor process.
     */
    enum ProcessState {
        /** The queried UnityEditor process is unknown.
         */
        UMP_UNKNOWN_PROCESS = 0,
        /** The queried UnityEditor process is unknown.
         */
        UnknownProcess = 0,
        /** The queried UnityEditor process ended successfully.
         */
        UMP_FINISHED_SUCCESSFULLY = 1,
        /** The queried UnityEditor process ended successfully.
         */
        FinishedSuccessfully = 1,
        /** The queried UnityEditor process finished with an error.
         */
        UMP_FINISHED_WITH_ERROR = 2,
        /** The queried UnityEditor process finished with an error.
         */
        FinishedWithError = 2,
        UMP_RUNNING = 3,
        Running = 3,
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    /** A structure that contains the connection information of a Channel in ChannelService.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChannelInfo extends ValueType {
        constructor()
        Equals(obj: ChannelInfo): boolean
        Equals(obj: Object): boolean
        GetHashCode(): number
        static op_Equality(x: ChannelInfo, y: ChannelInfo): boolean
        static op_Inequality(x: ChannelInfo, y: ChannelInfo): boolean
        // js_op_overloading: static ==(x: ChannelInfo, y: ChannelInfo): boolean
        /** The name of the channel. This matches the route of the URL that connects to the ChannelService. For example, "127.0.0.1:9292/<channelName>".
         */
        readonly name: string
        /** The ID of a specific channel. Normally this is the hash of the channel name.
         */
        readonly id: number
        static invalidChannel: ChannelInfo
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    /** A structure that contains all of a ChannelClient's connection data.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChannelClientInfo extends ValueType {
        constructor()
        Equals(obj: ChannelClientInfo): boolean
        Equals(obj: Object): boolean
        GetHashCode(): number
        static op_Equality(x: ChannelClientInfo, y: ChannelClientInfo): boolean
        static op_Inequality(x: ChannelClientInfo, y: ChannelClientInfo): boolean
        // js_op_overloading: static ==(x: ChannelClientInfo, y: ChannelClientInfo): boolean
        /** The ChannelClient's name (see ChannelClient.channelName. This matches the route of the URL connecting to the ChannelService. For example, "127.0.0.1:9292/<channelName>".
         */
        readonly name: string
        /** The channel's channel ID (see ChannelClient.clientId).
         */
        readonly clientId: number
        /** The ChannelClient's connection ID.
         */
        readonly connectionId: number
        static invalidClient: ChannelClientInfo
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    /** The ChannelService encapsulates a WebSocket server running in Unity.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ChannelService extends Object {
        static GetAddress(): string
        static GetPort(): number
        static Start(): void
        static Stop(): void
        static IsRunning(): boolean
        static GetChannelList(): Array<ChannelInfo>
        static GetChannelClientList(): Array<ChannelClientInfo>
        /** Sends a message to all  of a specific channel's ChannelClient connections.
         * @param channelId The ID of the channel to send the message to.
         * @param data The message to send. It can be binary or UTF8.
         */
        static Broadcast(channelId: number, data: string): void
        /** Sends a message to all  of a specific channel's ChannelClient connections.
         * @param channelId The ID of the channel to send the message to.
         * @param data The message to send. It can be binary or UTF8.
         */
        static Broadcast(channelId: number, data: Array<jsb.byte>): void
        /** Sends a message to all  of a specific channel's ChannelClient connections.
         * @param channelId The ID of the channel to send the message to.
         * @param data The binary data to send.
         */
        static BroadcastBinary(channelId: number, data: Array<jsb.byte>): void
        /** Sends a message to a specific connection. The message can be binary or UTF8.
         * @param connectionId The connection ID. This matches ChannelClientInfo.channelClientId.
         * @param data Data to send to the connected client.
         */
        static Send(connectionId: number, data: string): void
        /** Sends a message to a specific connection. The message can be binary or UTF8.
         * @param connectionId The connection ID. This matches ChannelClientInfo.channelClientId.
         * @param data Data to send to the connected client.
         */
        static Send(connectionId: number, data: Array<jsb.byte>): void
        /** Closes a specific channel and all connections to that channel.
         * @param channelName The ChannelName.
         * @returns The ChannelId. 
         */
        static ChannelNameToId(channelName: string): number
        static GetOrCreateChannel(channelName: string, handler: (arg1: number, arg2: Array<jsb.byte>) => void): () => void
        static RegisterMessageHandler(channelName: string, handler: (arg1: number, arg2: Array<jsb.byte>) => void): () => void
        static UnregisterMessageHandler(channelName: string, handler: (arg1: number, arg2: Array<jsb.byte>) => void): void
        /** Closes a specific channel and all connections to that channel.
         * @param channelName The name of the channel to close.
         */
        static CloseChannel(channelName: string): void
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    /** ChannelClient is a WebSocket client that connects to Unity's ChannelService, which is a WebSocket server.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChannelClient extends Object {
        IsConnected(): boolean
        /** Starts an existing ChannelClient so it listens to incoming and outgoing messages.
         * @param autoTick Specifies whether Unity processes (ticks) this ChannelClient's incoming and outgoing messages automatically, or the user processes (ticks) them manually, either in the main thread or a dedicated thread.
         */
        Start(autoTick: boolean): void
        Stop(): void
        Close(): void
        Tick(): void
        /** Sends an ASCII or binary message to the ChannelService. Depending on how the channel's handler processes the message, it may also be sent to other connections.
         * @param data Data to send.
         * @param connectionId The connection ID of the client sending the data.
         */
        Send(data: string): void
        /** Sends an ASCII or binary message to the ChannelService. Depending on how the channel's handler processes the message, it may also be sent to other connections.
         * @param data Data to send.
         * @param connectionId The connection ID of the client sending the data.
         */
        Send(data: Array<jsb.byte>): void
        RegisterMessageHandler(handler: (obj: string) => void): () => void
        RegisterMessageHandler(handler: (obj: Array<jsb.byte>) => void): () => void
        UnregisterMessageHandler(handler: (obj: string) => void): void
        UnregisterMessageHandler(handler: (obj: Array<jsb.byte>) => void): void
        NewRequestId(): number
        GetChannelClientInfo(): ChannelClientInfo
        /** Creates a unique request ID for this ChannelClient in this instance of Unity. For more information about requests, see ChannelClient.Request.
         * @param clientId The ChannelClient ID to generate the request from.
         * @returns The request ID. 
         */
        static NewRequestId(clientId: number): number
        /** Gets the ChannelClientInfo for a specific channel.
         * @param channelName The name of the channel to get information about.
         * @param clientId The ID of the channel to get information about.
         * @returns A structure that describes the channel. 
         */
        static GetChannelClientInfo(clientId: number): ChannelClientInfo
        /** Gets the ChannelClientInfo for a specific channel.
         * @param channelName The name of the channel to get information about.
         * @param clientId The ID of the channel to get information about.
         * @returns A structure that describes the channel. 
         */
        static GetChannelClientInfo(channelName: string): ChannelClientInfo
        static GetChannelClientList(): Array<ChannelClientInfo>
        /** Sends an ASCII or binary message to the ChannelService. Depending on how the channel's handler processes the message, it may also be sent to other connections.
         * @param data Data to send.
         * @param connectionId The connection ID of the client sending the data.
         */
        static Send(connectionId: number, data: Array<jsb.byte>): void
        /** Closes the ChannelClient. This closes the WebSocket client but not the Channel in the ChannelService. Other ChannelClients can still connect on the same Channel.
         * @param channelName The name of the channel to close.
         */
        static Close(channelName: string): void
        /** Creates a new ChannelClient on a specific channel. If a client already exists, this method gets the client.
         * @param channelName The name of the channel to open. This matches the last part of a WebSocket URL. For example, "127.0.0.1:9090/<channelName>".
         * @returns Instance of the newly-created or existing ChannelClient. 
         */
        static GetOrCreateClient(channelName: string): ChannelClient
        static Shutdown(): void
        protected constructor()
        /** The channel ID, which essentially a hash of the channel name. See ChannelService.ChannelNameToId.
         */
        readonly clientId: number
        /** The name of the channel this ChannelClient is connected to. The name matches the route of the URL used to connect to Unity's ChannelService. For example, 127.0.0.1:8928/<my Channel Name>.
         */
        readonly channelName: string
        /** Specifies whether Unity processes (ticks) this ChannelClient's incoming and outgoing messages automatically, or the user processes (ticks) them manually, either in the main thread or a dedicated thread.
         */
        readonly isAutoTick: boolean
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { PropertyModification } from "UnityEditor";
    import { Object as Object1 } from "UnityEngine";
    /** *This is an experimental feature.* The ProcessService allows you to start slave instance of UnityEditor, opened to the same Project as the master instance, with a specific RoleProviderAttribute.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ProcessService extends Object {
        constructor()
        static IsChannelServiceStarted(): boolean
        /** A utility function to read command line arguments passed to the current process.
         * @param paramName Specific name of a command line parameter.
         * @returns The parameter value. If empty, the parameter wasn't used on the command line. 
         */
        static ReadParameter(paramName: string): string
        /** Launches a secondary instance of UnityEditor on the same project as the master instance.
         * @param roleName The name that corresponds to the RoleProviderAttribute of the process to start.
         * @param keyValuePairs Arguments passed to the slave process.
         * @returns The process ID of the slave process. A value of 0 means the slave process could not be started. 
         */
        static Launch(roleName: string, ...keyValuePairs: string[]): number
        /** Terminates an editor process.
         * @param pid The process ID of the process to terminate.
         */
        static Terminate(pid: number): void
        /** Gets the ProcessState of a given instance of UnityEditor.
         * @param pid The process ID.
         * @returns The state of the queried process. 
         */
        static GetProcessState(pid: number): ProcessState
        /** Checks whether the current process has a given capability.
         * @param capName The capability name.
         * @returns True if the process has the capability. False otherwise. 
         */
        static HasCapability(capName: string): boolean
        static ApplyPropertyModifications(modifications: Array<PropertyModification>): void
        static SerializeObject(instanceId: number): Array<jsb.byte>
        static DeserializeObject(bytes: Array<jsb.byte>): Object1
        /** Enables a connection to the Profiler. The standalone Profiler uses this method.
         * @param dataPath Where to save profiling data. Normally this is set to Application.dataPath.
         * @returns Greater than 0 if successful. 
         */
        static EnableProfileConnection(dataPath: string): number
        static DisableProfileConnection(): void
        /** The ProcessLevel of the running instance of UnityEditor.
         */
        static readonly level: ProcessLevel
        /** The role name of the running UnityEditor process. For more information about how to register handlers for a specific process role, see RoleProviderAttribute. For a UnityEditor process of ProcessLevel Master, the roleName is always empty.
         */
        static readonly roleName: string
        static ProcessExitedEvent(op: "add" | "remove", fn: (arg1: number, arg2: ProcessState) => void): void
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    /** The Serialization type for sending a message, with arguments, using the EventService. For more information about argument serialization, see ChannelService.Broadcast and ChannelService.Emit.
     */
    enum EventDataSerialization {
        /** Use normal JSON to send a message using the [[EventService]. The receiving handler gets JSON objects (Dictionary<string, object>, List<object>, primitive types) as arguments of his ChannelHandler.
         */
        StandardJson = 0,
        /** Use JsonUtility.ToJson to serialize a message argument. Additional metadata is added to the message to specify which type to convert the JSON to when it is received.
         */
        JsonUtility = 1,
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { Object, Array, Exception, Enum } from "System";
    /** The EventService is a singleton implementation of a ChannelClient that runs on all instances of Unity. It is connected to the "events" channel and allows a Unity instance to send JSON messages to other EventServices in external process, or other instances of Unity.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EventService extends Object {
        static Start(): void
        static Close(): void
        static RegisterEventHandler(eventType: string, handler: (arg1: string, arg2: Array<Object>) => void): () => void
        static RegisterEventHandler(eventType: string, handler: (arg1: string, arg2: Array<Object>) => Object): () => void
        static UnregisterEventHandler(eventType: string, handler: (arg1: string, arg2: Array<Object>) => Object): void
        static Clear(): void
        /** Sends a fire-and-forget message to all ChannelClients connected to the "events" route.
         * @param eventType The message's type name.
         * @param args The arguments sent with the message.
         * @param targetId When you send the event to a specific connection, this is the connection ID. By default it is set to -1, which sends the message to all other EventServices.
         * @param eventDataSerialization Specifies how to serialize the request's arguments. This can be standard JSON, or JSON annotated with JsonUtility. You can use the latter to convert the argument to a concrete Unity object that supports JsonUtility.FromJson.
         */
        static Emit(eventType: string, args: Object, targetId: number, eventDataSerialization: EventDataSerialization): void
        /** Sends a fire-and-forget message to all ChannelClients connected to the "events" route.
         * @param eventType The message's type name.
         * @param args The arguments sent with the message.
         * @param targetId When you send the event to a specific connection, this is the connection ID. By default it is set to -1, which sends the message to all other EventServices.
         * @param eventDataSerialization Specifies how to serialize the request's arguments. This can be standard JSON, or JSON annotated with JsonUtility. You can use the latter to convert the argument to a concrete Unity object that supports JsonUtility.FromJson.
         */
        static Emit(eventType: string, args: Array<Object>, targetId: number, eventDataSerialization: EventDataSerialization): void
        /** Checks whether a request is pending on a specific event. For more information about Request, see EventService.Request.
         * @param eventType Event type name.
         * @returns True if there is a pending request for this event. False otherwise. 
         */
        static IsRequestPending(eventType: string): boolean
        /** Checks whether there is a pending request for a specific event and, if there is, cancels it. See EventService.Request for more details on Request.
         * @param eventType The event to cancel.
         * @param message The error message sent to the pending request.
         * @returns Returns true if a pending request was found and cancelled false otherwise. 
         */
        static CancelRequest(eventType: string, message: string): boolean
        static Request(eventType: string, promiseHandler: (arg1: Exception, arg2: Array<Object>) => void, args: Object, timeoutInMs: number, eventDataSerialization: EventDataSerialization): void
        static Request(eventType: string, promiseHandler: (arg1: Exception, arg2: Array<Object>) => void, args: Array<Object>, timeoutInMs: number, eventDataSerialization: EventDataSerialization): void
        /** Sends a log message to the ChannelService. Log messages are printed to the Console window.
         * @param msg The message to send.
         * @param logType The type of the message (i.e. Info, Warning or Error).
         */
        static Log(msg: string, logType: any): void
        /** Sends a log message to the ChannelService. Log messages are printed to the Console window.
         * @param msg The message to send.
         * @param logType The type of the message (i.e. Info, Warning or Error).
         */
        static Log(msg: string): void
        static Tick(): void
        /** The EventService connected to the ChannelService's "events" channel.
         */
        static readonly isConnected: boolean
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Scope that can be use to open a channel client on a specific channel and close the channel when the scope ends.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChannelClientScope extends ValueType {
        constructor(autoTick: boolean, channelName: string, handler: (obj: string) => void, closeClientOnExit: boolean)
        constructor(autoTick: boolean, channelName: string, handler: (obj: Array<jsb.byte>) => void, closeClientOnExit: boolean)
        Dispose(): void
        /** Get the Chanel client of this scope.
         */
        readonly client: ChannelClient
    }
}
declare module "UnityEditor.MPE" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Scope that cna be use to open a channel and that will close the channel when the scope ends.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ChannelScope extends ValueType {
        constructor(channelName: string, handler: (arg1: number, arg2: Array<jsb.byte>) => void, closeChannelOnExit: boolean)
        Dispose(): void
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** The shortcut context that is active while editing Terrain.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TerrainToolShortcutContext extends Object {
        protected constructor()
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Material } from "UnityEngine";
    /** Utility class for Terrain Inspector GUI.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TerrainInspectorUtility extends Object {
        /** Checks whether a Material is compatible with Terrain.
         * @param material The Material to validate.
         */
        static TerrainShaderValidationGUI(material: Material): void
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    /** Enum to specify whether DrawBrushPreview previews the source render texture or the destination render texture of a PaintContext.
     */
    enum TerrainBrushPreviewMode {
        /** Specifies that TerrainTools.TerrainPaintUtilityEditor.DrawBrushPreview uses the source render texture of the PaintContext.
         */
        SourceRenderTexture = 0,
        /** Specifies that TerrainTools.TerrainPaintUtilityEditor.DrawBrushPreview uses the destination render texture of the PaintContext.
         */
        DestinationRenderTexture = 1,
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { Behaviour, Texture, Material } from "UnityEngine";
    /** Terrain paint utility editor helper functions.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TerrainPaintUtilityEditor extends Object {
        /** Helper function to display a default preview brush with no rotation or custom materials.
         * @param terrain Terrain object.
         * @param brushTexture Brush texture.
         * @param brushSize Brush size.
         */
        static ShowDefaultPreviewBrush(terrain: any, brushTexture: Texture, brushSize: number): void
        static GetDefaultBrushPreviewMaterial(): Material
        static DrawBrushPreview(heightmapPC: any, previewTexture: TerrainBrushPreviewMode, brushTexture: Texture, brushXform: any, proceduralMaterial: Material, materialPassIndex: number): void
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    /** Flags that specify which brush controls the [IOnInspectorGUI.ShowBrushesGUI] method displays.
     */
    enum BrushGUIEditFlags {
        /** Don't display any brush controls.
         */
        None = 0,
        /** Display the brush selection control.
         */
        Select = 1,
        /** Display the brush inspector for the currently selected brush.
         */
        Inspect = 2,
        /** Display the brush selection control, and the brush inspector for the currently selected brush.
         */
        SelectAndInspect = 3,
        /** Display the brush size control.
         */
        Size = 4,
        /** Display the brush opacity control.
         */
        Opacity = 8,
        /** Display all brush controls.
         */
        All = 15,
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    /** Flags that indicate what to repaint on the Terrain tools.
     */
    enum RepaintFlags {
        /** Repaint the tool UI.
         */
        UI = 1,
        /** Repaint the Scene view.
         */
        Scene = 2,
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    import { Texture, Vector2, RaycastHit } from "UnityEngine";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IOnPaint {
        /** Instructs the Editor to repaint the tool UI, the Scene view, or both.
         * @param flags Specifies what to repaint.
         */
        Repaint(flags: RepaintFlags): void
        /** Read only. Current selected brush texture.
         */
        readonly brushTexture: Texture
        /** Read only. The normalized position (between 0 and 1) on the active Terrain.
         */
        readonly uv: Vector2
        /** Read only. Current brush strength.
         */
        readonly brushStrength: number
        /** Read only. Current brush size in Terrain units (equivalent size to world units).
         */
        readonly brushSize: number
        /** Read only. True if the mouse is over a valid Terrain object; otherwise false.
         */
        readonly hitValidTerrain: boolean
        /** Read only. The raycast result for the current mouse position.  This is valid when hitValidTerrain is true.
         */
        readonly raycastHit: RaycastHit
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    import { SceneView } from "UnityEditor";
    import { Texture, RaycastHit } from "UnityEngine";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IOnSceneGUI {
        /** Instructs the Editor to repaint the tool UI, the Scene view, or both.
         * @param flags Specifies what to repaint.
         */
        Repaint(flags: RepaintFlags): void
        /** Read only. SceneView object.
         */
        readonly sceneView: SceneView
        /** Read only. Current selected brush texture.
         */
        readonly brushTexture: Texture
        /** Read only. Current brush strength.
         */
        readonly brushStrength: number
        /** Read only. Current brush size in terrain units (equivalent size to world units).
         */
        readonly brushSize: number
        /** Read only. True if the mouse is over a valid Terrain object; otherwise false.
         */
        readonly hitValidTerrain: boolean
        /** Read only. The raycast result for the current mouse position.  This is valid when hitValidTerrain is true.
         */
        readonly raycastHit: RaycastHit
        /** The control ID for the current Terrain Inspector. (Read Only)
         */
        readonly controlId: number
    }
}
declare module "UnityEditor.TerrainTools" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IOnInspectorGUI {
        /** Displays the default controls for the brush in the tool inspector.
         * @param spacing Pixel spacing for the brush GUI controls.
         * @param flags Specifies which brush controls to display in the Terrain tool UI.
         * @param textureResolutionPerTile The resolution per Terrain tile of the Texture, which the tool is editing.  Unity uses this value to calculate Brush size limits.
         */
        ShowBrushesGUI(spacing: number, flags: BrushGUIEditFlags, textureResolutionPerTile: number): void
        /** Instructs the Editor to repaint the tool UI and/or the scene view.
         * @param flags What to repaint.
         */
        Repaint(flags: RepaintFlags): void
    }
}
declare module "UnityEditor.Licensing.UI.Events.Handlers" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class INotificationHandler extends Object {
        Handle(isHumanControllingUs: boolean): void
        HandleUI(): void
        HandleBatchmode(): void
    }
}
declare module "UnityEditor.Analytics" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Normally performance reporting is enabled from the Services window, but if writing your own editor extension, this API can be used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PerformanceReportingSettings extends Object {
        /** This Boolean field causes the performance reporting feature in Unity to be enabled if true, or disabled if false.
         */
        static enabled: boolean
    }
}
declare module "UnityEditor.Analytics" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Editor API for the Unity Services editor feature. Normally Analytics is enabled from the Services window, but if writing your own editor extension, this API can be used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class AnalyticsSettings extends Object {
        /** If set to true, this Boolean field enables the Analytics feature in Unity. It disables the feature if it is set to false.
         */
        static enabled: boolean
        /** Set to true for testing Analytics integration only within the Editor.
         */
        static testMode: boolean
        /** Controls whether Unity initializes Analytics immediately on startup.
         */
        static initializeOnStartup: boolean
        /** Reports whether device stats are enabled at runtime.
         */
        static readonly deviceStatsEnabledInBuild: boolean
        static packageRequiringCoreStatsPresent: boolean
        /** Set the Analytics event end point.
         */
        static eventUrl: string
        /** Set the Analytics config end point.
         */
        static configUrl: string
        /** Get the Analytics dashboard endpoint.
         */
        static dashboardUrl: string
        static OnRequireInBuildHandler(op: "add" | "remove", fn: () => boolean): void
    }
}
declare module "UnityEditor.Purchasing" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Editor API for the Unity Services editor feature. Normally Purchasing is enabled from the Services window, but if writing your own editor extension, this API can be used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PurchasingSettings extends Object {
        /** This Boolean field will cause the Purchasing feature in Unity to be enabled if true, or disabled if false.
         */
        static enabled: boolean
    }
}
declare module "UnityEditor.Advertisements" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** Editor API for the Unity Services editor feature. Normally UnityAds is enabled from the Services window, but if writing your own editor extension, this API can be used.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class AdvertisementSettings extends Object {
        /** Gets the game identifier specified for a runtime platform.
         * @returns The platform specific game identifier. 
         */
        static GetGameId(platform: any): string
        /** Sets the game identifier for the specified platform.
         */
        static SetGameId(platform: any, gameId: string): void
        /** Gets the game identifier specified for a runtime platform.
         * @returns The platform specific game identifier. 
         */
        static GetPlatformGameId(platformName: string): string
        /** Sets the game identifier for the specified platform.
         */
        static SetPlatformGameId(platformName: string, gameId: string): void
        /** Global boolean for enabling or disabling the advertisement feature.
         */
        static enabled: boolean
        /** Controls if testing advertisements are used instead of production advertisements.
         */
        static testMode: boolean
        /** Controls if the advertisement system should be initialized immediately on startup.
         */
        static initializeOnStartup: boolean
    }
}
declare module "UnityEditor.Toolbars" {
    import * as jsb from "jsb";
    import { EditorWindow } from "UnityEditor";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IAccessContainerWindow {
        /** EditorToolbar's container EditorWindow.
         */
        containerWindow: EditorWindow
    }
}
declare module "UnityEditor.Toolbars" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Editor utility functions when working with EditorToolbar.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorToolbarUtility extends Object {
        /** Assigns the required USS classes to child elements so that they appear as a single button strip.
         * @param root Root VisualElement of the button strip.
         */
        static SetupChildrenAsButtonStrip(root: any): void
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Rational number useful for expressing fractions precisely.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MediaRational extends ValueType {
        constructor(numerator: number, denominator: number)
        constructor(numerator: number)
        /** Sets the numerator and denominator, performing normalization.
         * @param numerator New value for the rational numerator.
         * @param denominator New value for the rational denominator.
         */
        Set(numerator: number, denominator: number): void
        static op_Explicit(r: MediaRational): number
        /** The inverse of the rational number.
         */
        readonly inverse: MediaRational
        /** Whether the rational number is valid.
         */
        readonly isValid: boolean
        /** Whether the rational number is zero.
         */
        readonly isZero: boolean
        /** Whether the rational number is negative.
         */
        readonly isNegative: boolean
        /** Invalid rational value.
         */
        static readonly Invalid: MediaRational
        /** Fraction numerator.
         */
        numerator: number
        /** Fraction denominator.
         */
        denominator: number
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Time representation for use with media containers.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MediaTime extends ValueType {
        constructor(count: number, rateNumerator: number, rateDenominator: number)
        constructor(seconds: number)
        static op_Explicit(t: MediaTime): number
        /** The sample count for the time value.
         */
        count: number
        /** The rate used for converting the count into seconds.
         */
        rate: MediaRational
        /** Invalid time value.
         */
        static readonly Invalid: MediaTime
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { VideoEncodingProfile } from "UnityEditor";
    /** Descriptor for H.264 encoder attributes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class H264EncoderAttributes extends ValueType {
        constructor()
        /** The maximum size of a group of pictures, in frames.
         */
        gopSize: number
        /** The maximum number of consecutive B frames between I and P frames.
         */
        numConsecutiveBFrames: number
        /** The VideoEncodingProfile for the encoded video.
         */
        profile: VideoEncodingProfile
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Descriptor for VP8 encoder attributes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VP8EncoderAttributes extends ValueType {
        constructor()
        /** The maximum distance between I-frames.
         */
        keyframeDistance: number
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { VideoBitrateMode } from "UnityEditor";
    /** Descriptor for video track format.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VideoTrackEncoderAttributes extends ValueType {
        constructor(h264Attrs: H264EncoderAttributes)
        constructor(vp8Attrs: VP8EncoderAttributes)
        /** The frame rate for the encoded video, in frames per second, expressed as a fraction.
         */
        frameRate: MediaRational
        /** The image width in pixels.
         */
        width: number
        /** The image height in pixels.
         */
        height: number
        /** The target bit rate for the encoder.
         */
        targetBitRate: number
        /** The VideoBitrateMode for the encoded video.
         */
        bitRateMode: VideoBitrateMode
        /** True if the track is to include the alpha channel found in the texture passed to AddFrame. False otherwise.
         */
        includeAlpha: boolean
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { VideoBitrateMode } from "UnityEditor";
    /** Descriptor for audio track format.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class VideoTrackAttributes extends ValueType {
        constructor()
        /** Frames per second.
         */
        frameRate: MediaRational
        /** Image width in pixels.
         */
        width: number
        /** Image height in pixels.
         */
        height: number
        /** True if the track is to include the alpha channel found in the texture passed to AddFrame. False otherwise.
         */
        includeAlpha: boolean
        /** VideoBitrateMode for the encoded video.
         */
        bitRateMode: VideoBitrateMode
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Descriptor for audio track format.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AudioTrackAttributes extends ValueType {
        constructor()
        /** Audio sampling rate.
         */
        sampleRate: MediaRational
        /** Number of channels.
         */
        channelCount: number
        /** Dialogue language, if applicable.  Can be empty.
         */
        language: string
    }
}
declare module "UnityEditor.Media" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Texture2D } from "UnityEngine";
    /** Encodes images and audio samples into an audio or movie file.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MediaEncoder extends Object {
        constructor(filePath: string, videoAttrs: VideoTrackAttributes, audioAttrs: Array<AudioTrackAttributes>)
        constructor(filePath: string, videoAttrs: VideoTrackEncoderAttributes, audioAttrs: Array<AudioTrackAttributes>)
        constructor(filePath: string, videoAttrs: VideoTrackEncoderAttributes, audioAttrs: AudioTrackAttributes)
        constructor(filePath: string, videoAttrs: VideoTrackAttributes, audioAttrs: AudioTrackAttributes)
        constructor(filePath: string, videoAttrs: VideoTrackEncoderAttributes)
        constructor(filePath: string, videoAttrs: VideoTrackAttributes)
        constructor(filePath: string, audioAttrs: Array<AudioTrackAttributes>)
        constructor(filePath: string, audioAttrs: AudioTrackAttributes)
        /** Appends a frame to the file's video track.
         * @param texture Texture containing the pixels to be written into the track for the current frame.
         * @param time Timestamp for the new frame.
         * @returns True if the operation succeeded. False otherwise. 
         */
        AddFrame(texture: Texture2D, time: MediaTime): boolean
        /** Appends a frame to the file's video track.
         * @param texture Texture containing the pixels to be written into the track for the current frame.
         * @param time Timestamp for the new frame.
         * @returns True if the operation succeeded. False otherwise. 
         */
        AddFrame(texture: Texture2D): boolean
        Dispose(): void
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Registers an EditorTool as either a Global tool or a Component tool for a specific target type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorToolAttribute extends Object {
        constructor(displayName: string, componentToolTarget: any, editorToolContext: any)
        constructor(displayName: string, componentToolTarget: any)
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Registers an EditorToolContext as either a global context or a Component context  for a specific target type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorToolContextAttribute extends Object {
        constructor(displayName: string, targetType: any)
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    import { ScriptableObject, Object } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    import { EditorWindow, Tool } from "UnityEditor";
    import { Object as Object1 } from "System";
    /** Use this class to implement specialized versions of the built-in transform tools. Built-in transform tools include Move, Rotate, Scale, Rect, and Transform.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorToolContext extends ScriptableObject {
        OnActivated(): void
        OnWillBeDeactivated(): void
        /** Implements any common functionality for the set of manipulation tools available for this context.
         * @param window The window that is displaying the active EditorTool.
         */
        OnToolGUI(window: EditorWindow): void
        /** Returns the matching EditorTool type for the specified Tool given the context.
         * @param tool The Tool to resolve to an EditorTool type.
         * @returns An EditorTool type for the requested Tool. 
         */
        ResolveTool(tool: Tool): any
        /** An array of the objects being inspected.
         */
        readonly targets: any
        /** The object being inspected.
         */
        readonly target: Object
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    /** This class represents the default context for manipulation tools. When GameObjectToolContext is active, manipulation tools affect the transform property of GameObjects in the SceneView Selection.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class GameObjectToolContext extends EditorToolContext {
        protected constructor()
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** This class manipulates editor tools in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ToolManager extends Object {
        /** Sets the active EditorToolContext.
         * @param context The EditorToolContext type to be set as the active tool.
         */
        static SetActiveContext(context: any): void
        /** Sets the active EditorTool.
         * @param type The EditorTool type to set as the active tool.
         * @param tool The EditorTool instance to set as the active tool.
         */
        static SetActiveTool(type: any): void
        /** Sets the active EditorTool.
         * @param type The EditorTool type to set as the active tool.
         * @param tool The EditorTool instance to set as the active tool.
         */
        static SetActiveTool(tool: EditorTool): void
        static RestorePreviousTool(): void
        static RestorePreviousPersistentTool(): void
        /** Test if an EditorTool is currently the active tool.
         * @param tool The EditorTool to compare with the active tool.
         * @returns Returns true if the tool is active, false if it is not the active tool. 
         */
        static IsActiveTool(tool: EditorTool): boolean
        /** Test if an EditorToolContext is currently the active tool context.
         * @param context The EditorToolContext to compare with the active tool context.
         * @returns Returns true if the context is active, false if it is not the active context. 
         */
        static IsActiveContext(context: EditorToolContext): boolean
        /** Gets the type of EditorToolContext that is currently active. The default value is GameObjectToolContext.
         */
        static readonly activeContextType: any
        /** Gets the type of the EditorTool that is currently active.
         */
        static readonly activeToolType: any
        static activeToolChanging(op: "add" | "remove", fn: () => void): void
        static activeToolChanged(op: "add" | "remove", fn: () => void): void
        static activeContextChanging(op: "add" | "remove", fn: () => void): void
        static activeContextChanged(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IDrawSelectedHandles {
        OnDrawHandles(): void
    }
}
declare module "UnityEditor.EditorTools" {
    import * as jsb from "jsb";
    import { ScriptableObject, Object, GUIContent } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    import { EditorWindow } from "UnityEditor";
    /** Use this class to implement editor tools. This is the base class from which all editor tools are inherited.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EditorTool extends ScriptableObject {
        OnActivated(): void
        OnWillBeDeactivated(): void
        /** Use this method to implement a custom editor tool.
         * @param window The window that is displaying the custom editor tool.
         */
        OnToolGUI(window: EditorWindow): void
        IsAvailable(): boolean
        /** An array of the objects being inspected.
         */
        readonly targets: any
        /** The object being inspected.
         */
        readonly target: Object
        /** The icon and tooltip for this custom editor tool. If this function is not implemented, the toolbar displays the Inspector icon for the target type. If no target type is defined, the toolbar displays the Tool Mode icon.
         */
        readonly toolbarIcon: GUIContent
        /** Use this property to allow the current EditorTool to enable/disable grid snapping.
         */
        readonly gridSnapEnabled: boolean
    }
}
declare module "UnityEditor.Playables" {
    import * as jsb from "jsb";
    import { Object, ValueType, Array } from "System";
    /** Editor utility functions for the Playable graph and its nodes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Utility extends Object {
        static GetAllGraphs(): Array<any>
        static graphCreated(op: "add" | "remove", fn: (obj: any) => void): void
        static destroyingGraph(op: "add" | "remove", fn: (obj: any) => void): void
    }
}
declare module "UnityEditor.Playables" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Editor extensions for all types that implement IPlayableOutput.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PlayableOutputEditorExtensions extends Object {
    }
}
declare module "UnityEditor.Connect" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class UnityOAuth extends Object {
        static GetAuthorizationCodeAsync(clientId: string, callback: (obj: UnityOAuth.AuthCodeResponse) => void): void
        static UserLoggedIn(op: "add" | "remove", fn: () => void): void
        static UserLoggedOut(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor.Connect" {
    import * as jsb from "jsb";
    import { ValueType, Exception } from "System";
    namespace UnityOAuth {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class AuthCodeResponse extends ValueType {
            constructor()
            AuthCode: string
            Exception: Exception
        }
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Enable or disable shader keyword filter attributes based on shader tags.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ApplyRulesIfTagsEqualAttribute extends Object {
        constructor(...tags: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Enable or disable shader keyword filter attributes based on shader tags.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ApplyRulesIfTagsNotEqualAttribute extends Object {
        constructor(...tags: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** Enable or disable shader keyword filter attributes based on the graphics API.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ApplyRulesIfGraphicsAPIAttribute extends Object {
        constructor(...graphicsDeviceTypes: any[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    /** Enable or disable shader keyword filter attributes based on the graphics API.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ApplyRulesIfNotGraphicsAPIAttribute extends Object {
        constructor(...graphicsDeviceTypes: any[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    /** Whether shader keyword filter attributes include the keywords, remove the keywords or do nothing, based on the attribute condition evaluation.
     */
    enum FilterAction {
        /** Includes only the keywords in any multi_compile keyword set containing them, if the attribute condition evaluates as true.
         */
        Select = 0,
        /** Removes the keywords from any multi_compile keyword set containing them, if the attribute condition evaluates as true.
         */
        Remove = 1,
        /** Includes only the keywords if the attribute condition evaluates as true. Removes the keywords if the attribute condition evaluates as false.
         */
        SelectOrRemove = 2,
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Include only the specified shader keywords in the build if the data field matches the condition.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SelectIfAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Remove the specified shader keywords from the build if the data field matches the condition.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class RemoveIfAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Either include or remove the specified shader keywords in the build, depending on the data field underneath.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SelectOrRemoveAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Include only the specified shader keywords in the build if the data field doesn't match the condition.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SelectIfNotAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Remove the specified shader keywords from the build if the data field doesn't match the condition.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class RemoveIfNotAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.ShaderKeywordFilter" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Either remove or include the specified shader keywords in the build, depending on the data field underneath.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class RemoveOrSelectAttribute extends Object {
        constructor(condition: Object, overridePriority: boolean, filePath: string, lineNumber: number, ...keywordNames: string[])
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    import { HierarchyProperty } from "UnityEditor";
    /** A search context implementation for Scene search engines. All methods that are called on a Scene search engine, and expect a SearchService.ISearchContext, receive an object of this type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneSearchContext extends Object implements ISearchContext {
        constructor()
        /** A unique identifier for this search context.
         */
        readonly guid: any
        /** An enum that identifies the scope of the current search. This property is automatically set to SearchService.Scene.EngineScope.
         */
        readonly engineScope: SearchEngineScope
        /** An IEnumerable of types that contains the type constraints for this search.
         */
        requiredTypes: any
        /** An IEnumerable of strings that contains the type name constraints for this search.
         */
        requiredTypeNames: IEnumerable<string>
        /** The root HierarchyProperty on which the search is started.
         */
        rootProperty: HierarchyProperty
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { HierarchyProperty } from "UnityEditor";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ISceneSearchEngine extends ISearchEngineBase {
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Use this API to perform searches in the Scene. Engines for this type of search implement the SearchService.ISceneSearchEngine interface.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class SceneSearch extends Object {
        /** Registers a Scene search engine dynamically.
         * @param engine The Scene search engine to register.
         */
        static RegisterEngine(engine: ISceneSearchEngine): void
        /** Unregisters a dynamically registered engine.
         * @param engine The Scene search engine to unregister.
         */
        static UnregisterEngine(engine: ISceneSearchEngine): void
        /** A enum that indicates the search scope for SceneSearch engines. It is used by SceneSearchContext.
         */
        static readonly EngineScope: SearchEngineScope
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object, ValueType, Array } from "System";
    import { Object as Object1 } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    /** A search context implementation for ObjectSelector search engines. All methods that are called on an ObjectSelector search engine, and expect a SearchService.ISearchContext, receive an object of this type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ObjectSelectorSearchContext extends Object implements ISearchContext {
        constructor()
        /** A unique identifier for this search context.
         */
        readonly guid: any
        /** An enum that identifies the scope of the current search. This property is automatically set to SearchService.ObjectSelector.EngineScope.
         */
        readonly engineScope: SearchEngineScope
        /** Identifies the currently selected object.
         */
        currentObject: Object1
        /** When the object selector is opened from an Inspector, this property indicates which objects are currently being edited.
         */
        editedObjects: Array<Object1>
        /** An IEnumerable of types that contains the type constraints for this search.
         */
        requiredTypes: any
        /** An IEnumerable of strings that contains the type name constraints for this search.
         */
        requiredTypeNames: IEnumerable<string>
        /** Indicates which categories of objects are visible in the window. For example, GameObjects, Assets, or both.
         */
        visibleObjects: VisibleObjects
        /** IEnumerable of integers that contains the instanceIds of objects that the search can include in its results.
         */
        allowedInstanceIds: any
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    /** A search context implementation for Project search engines. All methods that are called on a Project search engine, and expect a SearchService.ISearchContext, receive an object of this type.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ProjectSearchContext extends Object implements ISearchContext {
        constructor()
        /** A unique identifier for this search context.
         */
        readonly guid: any
        /** An enum that identifies the scope of the current search. This property is automatically set to SearchService.Project.EngineScope.
         */
        readonly engineScope: SearchEngineScope
        /** An IEnumerable of types that contains the type constraints for this search.
         */
        requiredTypes: any
        /** An IEnumerable of strings that contains the type name constraints for this search.
         */
        requiredTypeNames: IEnumerable<string>
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IProjectSearchEngine extends ISearchEngineBase {
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Use this API to perform searches in the Project. Engines for this type of search implement the SearchService.IProjectSearchEngine interface.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ProjectSearch extends Object {
        /** Registers a Project search engine dynamically.
         * @param engine The Project search engine to register.
         */
        static RegisterEngine(engine: IProjectSearchEngine): void
        /** Unregisters a dynamically registered engine.
         * @param engine The Project search engine to unregister.
         */
        static UnregisterEngine(engine: IProjectSearchEngine): void
        /** A enum that indicates the search scope for ProjectSearch engines. It is used by ProjectSearchContext.
         */
        static readonly EngineScope: SearchEngineScope
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    /** A bit field that contains the different categories of object that the object selector window can display.
     */
    enum VisibleObjects {
        /** The object selector window cannot display any objects.
         */
        None = 0,
        /** The object selector window can only display Assets.
         */
        Assets = 1,
        /** The object selector window can only display GameObjects.
         */
        Scene = 2,
        /** The object selector window can display all categories.
         */
        All = 3,
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IObjectSelectorEngine extends ISearchEngineBase, ISelectorEngine {
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Use this API to select objects. Engines for this type of search implement the SearchService.IObjectSelectorEngine interface.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ObjectSelectorSearch extends Object {
        /** Registers an ObjectSelector search engine dynamically.
         * @param engine The ObjectSelector search engine to register.
         */
        static RegisterEngine(engine: IObjectSelectorEngine): void
        /** Unregisters a dynamically registered engine.
         * @param engine The ObjectSelector search engine to unregister.
         */
        static UnregisterEngine(engine: IObjectSelectorEngine): void
        /** A enum that indicates the search scope of ObjectSelectorSearch engines. Used by ObjectSelectorSearchContext.
         */
        static readonly EngineScope: SearchEngineScope
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    /** An enumeration that contains the available search engine scopes.
     */
    enum SearchEngineScope {
        /** Identifies a search for Scene engines.
         */
        Scene = 0,
        /** Identifies a search for Project engines.
         */
        Project = 1,
        /** Identifies a search for ObjectSelector engines.
         */
        ObjectSelector = 2,
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { IEnumerable } from "System.Collections.Generic";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ISearchContext {
        /** A unique identifier for this search context.
         */
        readonly guid: any
        /** An enum that identifies the current search scope.
         */
        readonly engineScope: SearchEngineScope
        /** IEnumerable of types that contains the type constraints for this search.
         */
        readonly requiredTypes: any
        /** An IEnumerable of strings that contains the type name constraints for this search.
         */
        readonly requiredTypeNames: IEnumerable<string>
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ISearchEngineBase {
        /** A function called at the beginning of a search session.
         * @param context The search context.
         */
        BeginSession(context: ISearchContext): void
        /** A function called at the end of a search session.
         * @param context The search context.
         */
        EndSession(context: ISearchContext): void
        /** A function called at the beginning of each search.
         * @param context The search context.
         * @param query The query string used for the search.
         */
        BeginSearch(context: ISearchContext, query: string): void
        /** A function called at the end of a search.
         * @param context The search context.
         */
        EndSearch(context: ISearchContext): void
        /** The name displayed in the Preferences window in the Unity Editor. This name is used to store the active engine in the preferences.
         */
        readonly name: string
    }
}
declare module "UnityEditor.SearchService" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ISelectorEngine extends ISearchEngineBase {
        SelectObject(context: ISearchContext, onObjectSelectorClosed: (arg1: Object, arg2: boolean) => void, onObjectSelectedUpdated: (obj: Object) => void): boolean
        /** This function is called when the initial search text for the object selector window is set.
         * @param context The search context.
         * @param searchFilter The search filter to set on the object selector window.
         */
        SetSearchFilter(context: ISearchContext, searchFilter: string): void
    }
}
declare module "UnityEditor.Events" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { UnityEvent, UnityEventBase } from "UnityEngine.Events";
    /** Editor tools for working with persistent UnityEvents.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class UnityEventTools extends Object {
        /** Adds a persistent, call to the listener. Will be invoked with the arguments as defined by the Event and sent from the call location.
         * @param unityEvent Event to modify.
         * @param call Function to call.
         */
        static AddPersistentListener(unityEvent: UnityEvent, call: () => void): void
        /** Adds a persistent, call to the listener. Will be invoked with the arguments as defined by the Event and sent from the call location.
         * @param unityEvent Event to modify.
         * @param call Function to call.
         */
        static AddPersistentListener(unityEvent: UnityEventBase): void
        /** Removes the given function from the event.
         * @param unityEvent Event to modify.
         * @param index Index to remove (if specified).
         * @param call Function to remove (if specified).
         */
        static RemovePersistentListener(unityEvent: UnityEventBase, index: number): void
        /** Removes the given function from the event.
         * @param unityEvent Event to modify.
         * @param index Index to remove (if specified).
         * @param call Function to remove (if specified).
         */
        static RemovePersistentListener(unityEvent: UnityEventBase, call: () => void): void
        /** Modifies the event at the given index.
         * @param unityEvent Event to modify.
         * @param index Index to modify.
         * @param call Function to call.
         */
        static RegisterPersistentListener(unityEvent: UnityEvent, index: number, call: () => void): void
        /** Unregisters the given listener at the specified index.
         * @param unityEvent Event to modify.
         * @param index Index to unregister.
         */
        static UnregisterPersistentListener(unityEvent: UnityEventBase, index: number): void
        /** Adds a persistent, preset call to the listener.
         * @param unityEvent Event to modify.
         * @param call Function to call.
         */
        static AddVoidPersistentListener(unityEvent: UnityEventBase, call: () => void): void
        /** Modifies the event at the given index.
         * @param unityEvent Event to modify.
         * @param index Index to modify.
         * @param call Function to call.
         */
        static RegisterVoidPersistentListener(unityEvent: UnityEventBase, index: number, call: () => void): void
        static AddIntPersistentListener(unityEvent: UnityEventBase, call: (id: number) => void, argument: number): void
        static RegisterIntPersistentListener(unityEvent: UnityEventBase, index: number, call: (id: number) => void, argument: number): void
        static AddFloatPersistentListener(unityEvent: UnityEventBase, call: (arg0: number) => void, argument: number): void
        static RegisterFloatPersistentListener(unityEvent: UnityEventBase, index: number, call: (arg0: number) => void, argument: number): void
        static AddBoolPersistentListener(unityEvent: UnityEventBase, call: (obj: boolean) => void, argument: boolean): void
        static RegisterBoolPersistentListener(unityEvent: UnityEventBase, index: number, call: (obj: boolean) => void, argument: boolean): void
        static AddStringPersistentListener(unityEvent: UnityEventBase, call: (obj: string) => void, argument: string): void
        static RegisterStringPersistentListener(unityEvent: UnityEventBase, index: number, call: (obj: string) => void, argument: string): void
    }
}
declare module "UnityEditor.ProjectWindowCallback" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    /** Base class to implement callbacks to be used when creating assets via the project window. You can extend the EndNameEditAction and write your own callback.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class EndNameEditAction extends ScriptableObject {
        OnEnable(): void
        /** Unity calls this function when the user accepts an edited name, either by pressing the Enter key or by losing the keyboard input focus.
         * @param instanceId The instance ID of the edited asset.
         * @param pathName The path to the asset.
         * @param resourceFile The resource file string argument passed to ProjectWindowUtil.StartNameEditingIfProjectWindowExists.
         */
        Action(instanceId: number, pathName: string, resourceFile: string): void
        /** Unity calls this function when the user presses the Escape key to cancel editing a name.
         * @param instanceId The instance ID of the asset that the user attempted to edit.
         * @param pathName The path to the asset.
         * @param resourceFile The resource file string argument passed to ProjectWindowUtil.StartNameEditingIfProjectWindowExists.
         */
        Cancelled(instanceId: number, pathName: string, resourceFile: string): void
        CleanUp(): void
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** ToolbarOverlay is an implementation of Overlay that provides a base for Overlays that can be placed in horizontal or vertical toolbars.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class ToolbarOverlay extends Overlay {
        CreateHorizontalToolbarContent(): any
        CreateVerticalToolbarContent(): any
        CreatePanelContent(): any
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { EditorWindow } from "UnityEditor";
    import { Vector2, Vector3 } from "UnityEngine";
    /** Overlays are persistent and customizable panels and toolbars that are available within Editor Windows. Use Overlays to expose actions and tool options in a convenient and user-controllable way.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Overlay extends Object {
        CreatePanelContent(): any
        OnCreated(): void
        OnWillBeDestroyed(): void
        Undock(): void
        /** EditorWindow the overlay is contained within.
         */
        readonly containerWindow: EditorWindow
        /** Overlay unique ID.
         */
        readonly id: string
        /** Describes the presentation mode for an Overlay.
         */
        readonly layout: Layout
        /** Defines whether the overlay is in collapsed form.
         */
        collapsed: boolean
        /** Name of overlay used as title.
         */
        displayName: string
        /** Shows or hides the overlay.
         */
        displayed: boolean
        /** Returns true if overlay is docked in a toolbar.
         */
        readonly isInToolbar: boolean
        /** Local position of closest overlay corner to closest dockposition when floating.
         */
        floatingPosition: Vector2
        /** Returns true if overlay is floating, returns false if overlay is docked in a corner or in a toolbar.
         */
        readonly floating: boolean
        /** USS class name of elements of this type.
         */
        static readonly ussClassName: string
        layoutChanged(op: "add" | "remove", fn: (obj: Layout) => void): void
        collapsedChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        displayedChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        floatingChanged(op: "add" | "remove", fn: (obj: boolean) => void): void
        floatingPositionChanged(op: "add" | "remove", fn: (obj: Vector3) => void): void
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ITransientOverlay {
        /** Use visible to enable or disable the rendering of this Overlay.
         */
        readonly visible: boolean
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** IMGUIOverlay is an implementation of Overlay that provides a UIElements.IMGUIContainer.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class IMGUIOverlay extends Overlay {
        CreatePanelContent(): any
        OnGUI(): void
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    /** Possible layouts for an overlay.
     */
    enum Layout {
        /** Contents will be sized to fit within a toolbar and arranged horizontally.
         */
        HorizontalToolbar = 1,
        /** Contents will be sized to fit within a toolbar and arranged vertically.
         */
        VerticalToolbar = 2,
        /** Contents will be presented as a normal overlay with a header title and content area.
         */
        Panel = 4,
        /** Equivalent to Layout.Panel | Layout.HorizontalToolbar | Layout.VerticalToolbar.
         */
        All = 7,
    }
}
declare module "UnityEditor.Overlays" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface ISupportsOverlays {
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Color, Vector3, Quaternion, EventType } from "UnityEngine";
    /** A class for a compound handle to edit an angle and a radius in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ArcHandle extends Object {
        constructor()
        /** Sets angleHandleColor, wireframeColor, and fillColor to the same value, where fillColor will have the specified alpha value. radiusHandleColor will be set to Color.clear and the radius handle will be disabled.
         * @param color The color to use for the angle control handle and the fill shape.
         * @param fillColorAlpha The alpha value to use for fillColor.
         */
        SetColorWithoutRadiusHandle(color: Color, fillColorAlpha: number): void
        /** Sets angleHandleColor, radiusHandleColor, wireframeColor, and fillColor to the same value, where fillColor will have the specified alpha value.
         * @param color The color to use for the angle and radius control handles and the fill shape.
         * @param fillColorAlpha The alpha value to use for fillColor.
         */
        SetColorWithRadiusHandle(color: Color, fillColorAlpha: number): void
        DrawHandle(): void
        /** A Handles.CapFunction that draws a line terminated with Handles.CylinderHandleCap.
         * @param controlID The control ID for the handle.
         * @param position The position of the handle in the space of Handles.matrix.
         * @param rotation The rotation of the handle in the space of Handles.matrix.
         * @param size The size of the handle in the space of Handles.matrix. Use HandleUtility.GetHandleSize if you want a constant screen-space size.
         * @param eventType Event type for the handle to act upon. By design it handles EventType.Layout and EventType.Repaint events.
         */
        static DefaultAngleHandleDrawFunction(controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType): void
        /** A Handles.SizeFunction that returns a fixed screen-space size.
         * @param position The current position of the handle in the space of Handles.matrix.
         * @returns The size to use for a handle at the specified position. 
         */
        static DefaultAngleHandleSizeFunction(position: Vector3): number
        /** A Handles.SizeFunction that returns a fixed screen-space size.
         * @param position The current position of the handle in the space of Handles.matrix.
         * @returns The size to use for a handle at the specified position. 
         */
        static DefaultRadiusHandleSizeFunction(position: Vector3): number
        /** Returns or specifies the angle of the arc for the handle.
         */
        angle: number
        /** Returns or specifies the radius of the arc for the handle.
         */
        radius: number
        /** Returns or specifies the color of the angle control handle.
         */
        angleHandleColor: Color
        /** Returns or specifies the color of the radius control handle.
         */
        radiusHandleColor: Color
        /** Returns or specifies the color of the arc shape.
         */
        fillColor: Color
        /** Returns or specifies the color of the curved line along the outside of the arc.
         */
        wireframeColor: Color
        angleHandleDrawFunction(op: "get"): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void
        angleHandleDrawFunction(op: "add" | "remove" | "set", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): void
        angleHandleDrawFunction(op: "add" | "remove" | "set" | "get", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void | void
        angleHandleSizeFunction(op: "get"): (position: Vector3) => number
        angleHandleSizeFunction(op: "add" | "remove" | "set", fn?: (position: Vector3) => number): void
        angleHandleSizeFunction(op: "add" | "remove" | "set" | "get", fn?: (position: Vector3) => number): (position: Vector3) => number | void
        radiusHandleDrawFunction(op: "get"): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void
        radiusHandleDrawFunction(op: "add" | "remove" | "set", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): void
        radiusHandleDrawFunction(op: "add" | "remove" | "set" | "get", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void | void
        radiusHandleSizeFunction(op: "get"): (position: Vector3) => number
        radiusHandleSizeFunction(op: "add" | "remove" | "set", fn?: (position: Vector3) => number): void
        radiusHandleSizeFunction(op: "add" | "remove" | "set" | "get", fn?: (position: Vector3) => number): (position: Vector3) => number | void
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Texture2D } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    /** Items that build the drop-down list.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AdvancedDropdownItem extends Object {
        constructor(name: string)
        /** Adds the given AdvancedDropdownItem child to the children list.
         * @param child AdvancedDropdownItem to be added to the children list.
         */
        AddChild(child: AdvancedDropdownItem): void
        CompareTo(o: Object): number
        AddSeparator(): void
        toString(): string
        /** Name shown for this item when rendered.
         */
        name: string
        /** If set, this icon will be rendered to the left of the item name.
         */
        icon: Texture2D
        /** The unique identifier for an item.
         */
        id: number
        /** True if the item is enabled.
         */
        enabled: boolean
        /** The list of child items of this item.
         */
        readonly children: any
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** The state of the drop-down. This Object can be serialized.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class AdvancedDropdownState extends Object {
        constructor()
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    /** A compound handle to edit a capsule-shaped bounding volume in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class CapsuleBoundsHandle extends PrimitiveBoundsHandle {
        constructor()
        /** Returns or specifies the axis in the handle's space to which height maps. The radius maps to the remaining axes.
         */
        heightAxis: CapsuleBoundsHandle.HeightAxis
        /** Returns or specifies the height of the capsule bounding volume.
         */
        height: number
        /** Returns or specifies the radius of the capsule bounding volume.
         */
        radius: number
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector3, Color, Quaternion, EventType } from "UnityEngine";
    /** Base class for a compound handle to edit a bounding volume in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PrimitiveBoundsHandle extends Object {
        /** Sets handleColor and wireframeColor to the same value.
         * @param color The color to use for the control handles and the wireframe shape.
         */
        SetColor(color: Color): void
        DrawHandle(): void
        /** A Handles.SizeFunction that returns a fixed screen-space size.
         * @param position The current position of the handle in the space of Handles.matrix.
         * @returns The size to use for a handle at the specified position. 
         */
        static DefaultMidpointHandleSizeFunction(position: Vector3): number
        /** Returns or specifies the center of the bounding volume for the handle.
         */
        center: Vector3
        /** Flags specifying which axes should display control handles.
         */
        axes: PrimitiveBoundsHandle.Axes
        /** Returns or specifies the color of the control handles.
         */
        handleColor: Color
        /** Returns or specifies the color of the wireframe shape.
         */
        wireframeColor: Color
        midpointHandleDrawFunction(op: "get"): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void
        midpointHandleDrawFunction(op: "add" | "remove" | "set", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): void
        midpointHandleDrawFunction(op: "add" | "remove" | "set" | "get", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void | void
        midpointHandleSizeFunction(op: "get"): (position: Vector3) => number
        midpointHandleSizeFunction(op: "add" | "remove" | "set", fn?: (position: Vector3) => number): void
        midpointHandleSizeFunction(op: "add" | "remove" | "set" | "get", fn?: (position: Vector3) => number): (position: Vector3) => number | void
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    namespace CapsuleBoundsHandle {
        enum HeightAxis {
            X = 0,
            Y = 1,
            Z = 2,
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    namespace PrimitiveBoundsHandle {
        enum Axes {
            None = 0,
            X = 1,
            Y = 2,
            Z = 4,
            All = 7,
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    /** A compound handle to edit a sphere-shaped bounding volume in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SphereBoundsHandle extends PrimitiveBoundsHandle {
        constructor()
        /** Returns or specifies the radius of the sphere bounding volume.
         */
        radius: number
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Vector3 } from "UnityEngine";
    /** A compound handle to edit a box-shaped bounding volume in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BoxBoundsHandle extends PrimitiveBoundsHandle {
        constructor()
        /** Returns or specifies the size of the bounding box.
         */
        size: Vector3
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    import { Rect } from "UnityEngine";
    /** The MultiColumnHeader is a general purpose class that e.g can be used with the TreeView to create multi-column tree views and list views.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MultiColumnHeader extends Object {
        constructor(state: MultiColumnHeaderState)
        /** Sets multiple sorting columns and the associated sorting orders.
         * @param columnIndices Column indices of the sorted columns.
         * @param sortAscending Sorting order for the column indices specified.
         */
        SetSortingColumns(columnIndices: Array<number>, sortAscending: Array<boolean>): void
        /** Sets the primary sorting column and its sorting order.
         * @param columnIndex Column to sort.
         * @param sortAscending Sorting order for the column specified.
         */
        SetSorting(columnIndex: number, sortAscending: boolean): void
        /** Change sort direction for a given column.
         * @param columnIndex Column index.
         * @param sortAscending Direction of the sorting.
         */
        SetSortDirection(columnIndex: number, sortAscending: boolean): void
        /** Check the sorting order state for a column.
         * @param columnIndex Column index.
         * @returns True if sorted ascending. 
         */
        IsSortedAscending(columnIndex: number): boolean
        /** Returns the column data for a given column index.
         * @param columnIndex Column index.
         * @returns Column data. 
         */
        GetColumn(columnIndex: number): MultiColumnHeaderState.Column
        /** Check if a column is currently visible in the MultiColumnHeader.
         * @param columnIndex Column index.
         */
        IsColumnVisible(columnIndex: number): boolean
        /** Convert from column index to visible column index.
         * @param columnIndex Column index.
         * @returns Visible column index. 
         */
        GetVisibleColumnIndex(columnIndex: number): number
        /** Calculates a cell rect for a column and row using the visibleColumnIndex and rowRect parameters.
         */
        GetCellRect(visibleColumnIndex: number, rowRect: Rect): Rect
        /** Returns the header column Rect for a given visible column index.
         * @param visibleColumnIndex Index of a visible column.
         */
        GetColumnRect(visibleColumnIndex: number): Rect
        ResizeToFit(): void
        /** Render and handle input for the MultiColumnHeader at the given rect.
         * @param xScroll Horizontal scroll offset.
         * @param rect Rect where the MultiColumnHeader is drawn in.
         */
        OnGUI(rect: Rect, xScroll: number): void
        Repaint(): void
        /** Customizable height of the multi column header.
         */
        height: number
        /** Use this property to control whether sorting is enabled for all the columns.
         */
        canSort: boolean
        /** The index of the column that is set to be the primary sorting column. This is the column that shows the sorting arrow above the header text.
         */
        sortedColumnIndex: number
        /** This is the state of the MultiColumnHeader.
         */
        state: MultiColumnHeaderState
        sortingChanged(op: "add" | "remove", fn: (multiColumnHeader: MultiColumnHeader) => void): void
        visibleColumnsChanged(op: "add" | "remove", fn: (multiColumnHeader: MultiColumnHeader) => void): void
        columnSettingsChanged(op: "add" | "remove", fn: (id: number) => void): void
        columnsSwapped(op: "add" | "remove", fn: (arg1: number, arg2: number) => void): void
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace MultiColumnHeader {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class DefaultGUI extends Object {
            static readonly defaultHeight: number
            static readonly minimumHeight: number
            static readonly columnContentMargin: number
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIStyle } from "UnityEngine";
    namespace MultiColumnHeader {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class DefaultStyles extends Object {
            static columnHeader: GUIStyle
            static columnHeaderRightAligned: GUIStyle
            static columnHeaderCenterAligned: GUIStyle
            static background: GUIStyle
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Vector2 } from "UnityEngine";
    /** The TreeViewState contains serializable state information for the TreeView.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TreeViewState extends Object {
        constructor()
        /** Selected TreeViewItem IDs. Use of the SetSelection and IsSelected API will access this state.
         */
        selectedIDs: any
        /** The ID for the TreeViewItem that currently is being used for multi selection and key navigation.
         */
        lastClickedID: number
        /** This is the list of currently expanded TreeViewItem IDs.
         */
        expandedIDs: any
        /** Search string state that can be used in the TreeView to filter the tree data when creating the TreeViewItems.
         */
        searchString: string
        /** The current scroll values of the TreeView's scroll view.
         */
        scrollPos: Vector2
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    /** State used by the MultiColumnHeader.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MultiColumnHeaderState extends Object {
        constructor(columns: Array<MultiColumnHeaderState.Column>)
        /** Checks if the source state can transfer its serialized data to the destination state.
         * @param source State that have serialized data to be transfered to the destination state.
         * @param destination Destination state.
         * @returns Returns true if the source state have the same number of columns as the destination state. 
         */
        static CanOverwriteSerializedFields(source: MultiColumnHeaderState, destination: MultiColumnHeaderState): boolean
        /** Overwrites the seralized fields from the source state to the destination state.
         * @param source State that have serialized data to be transfered to the destination state.
         * @param destination Destination state.
         */
        static OverwriteSerializedFields(source: MultiColumnHeaderState, destination: MultiColumnHeaderState): void
        /** This property holds the index to the primary sorted column.
         */
        sortedColumnIndex: number
        /** This property controls the maximum number of columns returned by the sortedColumns property.
         */
        maximumNumberOfSortedColumns: number
        /** The array of column indices for multiple column sorting.
         */
        sortedColumns: Array<number>
        /** The array of column states used by the MultiColumnHeader class.
         */
        readonly columns: Array<MultiColumnHeaderState.Column>
        /** This is the array of currently visible column indices.
         */
        visibleColumns: Array<number>
        /** Returns the sum of all the widths of the visible columns in the visibleColumns array.
         */
        readonly widthOfAllVisibleColumns: number
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    import { GUIContent } from "UnityEngine";
    namespace MultiColumnHeaderState {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class Column extends Object {
            constructor()
            width: number
            sortedAscending: boolean
            headerContent: GUIContent
            contextMenuText: string
            headerTextAlignment: any
            sortingArrowAlignment: any
            minWidth: number
            maxWidth: number
            autoResize: boolean
            allowToggleVisibility: boolean
            canSort: boolean
            userData: number
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Texture2D } from "UnityEngine";
    /** The TreeViewItem is used to build the tree representation of a tree data structure.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class TreeViewItem extends Object {
        constructor(id: number, depth: number, displayName: string)
        constructor(id: number, depth: number)
        constructor(id: number)
        constructor()
        /** Helper method that adds the child TreeViewItem to the children list and sets the parent property on the child.
         * @param child TreeViewItem to be added to the children list.
         */
        AddChild(child: TreeViewItem): void
        CompareTo(other: TreeViewItem): number
        toString(): string
        /** Unique ID for an item.
         */
        id: number
        /** Name shown for this item when rendered.
         */
        displayName: string
        /** The depth refers to how many ancestors this item has, and corresponds to the number of horizontal ‘indents’ this item has.
         */
        depth: number
        /** Returns true if children has any items.
         */
        readonly hasChildren: boolean
        /** The list of child items of this TreeViewItem.
         */
        children: any
        /** The parent of this TreeViewItem. If it is null then it is considered the root of the TreeViewItem tree.
         */
        parent: TreeViewItem
        /** If set, this icon will be rendered to the left of the displayName. The icon is rendered at 16x16 points by default.
         */
        icon: Texture2D
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    /** Inherit from this class to implement your own drop-down control.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class AdvancedDropdown extends Object {
        /** Call this method to show the drop-down at the given position.
         * @param rect Position of the button that triggered the drop-down.
         */
        Show(rect: Rect): void
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    /** The TreeView is an IMGUI control that lets you create tree views, list views and multi-column tables for Editor tools.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class TreeView extends Object {
        Reload(): void
        Repaint(): void
        GetRows(): any
        ExpandAll(): void
        CollapseAll(): void
        /** Expand or collapse all items under item with id.
         * @param id TreeViewItem ID.
         * @param expanded Expanded state: true expands, false collapses.
         */
        SetExpandedRecursive(id: number, expanded: boolean): void
        /** Set a single TreeViewItem to be expanded or collapsed.
         * @param id TreeViewItem ID.
         * @param expanded True expands item. False collapses item.
         * @returns True if item changed expanded state, false if item already had the expanded state. 
         */
        SetExpanded(id: number, expanded: boolean): boolean
        SetExpanded(ids: any): void
        GetExpanded(): any
        /** Returns true if the TreeViewItem with ID id is currently expanded.
         * @param id TreeViewItem ID.
         */
        IsExpanded(id: number): boolean
        GetSelection(): any
        SetSelection(selectedIDs: any, options: TreeViewSelectionOptions): void
        SetSelection(selectedIDs: any): void
        /** Returns true if the TreeViewItem with ID id is currently selected.
         * @param id TreeViewItem ID.
         */
        IsSelected(id: number): boolean
        HasSelection(): boolean
        HasFocus(): boolean
        SetFocus(): void
        SetFocusAndEnsureSelectedItem(): void
        /** Shows the rename overlay for a TreeViewItem.
         * @param item Item to rename.
         * @param delay Delay in seconds until the rename overlay shows.
         * @returns Returns true if renaming was started. Returns false if renaming was already active. 
         */
        BeginRename(item: TreeViewItem, delay: number): boolean
        /** Shows the rename overlay for a TreeViewItem.
         * @param item Item to rename.
         * @param delay Delay in seconds until the rename overlay shows.
         * @returns Returns true if renaming was started. Returns false if renaming was already active. 
         */
        BeginRename(item: TreeViewItem): boolean
        EndRename(): void
        /** This will reveal the item with ID id (by expanding the ancestors of that item) and will make sure it is visible in the ScrollView.
         * @param id TreeViewItem ID.
         */
        FrameItem(id: number): void
        /** This is the main GUI method of the TreeView, where the TreeViewItems are processed and drawn.
         * @param rect Rect where the TreeView is rendered.
         */
        OnGUI(rect: Rect): void
        SelectAllRows(): void
        /** The state of the TreeView (expanded state, selection, scroll etc.)
         */
        readonly state: TreeViewState
        /** Get the MultiColumnHeader of the TreeView. Can be null if the TreeView was created without a MultiColumnHeader.
         */
        multiColumnHeader: MultiColumnHeader
        /** Returns the sum of the TreeView row heights, the MultiColumnHeader height (if used) and the border (if used).
         */
        readonly totalHeight: number
        /** The controlID used by the TreeView to obtain keyboard control focus.
         */
        treeViewControlID: number
        /** The current search state of the TreeView.
         */
        readonly hasSearch: boolean
        /** Current search string of the TreeView.
         */
        searchString: string
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    namespace TreeView {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class DefaultGUI extends Object {
            static FoldoutLabel(rect: Rect, label: string, selected: boolean, focused: boolean): void
            static Label(rect: Rect, label: string, selected: boolean, focused: boolean): void
            static LabelRightAligned(rect: Rect, label: string, selected: boolean, focused: boolean): void
            static BoldLabel(rect: Rect, label: string, selected: boolean, focused: boolean): void
            static BoldLabelRightAligned(rect: Rect, label: string, selected: boolean, focused: boolean): void
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GUIStyle } from "UnityEngine";
    namespace TreeView {
        @jsb.RequiredDefines("UNITY_EDITOR")
        abstract class DefaultStyles extends Object {
            static foldoutLabel: GUIStyle
            static label: GUIStyle
            static labelRightAligned: GUIStyle
            static boldLabel: GUIStyle
            static boldLabelRightAligned: GUIStyle
            static backgroundEven: GUIStyle
            static backgroundOdd: GUIStyle
        }
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    /** Enum used by the TreeView.SetSelection method.
     */
    enum TreeViewSelectionOptions {
        /** If this flag is passed to TreeView.SetSelection no extra logic is be performed after setting selection.
         */
        None = 0,
        /** If this flag is passed to TreeView.SetSelection then the TreeView will call the its TreeView.SelectionChanged method.
         */
        FireSelectionChanged = 1,
        /** If this flag is passed to TreeView.SetSelection then the TreeView will make sure the last item in the input selection list is visible on screen.
         */
        RevealAndFrame = 2,
    }
}
declare module "UnityEditor.IMGUI.Controls" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    import { Vector2, Color, Vector3, Quaternion, EventType } from "UnityEngine";
    /** A class for a compound handle to edit multiaxial angular motion limits in the Scene view.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class JointAngularLimitHandle extends Object {
        constructor()
        DrawHandle(usingArticulations: boolean): void
        DrawHandle(): void
        /** Returns or specifies the minimum angular motion about the x-axis.
         */
        xMin: number
        /** Returns or specifies the maximum angular motion about the x-axis.
         */
        xMax: number
        /** Returns or specifies the minimum angular motion about the y-axis.
         */
        yMin: number
        /** Returns or specifies the maximum angular motion about the y-axis.
         */
        yMax: number
        /** Returns or specifies the minimum angular motion about the z-axis.
         */
        zMin: number
        /** Returns or specifies the maximum angular motion about the z-axis.
         */
        zMax: number
        /** Returns or specifies the range of valid values for angular motion about the x-axis. Defaults to [-180.0, 180.0].
         */
        xRange: Vector2
        /** Returns or specifies the range of valid values for angular motion about the y-axis. Defaults to [-180.0, 180.0].
         */
        yRange: Vector2
        /** Returns or specifies the range of valid values for angular motion about the z-axis. Defaults to [-180.0, 180.0].
         */
        zRange: Vector2
        /** Returns or specifies how angular motion is limited about the x-axis. Defaults to ConfigurableJointMotion.Limited.
         */
        xMotion: any
        /** Returns or specifies how angular motion is limited about the y-axis. Defaults to ConfigurableJointMotion.Limited.
         */
        yMotion: any
        /** Returns or specifies how angular motion is limited about the z-axis. Defaults to ConfigurableJointMotion.Limited.
         */
        zMotion: any
        /** Returns or specifies the color to use for the handle limiting motion around the x-axis. Defaults to Handles.xAxisColor.
         */
        xHandleColor: Color
        /** Returns or specifies the color to use for the handle limiting motion around the y-axis. Defaults to Handles.yAxisColor.
         */
        yHandleColor: Color
        /** Returns or specifies the color to use for the handle limiting motion around the z-axis. Defaults to Handles.zAxisColor.
         */
        zHandleColor: Color
        /** Returns or specifies the radius of the arc for the handle. Defaults to 1.0.
         */
        radius: number
        /** Returns or specifies the opacity to use when rendering fill shapes for the range of motion for each axis. Defaults to 0.1.
         */
        fillAlpha: number
        /** Returns or specifies the opacity to use for the curved lines along the outside of the arcs of motion. Defaults to 1.0.
         */
        wireframeAlpha: number
        angleHandleDrawFunction(op: "get"): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void
        angleHandleDrawFunction(op: "add" | "remove" | "set", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): void
        angleHandleDrawFunction(op: "add" | "remove" | "set" | "get", fn?: (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void): (controlID: number, position: Vector3, rotation: Quaternion, size: number, eventType: EventType) => void | void
        angleHandleSizeFunction(op: "get"): (position: Vector3) => number
        angleHandleSizeFunction(op: "add" | "remove" | "set", fn?: (position: Vector3) => number): void
        angleHandleSizeFunction(op: "add" | "remove" | "set" | "get", fn?: (position: Vector3) => number): (position: Vector3) => number | void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    /** Sets which texture compression override to use when importing assets.
     */
    enum OverrideTextureCompression {
        /** Do not override texture import compression parameters.
         */
        NoOverride = 0,
        /** Import textures with texture compression off.
         */
        ForceUncompressed = 1,
        /** Import textures with fast, but lower quality, texture compression.
         */
        ForceFastCompressor = 2,
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    /** Options to control code generation for IL2CPP compiler.
     */
    enum Il2CppCodeGeneration {
        /** IL2CPP compiler will generate code optimized for runtime performance.
         */
        OptimizeSpeed = 0,
        /** IL2CPP compiler will generate code optimized for build size and build time.
         */
        OptimizeSize = 1,
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { BuildPlayerOptions } from "UnityEditor";
    /** Get a BuildPlayerContext object from a Build.BuildPlayerProcessor.PrepareForBuild callback.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildPlayerContext extends Object {
        /** Add additional streaming assets to the built player data. For example, you can include AssetBundles or other streaming assets without first putting them in the project StreamingAssets folder.
         * @param directoryOrFile Path representing an existing file or directory. If the path doesn't exit, this function throws a FileNotFoundException.
         * @param pathInStreamingAssets The path within the StreamingAssets folder at which to place the additional assets. If null, the file or directory is placed directly in the StreamingAssets folder.
         */
        AddAdditionalPathToStreamingAssets(directoryOrFile: string, pathInStreamingAssets: string): void
        protected constructor()
        /** The player build options associated with this build.
         */
        readonly BuildPlayerOptions: BuildPlayerOptions
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Exception } from "System";
    /** An exception class that represents a failed build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildFailedException extends Exception {
        constructor(message: string)
        constructor(innerException: Exception)
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IOrderedCallback {
        /** Returns the relative callback order for callbacks.  Callbacks with lower values are called before ones with higher values.
         */
        readonly callbackOrder: number
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Extend BuildPlayerProcessor to receive callbacks during a player build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class BuildPlayerProcessor extends Object implements IOrderedCallback {
        /** Implement this function to receive a callback before a player build starts.
         * @param buildPlayerContext A context tied to the scheduled player build.
         */
        PrepareForBuild(buildPlayerContext: BuildPlayerContext): void
        /** Returns the relative callback order for callbacks.  Callbacks with lower values are called before ones with higher values.
         */
        readonly callbackOrder: number
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IPreprocessBuildWithReport extends IOrderedCallback {
        /** Implement this function to receive a callback before the build is started.
         * @param report A report containing information about the build, such as its target platform and output path.
         */
        OnPreprocessBuild(report: BuildReport): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Array } from "System";
    import { BuildOptions } from "UnityEditor";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IFilterBuildAssemblies extends IOrderedCallback {
        /** Will be called after building script assemblies, but makes it possible to filter away unwanted scripts to be included.
         * @param buildOptions The current build options.
         * @param assemblies The list of assemblies that will be included.
         * @returns Returns the filtered list of assemblies that are included in the build. 
         */
        OnFilterAssemblies(buildOptions: BuildOptions, assemblies: Array<string>): Array<string>
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IPostprocessBuildWithReport extends IOrderedCallback {
        /** Implement this function to receive a callback after the build is complete.
         * @param report A BuildReport containing information about the build, such as the target platform and output path.
         */
        OnPostprocessBuild(report: BuildReport): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IPostBuildPlayerScriptDLLs extends IOrderedCallback {
        /** Implement this interface to receive a callback just after the player scripts have been compiled.
         * @param report A report containing information about the build, such as its target platform and output path.
         */
        OnPostBuildPlayerScriptDLLs(report: BuildReport): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IProcessSceneWithReport extends IOrderedCallback {
        /** Implement this function to receive a callback for each Scene during the build.
         * @param scene The current Scene being processed.
         * @param report A report containing information about the current build. When this callback is invoked for Scene loading during Editor playmode, this parameter will be null.
         */
        OnProcessScene(scene: any, report: BuildReport): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { BuildTarget } from "UnityEditor";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IActiveBuildTargetChanged extends IOrderedCallback {
        /** This function is called automatically when the active build platform has changed.
         * @param previousTarget The build target before the change.
         * @param newTarget The new active build target.
         */
        OnActiveBuildTargetChanged(previousTarget: BuildTarget, newTarget: BuildTarget): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { ValueType } from "System";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IPreprocessShaders extends IOrderedCallback {
        OnProcessShader(shader: any, snippet: any, data: any): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { ValueType } from "System";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IPreprocessComputeShaders extends IOrderedCallback {
        OnProcessComputeShader(shader: any, kernelName: string, data: any): void
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { BuildReport } from "UnityEditor.Build.Reporting";
    import { Object } from "System";
    // @jsb.RequiredDefines("UNITY_EDITOR")
    interface IUnityLinkerProcessor extends IOrderedCallback {
        /** Generates additional link.xml files for preserving additional types and their members.
         * @param report The current built report.
         * @param data Information about the current run of UnityLinker.
         * @returns The file path to the generated link.xml file. If the path is relative, GenerateAdditionalLinkXmlFile combines it with the working directory to make an absolute path. 
         */
        GenerateAdditionalLinkXmlFile(report: BuildReport, data: any): string
    }
}
declare module "UnityEditor.Build" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { BuildTargetGroup } from "UnityEditor";
    /** Build Target by name.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class NamedBuildTarget extends ValueType {
        constructor()
        ToBuildTargetGroup(): BuildTargetGroup
        GetHashCode(): number
        Equals(obj: Object): boolean
        Equals(other: NamedBuildTarget): boolean
        CompareTo(other: NamedBuildTarget): number
        static FromBuildTargetGroup(buildTargetGroup: BuildTargetGroup): NamedBuildTarget
        static op_Equality(lhs: NamedBuildTarget, rhs: NamedBuildTarget): boolean
        static op_Inequality(lhs: NamedBuildTarget, rhs: NamedBuildTarget): boolean
        // js_op_overloading: static ==(lhs: NamedBuildTarget, rhs: NamedBuildTarget): boolean
        /** Name of the build target.
         */
        readonly TargetName: string
        /** Unknown.
         */
        static readonly Unknown: NamedBuildTarget
        /** Desktop Standalone.
         */
        static readonly Standalone: NamedBuildTarget
        /** Server.
         */
        static readonly Server: NamedBuildTarget
        /** iOS.
         */
        static readonly iOS: NamedBuildTarget
        /** Android.
         */
        static readonly Android: NamedBuildTarget
        /** WebGL.
         */
        static readonly WebGL: NamedBuildTarget
        /** Windows Store Apps.
         */
        static readonly WindowsStoreApps: NamedBuildTarget
        /** PS4.
         */
        static readonly PS4: NamedBuildTarget
        /** Xbox One.
         */
        static readonly XboxOne: NamedBuildTarget
        /** TvOS.
         */
        static readonly tvOS: NamedBuildTarget
        /** Nintendo Switch.
         */
        static readonly NintendoSwitch: NamedBuildTarget
        /** Stadia.
         */
        static readonly Stadia: NamedBuildTarget
        /** LinuxHeadlessSimulation.
         */
        static readonly LinuxHeadlessSimulation: NamedBuildTarget
        /** EmbeddedLinux.
         */
        static readonly EmbeddedLinux: NamedBuildTarget
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Contains information about which scenes in a build have references to an Asset in the build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ScenesUsingAsset extends ValueType {
        constructor()
        /** The asset path.
         */
        readonly assetPath: string
        /** The list of scenes in the build referring to the asset, identified by a string containing the scene index in the BuildPlayerOptions.scenes list, as well as the scene path.
         */
        readonly scenePaths: Array<string>
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Array } from "System";
    /** An extension to the BuildReport class that tracks how Assets contribute to the size of the build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PackedAssets extends Object {
        constructor()
        /** The file path to the Asset package, relative to the Data folder of the build.
         */
        readonly shortPath: string
        /** The header size of the packed Asset file.
         */
        readonly overhead: number
        /** An array of PackedAssetInfo objects that holds information about the Assets that are included in the PackedAssets bundle, such as packed Asset size and type.
         */
        readonly contents: Array<PackedAssetInfo>
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** This class provides constant values for some of the common roles used by files in the build. The role of each file in the build is available in BuildFile.role.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class CommonRoles extends Object {
        /** The BuildFile.role value of a file that contains the packed content of a Scene.
         */
        static readonly scene: string
        /** The BuildFile.role value of a file that contains asset objects which are shared between Scenes. Examples of asset objects are textures, models, and audio.
         */
        static readonly sharedAssets: string
        /** The BuildFile.role value of the file that contains the contents of the project's "Resources" folder, packed into a single file.
         */
        static readonly resourcesFile: string
        /** The BuildFile.role value of built AssetBundle files.
         */
        static readonly assetBundle: string
        /** The BuildFile.role value of a manifest AssetBundle, which is an AssetBundle that contains information about other AssetBundles and their dependencies.
         */
        static readonly manifestAssetBundle: string
        /** The BuildFile.role value of an AssetBundle manifest file, produced during the build process, that contains information about the bundle and its dependencies.
         */
        static readonly assetBundleTextManifest: string
        /** The BuildFile.role value of a managed assembly, containing compiled script code.
         */
        static readonly managedLibrary: string
        /** The BuildFile.role value of a managed library that is present in the build due to being a dependency of a CommonRoles.managedLibrary.
         */
        static readonly dependentManagedLibrary: string
        /** The BuildFile.role value of an executable - the file that will actually be launched on the target device.
         */
        static readonly executable: string
        /** The BuildFile.role value of a file that contains streaming resource data.
         */
        static readonly streamingResourceFile: string
        /** The BuildFile.role value of files that have been copied into the build without modification from the StreamingAssets folder in the project.
         */
        static readonly streamingAsset: string
        /** The BuildFile.role value of the file that contains configuration information for the very early stages of engine startup.
         */
        static readonly bootConfig: string
        /** The BuildFile.role value of the file that contains built-in resources for the engine.
         */
        static readonly builtInResources: string
        /** The BuildFile.role value of the file that contains Unity's built-in shaders, such as the Standard shader.
         */
        static readonly builtInShaders: string
        /** The BuildFile.role value of the file that provides config information used in Low Integrity mode on Windows.
         */
        static readonly appInfo: string
        /** The BuildFile.role value of files that provide the managed API for Unity.
         */
        static readonly managedEngineApi: string
        /** The BuildFile.role value of files that make up the Mono runtime itself.
         */
        static readonly monoRuntime: string
        /** The BuildFile.role value of files that are used as configuration data by the Mono runtime.
         */
        static readonly monoConfig: string
        /** The BuildFile.role value of files that contain information for debuggers.
         */
        static readonly debugInfo: string
        /** The BuildFile.role value of the file that contains global Project Settings data for the player.
         */
        static readonly globalGameManagers: string
        /** The BuildFile.role value of the executable that is used to capture crashes from the player.
         */
        static readonly crashHandler: string
        /** The BuildFile.role value of the main Unity runtime when it is built as a separate library.
         */
        static readonly engineLibrary: string
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { GUID } from "UnityEditor";
    /** Contains information about a single packed Asset.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PackedAssetInfo extends ValueType {
        constructor()
        /** The unique identifier of the packed Asset.
         */
        readonly id: number
        /** The type of source Asset that the build process used to generate the package Asset, such as image, Mesh or audio types.
         */
        readonly type: any
        /** The size of the packed Asset.
         */
        readonly packedSize: number
        /** The offset in a PackedAssets file that indicates the beginning of the packed Asset.
         */
        readonly offset: number
        /** The Global Unique Identifier (GUID) of the source Asset that the build process used to generate the packed Asset.
         */
        readonly sourceAssetGUID: GUID
        /** The file path to the source Asset that the build process used to generate the package Asset, relative to the Project directory.
         */
        readonly sourceAssetPath: string
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    import { IEnumerable } from "System.Collections.Generic";
    /** The StrippingInfo object contains information about which native code modules in the engine are still present in the build, and the reasons why they are still present.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class StrippingInfo extends ScriptableObject {
        constructor()
        /** Returns the list of dependencies or reasons that caused the given entity to be included in the build.
         * @param entityName The name of an engine module, class, or other entity present in the build.
         * @returns A list of modules, classes, or other entities that caused the provided entity to be included in the build. 
         */
        GetReasonsForIncluding(entityName: string): IEnumerable<string>
        /** The native engine modules that were included in the build.
         */
        readonly includedModules: IEnumerable<string>
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    /** Describes the outcome of the build process.
     */
    enum BuildResult {
        /** Indicates that the outcome of the build is in an unknown state.
         */
        Unknown = 0,
        /** Indicates that the build completed successfully.
         */
        Succeeded = 1,
        /** Indicates that the build failed.
         */
        Failed = 2,
        /** Indicates that the build was cancelled by the user.
         */
        Cancelled = 3,
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType, DateTime } from "System";
    import { GUID, BuildTarget, BuildTargetGroup, BuildOptions } from "UnityEditor";
    /** Contains overall summary information about a build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildSummary extends ValueType {
        constructor()
        /** The time the build was started.
         */
        readonly buildStartedAt: DateTime
        /** The Application.buildGUID of the build.
         */
        readonly guid: GUID
        /** The platform that the build was created for.
         */
        readonly platform: BuildTarget
        /** The platform group the build was created for.
         */
        readonly platformGroup: BuildTargetGroup
        /** The BuildOptions used for the build, as passed to BuildPipeline.BuildPlayer.
         */
        readonly options: BuildOptions
        /** The output path for the build, as provided to BuildPipeline.BuildPlayer.
         */
        readonly outputPath: string
        /** The total size of the build output, in bytes.
         */
        readonly totalSize: number
        /** The total time taken by the build process.
         */
        readonly totalTime: any
        /** The time the build ended.
         */
        readonly buildEndedAt: DateTime
        /** The total number of errors and exceptions recorded during the build process.
         */
        readonly totalErrors: number
        /** The total number of warnings recorded during the build process.
         */
        readonly totalWarnings: number
        /** The outcome of the build.
         */
        readonly result: BuildResult
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType, Enum } from "System";
    /** Contains information about a single log message recorded during the build process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildStepMessage extends ValueType {
        constructor()
        /** The LogType of the log message.
         */
        readonly type: any
        /** The text content of the log message.
         */
        readonly content: string
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** Contains information about a single file produced by the build process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildFile extends ValueType {
        constructor()
        toString(): string
        /** The unique indentifier of the build file.
         */
        readonly id: number
        /** The absolute path of the file produced by the build process.
         */
        readonly path: string
        /** The role the file plays in the build output.
         */
        readonly role: string
        /** The total size of the file, in bytes.
         */
        readonly size: number
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { ValueType, Array } from "System";
    /** Contains information about a single step in the build process.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class BuildStep extends ValueType {
        constructor()
        toString(): string
        /** The name of this build step.
         */
        readonly name: string
        /** The total duration for this build step.
         */
        readonly duration: any
        /** All log messages recorded during this build step, in the order of which they occurred.
         */
        readonly messages: Array<BuildStepMessage>
        /** The nesting depth of the build step.
         */
        readonly depth: number
    }
}
declare module "UnityEditor.Build.Reporting" {
    import * as jsb from "jsb";
    import { Object } from "UnityEngine";
    import { Array } from "System";
    /** An extension to the BuildReport class that tracks which scenes in the build have references to a specific asset in the build.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ScenesUsingAssets extends Object {
        constructor()
        /** An array of ScenesUsingAsset that holds information about the Assets that are included in the build.
         */
        readonly list: Array<ScenesUsingAsset>
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class UsbDevice extends ValueType {
        constructor()
        toString(): string
        readonly vendorId: number
        readonly productId: number
        readonly revision: number
        readonly udid: string
        readonly name: string
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class Usb extends Object {
        constructor()
        static OnDevicesChanged(devices: Array<UsbDevice>): void
        static DevicesChanged(op: "add" | "remove", fn: (devices: Array<UsbDevice>) => void): void
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    enum DevDeviceState {
        Disconnected = 0,
        Connected = 1,
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    enum DevDeviceFeatures {
        None = 0,
        PlayerConnection = 1,
        RemoteConnection = 2,
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DevDevice extends ValueType {
        constructor(id: string, name: string, type: string, module_: string, state: DevDeviceState, features: DevDeviceFeatures)
        toString(): string
        readonly isConnected: boolean
        static readonly none: DevDevice
        readonly id: string
        readonly name: string
        readonly type: string
        readonly module_: string
        readonly state: DevDeviceState
        readonly features: DevDeviceFeatures
    }
}
declare module "UnityEditor.Hardware" {
    import * as jsb from "jsb";
    import { Object, Array } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DevDeviceList extends Object {
        constructor()
        static OnChanged(): void
        static FindDevice(deviceId: string, device: jsb.Out<DevDevice>): boolean
        static GetDevices(): Array<DevDevice>
        static Changed(op: "add" | "remove", fn: () => void): void
    }
}
declare module "UnityEditor.Callbacks" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Add this attribute to a method to get a notification just after building the player.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PostProcessBuildAttribute extends Object {
        constructor(callbackOrder: number)
        constructor()
    }
}
declare module "UnityEditor.Callbacks" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Add this attribute to a method to get a notification just after building the Scene.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PostProcessSceneAttribute extends Object {
        constructor(callbackOrder: number, version: number)
        constructor(callbackOrder: number)
        constructor()
    }
}
declare module "UnityEditor.Callbacks" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Add this attribute to a method to get a notification after scripts have been reloaded.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class DidReloadScripts extends Object {
        constructor(callbackOrder: number)
        constructor()
    }
}
declare module "UnityEditor.Callbacks" {
    import * as jsb from "jsb";
    /** Indicates whether OnOpenAssetAttribute decorated method is a validation function that checks if asset opening is handled by Unity or a custom script.
     */
    enum OnOpenAssetAttributeMode {
        /** Indicates that OnOpenAssetAttribute decorated method is an opening function.
         */
        Execute = 0,
        /** Indicates that OnOpenAssetAttribute decorated method is a validation function.
         */
        Validate = 1,
    }
}
declare module "UnityEditor.Callbacks" {
    import * as jsb from "jsb";
    import { Object } from "System";
    @jsb.RequiredDefines("UNITY_EDITOR")
    class OnOpenAssetAttribute extends Object {
        constructor(callbackOrder: number, attributeMode: OnOpenAssetAttributeMode)
        constructor(attributeMode: OnOpenAssetAttributeMode)
        constructor(callbackOrder: number)
        constructor()
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { SceneManager } from "UnityEngine.SceneManagement";
    import { SceneAsset } from "UnityEditor";
    import { ValueType, Array } from "System";
    import { Object, YieldInstruction } from "UnityEngine";
    /** Scene management in the Editor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class EditorSceneManager extends SceneManager {
        constructor()
        static IsReloading(scene: any): boolean
        /** Open a Scene in the Editor.
         * @param scenePath The path of the Scene. This should be relative to the Project folder; for example, "AssetsMyScenesMyScene.unity".
         * @param mode Allows you to select how to open the specified Scene, and whether to keep existing Scenes in the Hierarchy. See SceneManagement.OpenSceneMode for more information about the options.
         * @returns A reference to the opened Scene. 
         */
        static OpenScene(scenePath: string, mode: OpenSceneMode): any
        static OpenScene(scenePath: string): any
        /** Create a new Scene.
         * @param setup Whether the new Scene should use the default set of GameObjects.
         * @param mode Whether to keep existing Scenes open.
         * @returns A reference to the new Scene. 
         */
        static NewScene(setup: NewSceneSetup, mode: NewSceneMode): any
        static NewScene(setup: NewSceneSetup): any
        static NewPreviewScene(): any
        /** Close the Scene. If removeScene flag is true, the closed Scene will also be removed from EditorSceneManager.
         * @param scene The Scene to be closed/removed.
         * @param removeScene Bool flag to indicate if the Scene should be removed after closing.
         * @returns Returns true if the Scene is closed/removed. 
         */
        static CloseScene(scene: any, removeScene: boolean): boolean
        /** Closes a preview Scene created by NewPreviewScene.
         * @param scene The preview Scene to close.
         * @returns True if the Scene was successfully closed. 
         */
        static ClosePreviewScene(scene: any): boolean
        /** Is the Scene a preview Scene?
         * @param scene The Scene to check.
         * @returns True if the Scene is a preview Scene. 
         */
        static IsPreviewScene(scene: any): boolean
        /** Is this object part of a preview Scene?
         * @param obj The object to check.
         * @returns True if this object is part of a preview Scene. 
         */
        static IsPreviewSceneObject(obj: Object): boolean
        /** Allows you to reorder the Scenes currently open in the Hierarchy window. Moves the source Scene so it comes before the destination Scene.
         * @param src The Scene to move.
         * @param dst The Scene which should come directly after the source Scene in the hierarchy.
         */
        static MoveSceneBefore(src: any, dst: any): void
        /** Allows you to reorder the Scenes currently open in the Hierarchy window. Moves the source Scene so it comes after the destination Scene.
         * @param src The Scene to move.
         * @param dst The Scene which should come directly before the source Scene in the hierarchy.
         */
        static MoveSceneAfter(src: any, dst: any): void
        static SaveOpenScenes(): boolean
        /** Save a list of Scenes.
         * @param scenes List of Scenes that should be saved.
         * @returns True if the save succeeded. Otherwise false. 
         */
        static SaveScenes(scenes: Array<any>): boolean
        /** Asks whether the modfied input Scenes should be saved.
         * @param scenes Scenes that should be saved if they are modified.
         * @returns Returns true if the user clicked Save or Don't Save to indicate that that it is ok to close the input scenes after the dialog closes. Returns false if the user clicked Cancel to abort. 
         */
        static SaveModifiedScenesIfUserWantsTo(scenes: Array<any>): boolean
        /** Shows a save dialog if an Untitled Scene exists in the current Scene manager setup.
         * @param dialogContent Text shown in the save dialog.
         * @returns True if the Scene is saved or if there is no Untitled Scene. 
         */
        static EnsureUntitledSceneHasBeenSaved(dialogContent: string): boolean
        /** Mark the specified Scene as modified.
         * @param scene The Scene to be marked as modified.
         * @returns Whether the Scene was successfully marked as dirty. 
         */
        static MarkSceneDirty(scene: any): boolean
        static MarkAllScenesDirty(): void
        static GetSceneManagerSetup(): Array<SceneSetup>
        /** Restore the setup of the SceneManager.
         * @param value In this array, at least one Scene should be loaded, and there must be one active Scene.
         */
        static RestoreSceneManagerSetup(value: Array<SceneSetup>): void
        /** Detects cross-Scene references in a Scene.
         * @param scene Scene to check for cross-Scene references.
         * @returns Was any cross-Scene references found. 
         */
        static DetectCrossSceneReferences(scene: any): boolean
        /** Return the culling mask set on the given Scene.
         * @param scene The scene to get the culling mask from.
         * @returns The scene's current culling mask as a bitfield. 
         */
        static GetSceneCullingMask(scene: any): number
        /** Set the culling mask on this scene to this value.
Cameras will only render objects in Scenes that have the same bits set in their culling mask.
         * @param scene The scene to set the culling mask on.
         * @param sceneCullingMask The value of the culling mask, stored as a bitfield.
         */
        static SetSceneCullingMask(scene: any, sceneCullingMask: number): void
        static CalculateAvailableSceneCullingMask(): number
        static SaveCurrentModifiedScenesIfUserWantsTo(): boolean
        /** Save a Scene.
         * @param scene The Scene to be saved.
         * @param dstScenePath The file path to save the Scene to. If the path is empty, the current open Scene is overwritten. If it has not yet been saved at all, a save dialog is shown.
         * @param saveAsCopy If set to true, the Scene is saved without changing the current Scene, and without clearing the unsaved changes marker.
         * @returns True if the save succeeded, otherwise false. 
         */
        static SaveScene(scene: any, dstScenePath: string, saveAsCopy: boolean): boolean
        static SaveScene(scene: any, dstScenePath: string): boolean
        static SaveScene(scene: any): boolean
        /** This method allows you to load a Scene during playmode in the editor, without requiring the Scene to be included in the Scene list.
         * @param path Path to Scene to load.
         * @param parameters Parameters used to load the Scene SceneManagement.LoadSceneParameters.
         * @returns Scene that is loading. 
         */
        static LoadSceneInPlayMode(path: string, parameters: any): any
        /** This method allows you to load a Scene during playmode in the editor, without requiring the Scene to be included in the Scene list.
         * @param path Path to Scene to load.
         * @param parameters Parameters to apply to loading. See SceneManagement.LoadSceneParameters.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static LoadSceneAsyncInPlayMode(path: string, parameters: any): any
        /** The number of loaded Scenes.
         */
        static readonly loadedSceneCount: number
        static readonly loadedRootSceneCount: number
        /** The current amount of active preview Scenes.
         */
        static readonly previewSceneCount: number
        /** Controls whether cross-Scene references are allowed in the Editor.
         */
        static preventCrossSceneReferences: boolean
        /** Loads this SceneAsset when you start Play Mode.
         */
        static playModeStartScene: SceneAsset
        /** Use SceneCullingMasks.DefaultSceneCullingMask instead.
         */
        static readonly DefaultSceneCullingMask: number
        static activeSceneChangedInEditMode(op: "add" | "remove", fn: (arg0: any, arg1: any) => void): void
        static newSceneCreated(op: "add" | "remove", fn: (scene: any, setup: NewSceneSetup, mode: NewSceneMode) => void): void
        static sceneOpening(op: "add" | "remove", fn: (path: string, mode: OpenSceneMode) => void): void
        static sceneOpened(op: "add" | "remove", fn: (scene: any, mode: OpenSceneMode) => void): void
        static sceneClosing(op: "add" | "remove", fn: (scene: any, removingScene: boolean) => void): void
        static sceneClosed(op: "add" | "remove", fn: (scene: any) => void): void
        static sceneSaving(op: "add" | "remove", fn: (scene: any, path: string) => void): void
        static sceneSaved(op: "add" | "remove", fn: (scene: any) => void): void
        static sceneDirtied(op: "add" | "remove", fn: (scene: any) => void): void
    }
}
declare module "UnityEngine.SceneManagement" {
    import * as jsb from "jsb";
    import { Object, ValueType, Enum } from "System";
    import { GameObject, YieldInstruction } from "UnityEngine";
    /** Scene management at run-time.
     */
    class SceneManager extends Object {
        constructor()
        static GetActiveScene(): any
        /** Set the Scene to be active.
         * @param scene The Scene to be set.
         * @returns Returns false if the Scene is not loaded yet. 
         */
        static SetActiveScene(scene: any): boolean
        /** Searches all Scenes loaded for a Scene that has the given asset path.
         * @param scenePath Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
         */
        static GetSceneByPath(scenePath: string): any
        /** Searches through the Scenes loaded for a Scene with the given name.
         * @param name Name of Scene to find.
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
         */
        static GetSceneByName(name: string): any
        /** Get a Scene struct from a build index.
         * @param buildIndex Build index as shown in the Build Settings window.
         * @returns A reference to the Scene, if valid. If not, an invalid Scene is returned. 
         */
        static GetSceneByBuildIndex(buildIndex: number): any
        /** Get the Scene at index in the SceneManager's list of loaded Scenes.
         * @param index Index of the Scene to get. Index must be greater than or equal to 0 and less than SceneManager.sceneCount.
         * @returns A reference to the Scene at the index specified. 
         */
        static GetSceneAt(index: number): any
        /** Create an empty new Scene at runtime with the given name.
         * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
         * @param parameters Various parameters used to create the Scene.
         * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
         */
        static CreateScene(sceneName: string, parameters: any): any
        /** Create an empty new Scene at runtime with the given name.
         * @param sceneName The name of the new Scene. It cannot be empty or null, or same as the name of the existing Scenes.
         * @param parameters Various parameters used to create the Scene.
         * @returns A reference to the new Scene that was created, or an invalid Scene if creation failed. 
         */
        static CreateScene(sceneName: string): any
        /** This will merge the source Scene into the destinationScene.
         * @param sourceScene The Scene that will be merged into the destination Scene.
         * @param destinationScene Existing Scene to merge the source Scene into.
         */
        static MergeScenes(sourceScene: any, destinationScene: any): void
        /** Move a GameObject from its current Scene to a new Scene.
         * @param go GameObject to move.
         * @param scene Scene to move into.
         */
        static MoveGameObjectToScene(go: GameObject, scene: any): void
        /** Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
         */
        static LoadScene(sceneName: string, mode: any): void
        /** Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param parameters Various parameters used to load the Scene.
         * @returns A handle to the Scene being loaded. 
         */
        static LoadScene(sceneName: string, parameters: any): any
        /** Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode Allows you to specify whether or not to load the Scene additively. See SceneManagement.LoadSceneMode for more information about the options.
         */
        static LoadScene(sceneBuildIndex: number, mode: any): void
        /** Loads the Scene by its name or index in Build Settings.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param parameters Various parameters used to load the Scene.
         * @returns A handle to the Scene being loaded. 
         */
        static LoadScene(sceneBuildIndex: number, parameters: any): any
        static LoadScene(sceneName: string): void
        static LoadScene(sceneBuildIndex: number): void
        /** Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static LoadSceneAsync(sceneBuildIndex: number, mode: any): any
        /** Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static LoadSceneAsync(sceneBuildIndex: number, parameters: any): any
        /** Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static LoadSceneAsync(sceneName: string, mode: any): any
        /** Loads the Scene asynchronously in the background.
         * @param sceneName Name or path of the Scene to load.
         * @param sceneBuildIndex Index of the Scene in the Build Settings to load.
         * @param mode If LoadSceneMode.Single then all current Scenes will be unloaded before loading.
         * @param parameters Struct that collects the various parameters into a single place except for the name and index.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static LoadSceneAsync(sceneName: string, parameters: any): any
        static LoadSceneAsync(sceneBuildIndex: number): any
        static LoadSceneAsync(sceneName: string): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(sceneBuildIndex: number, options: any): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(sceneName: string, options: any): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(scene: any, options: any): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(sceneBuildIndex: number): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(sceneName: string): any
        /** Destroys all GameObjects associated with the given Scene and removes the Scene from the SceneManager.
         * @param sceneBuildIndex Index of the Scene in BuildSettings.
         * @param sceneName Name or path of the Scene to unload.
         * @param scene Scene to unload.
         * @param options Scene unloading options.
         * @returns Use the AsyncOperation to determine if the operation has completed. 
         */
        static UnloadSceneAsync(scene: any): any
        /** The total number of currently loaded Scenes.
         */
        static readonly sceneCount: number
        /** Number of Scenes in Build Settings.
         */
        static readonly sceneCountInBuildSettings: number
        static sceneLoaded(op: "add" | "remove", fn: (arg0: any, arg1: any) => void): void
        static sceneUnloaded(op: "add" | "remove", fn: (arg0: any) => void): void
        static activeSceneChanged(op: "add" | "remove", fn: (arg0: any, arg1: any) => void): void
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Masks that control what kind of Scene views and Game views Unity should render a GameObject in.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class SceneCullingMasks extends Object {
        /** Specifies the default culling mask for a Scene.  Use the bits from this Scene culling mask for objects that you want to render in both in the Game view and the Scene view.
         */
        static readonly DefaultSceneCullingMask: number
        /** The bits from this mask specify GameObjects that Unity should render in Game view.
         */
        static readonly GameViewObjects: number
        /** The bits from this mask specify GameObjects that Unity should render in Scene views showing the main stage.
         */
        static readonly MainStageSceneViewObjects: number
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    /** Used when opening a Scene in the Editor to specify how a Scene should be opened.
     */
    enum OpenSceneMode {
        /** Closes all current open Scenes and loads a Scene.
         */
        Single = 0,
        /** Adds a Scene to the current open Scenes and loads it.
         */
        Additive = 1,
        /** Adds a Scene to the current open Scenes without loading it. It will show up as 'unloaded' in the Hierarchy Window.
         */
        AdditiveWithoutLoading = 2,
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    /** Used when creating a new Scene in the Editor.
     */
    enum NewSceneMode {
        /** All current open Scenes are closed and the newly created Scene are opened.
         */
        Single = 0,
        /** The newly created Scene is added to the current open Scenes.
         */
        Additive = 1,
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    /** Used when creating a new Scene in the Editor.
     */
    enum NewSceneSetup {
        /** No game objects are added to the new Scene.
         */
        EmptyScene = 0,
        /** Adds default game objects to the new Scene (a light and camera).
         */
        DefaultGameObjects = 1,
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { Object, ValueType, Array } from "System";
    import { GenericMenu } from "UnityEditor";
    import { GameObject, Transform } from "UnityEngine";
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class SceneHierarchyHooks extends Object {
        static ReloadAllSceneHierarchies(): void
        static CanSetNewParent(transform: Transform, newParent: Transform): boolean
        static CanMoveTransformToScene(transform: Transform, scene: any): boolean
        static addItemsToGameObjectContextMenu(op: "add" | "remove", fn: (arg1: GenericMenu, arg2: GameObject) => void): void
        static addItemsToSceneHeaderContextMenu(op: "add" | "remove", fn: (arg1: GenericMenu, arg2: any) => void): void
        static addItemsToSubSceneHeaderContextMenu(op: "add" | "remove", fn: (arg1: GenericMenu, arg2: SceneHierarchyHooks.SubSceneInfo) => void): void
        static addItemsToCreateMenu(op: "add" | "remove", fn: (obj: GenericMenu) => void): void
        static provideSubScenes(op: "get"): () => Array<SceneHierarchyHooks.SubSceneInfo>
        static provideSubScenes(op: "add" | "remove" | "set", fn?: () => Array<SceneHierarchyHooks.SubSceneInfo>): void
        static provideSubScenes(op: "add" | "remove" | "set" | "get", fn?: () => Array<SceneHierarchyHooks.SubSceneInfo>): () => Array<SceneHierarchyHooks.SubSceneInfo> | void
        static provideSubSceneName(op: "get"): (arg: SceneHierarchyHooks.SubSceneInfo) => string
        static provideSubSceneName(op: "add" | "remove" | "set", fn?: (arg: SceneHierarchyHooks.SubSceneInfo) => string): void
        static provideSubSceneName(op: "add" | "remove" | "set" | "get", fn?: (arg: SceneHierarchyHooks.SubSceneInfo) => string): (arg: SceneHierarchyHooks.SubSceneInfo) => string | void
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Transform, Color32 } from "UnityEngine";
    import { SceneAsset } from "UnityEditor";
    namespace SceneHierarchyHooks {
        @jsb.RequiredDefines("UNITY_EDITOR")
        class SubSceneInfo extends ValueType {
            constructor()
            readonly isValid: boolean
            transform: Transform
            scene: any
            sceneAsset: SceneAsset
            sceneName: string
            color: Color32
        }
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** The setup information for a Scene in the SceneManager. This cannot be used in Play Mode. 
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class SceneSetup extends Object {
        constructor()
        /** Path of the Scene. Should be relative to the project folder. Like: "AssetsMyScenesMyScene.unity".
         */
        path: string
        /** If the Scene is loaded.
         */
        isLoaded: boolean
        /** If the Scene is active.
         */
        isActive: boolean
        isSubScene: boolean
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { Object, ValueType } from "System";
    import { GameObject, Camera } from "UnityEngine";
    /** Utility methods related to stages.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class StageUtility extends Object {
        /** Is the given GameObject rendered by the given Camera?
         * @param gameObject The GameObject to check.
         * @param camera The camera to check.
         * @returns True if the GameObject is rendered by the camera. 
         */
        static IsGameObjectRenderedByCamera(gameObject: GameObject, camera: Camera): boolean
        /** Specifies whether the given Camera currently renders the given GameObject and the GameObject is also part of an editable scene.
         * @param gameObject The GameObject to check.
         * @param camera The Camera to check.
         * @returns True if the GameObject is rendered by the camera and part of an editable scene. 
         */
        static IsGameObjectRenderedByCameraAndPartOfEditableScene(gameObject: GameObject, camera: Camera): boolean
        static GetCurrentStage(): Stage
        static GetMainStage(): MainStage
        /** Get the Stage object that contains the input GameObject or Scene.
         * @returns The Stage that contains either the GameObject or the Scene. 
         */
        static GetStage(gameObject: GameObject): Stage
        /** Get the Stage object that contains the input GameObject or Scene.
         * @returns The Stage that contains either the GameObject or the Scene. 
         */
        static GetStage(scene: any): Stage
        static GetCurrentStageHandle(): StageHandle
        static GetMainStageHandle(): StageHandle
        /** Get the stage in which the given GameObject exists.
         * @param gameObject The GameObject to find the stage of.
         * @returns The stage of the GameObject. 
         */
        static GetStageHandle(gameObject: GameObject): StageHandle
        /** Get the stage in which the given Scene exists.
         * @param scene The Scene to find the stage of.
         * @returns The stage of the Scene. 
         */
        static GetStageHandle(scene: any): StageHandle
        static GoToMainStage(): void
        static GoBackToPreviousStage(): void
        /** Navigates the Editor to the specified stage.
         * @param stage The stage to navigate to.
         * @param setAsFirstItemAfterMainStage When set to true, the new stage replaces existing stages in the breadcrumbs, apart from the main stage.
         */
        static GoToStage(stage: Stage, setAsFirstItemAfterMainStage: boolean): void
        /** Place the given GameObject in the current stage being edited.
         * @param gameObject The GameObject to be placed in the current stage.
         */
        static PlaceGameObjectInCurrentStage(gameObject: GameObject): void
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    /** The PreviewSceneStage class represents an editing context based on a single preview Scene.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PreviewSceneStage extends Stage {
        /** The preview Scene this stage controls. Stage content should be moved into this Scene.
         */
        readonly scene: any
        /** See Stage.stageHandle.
         */
        readonly stageHandle: StageHandle
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { ScriptableObject } from "UnityEngine";
    /** The Stage class represents an editing context which includes a collection of Scenes.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class Stage extends ScriptableObject {
        GetCombinedSceneCullingMaskForCamera(): number
        /** The path of the Asset file associated with the stage, relative to the project root folder.
         */
        readonly assetPath: string
        /** The StageHandle struct for this stage.
         */
        readonly stageHandle: StageHandle
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { GameObject } from "UnityEngine";
    /** Struct that represents a stage handle.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class StageHandle extends ValueType {
        constructor()
        /** Does the stage contain the given GameObject?
         * @param gameObject The GameObject to check.
         * @returns True if the stage contains the given GameObject. 
         */
        Contains(gameObject: GameObject): boolean
        IsValid(): boolean
        Equals(other: Object): boolean
        Equals(other: StageHandle): boolean
        GetHashCode(): number
        static op_Equality(s1: StageHandle, s2: StageHandle): boolean
        static op_Inequality(s1: StageHandle, s2: StageHandle): boolean
        // js_op_overloading: static ==(s1: StageHandle, s2: StageHandle): boolean
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    /** The Main Stage contains all the currently open regular Scenes and is always available.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class MainStage extends Stage {
        constructor()
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    /** The PrefabStage class represents an editing context for Prefab Assets.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class PrefabStage extends PreviewSceneStage {
        GetCombinedSceneCullingMaskForCamera(): number
        /** Is this GameObject part of the loaded Prefab Asset contents in the Prefab stage?
         * @param gameObject The GameObject to check.
         * @returns True if the GameObject is part of the Prefab contents. 
         */
        IsPartOfPrefabContents(gameObject: GameObject): boolean
        ClearDirtiness(): void
        protected constructor()
        /** The root GameObject of the loaded Prefab Asset contents.
         */
        readonly prefabContentsRoot: GameObject
        /** The root of the Prefab instance that you opened Prefab Mode through.
         */
        readonly openedFromInstanceRoot: GameObject
        /** A GameObject inside the Prefab instance that you opened Prefab Mode through.
         */
        readonly openedFromInstanceObject: GameObject
        /** The Prefab Stage can be opened either in isolation or in context.
         */
        readonly mode: PrefabStage.Mode
        /** The asset path where the Prefab Asset file is stored, relative to the project root.
         */
        readonly assetPath: string
        static prefabStageOpened(op: "add" | "remove", fn: (obj: PrefabStage) => void): void
        static prefabStageClosing(op: "add" | "remove", fn: (obj: PrefabStage) => void): void
        static prefabStageDirtied(op: "add" | "remove", fn: (obj: PrefabStage) => void): void
        static prefabSaving(op: "add" | "remove", fn: (obj: GameObject) => void): void
        static prefabSaved(op: "add" | "remove", fn: (obj: GameObject) => void): void
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    namespace PrefabStage {
        enum Mode {
            InIsolation = 0,
            InContext = 1,
        }
    }
}
declare module "UnityEditor.SceneManagement" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GameObject } from "UnityEngine";
    /** Utility methods related to Prefab stages.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    abstract class PrefabStageUtility extends Object {
        static OpenPrefab(prefabAssetPath: string, openedFromInstance: GameObject, prefabStageMode: PrefabStage.Mode): PrefabStage
        /** Opens a Prefab Asset in Prefab Mode.
         * @param prefabAssetPath File path for the Prefab Asset to open in Prefab Mode.
         * @param openedFromInstance Opens Prefab Mode in context of this Prefab instance GameObject.
         * @param prefabStageMode Mode that determines whether to open in isolation or in context.
         * @returns The opened PrefabStage. 
         */
        static OpenPrefab(prefabAssetPath: string, openedFromInstance: GameObject): PrefabStage
        /** Opens a Prefab Asset in Prefab Mode.
         * @param prefabAssetPath File path for the Prefab Asset to open in Prefab Mode.
         * @param openedFromInstance Opens Prefab Mode in context of this Prefab instance GameObject.
         * @param prefabStageMode Mode that determines whether to open in isolation or in context.
         * @returns The opened PrefabStage. 
         */
        static OpenPrefab(prefabAssetPath: string): PrefabStage
        static GetCurrentPrefabStage(): PrefabStage
        /** Get the Prefab stage which contains the given GameObject.
         * @param gameObject The GameObject to check.
         * @returns The containing Prefab stage. 
         */
        static GetPrefabStage(gameObject: GameObject): PrefabStage
    }
}
declare module "UnityEditor.Scripting" {
    import * as jsb from "jsb";
    import { Object } from "System";
    /** Representation of managed debugger in UnityEditor.
     */
    @jsb.RequiredDefines("UNITY_EDITOR")
    class ManagedDebugger extends Object {
        constructor()
        static Disconnect(): void
        /** Returns true if there is a managed debugger attached to the UnityEditor, or false if there is not.
         */
        static readonly isAttached: boolean
        /** Returns true if managed debugger is enabled, or false if it is not.
         */
        static readonly isEnabled: boolean
        static debuggerAttached(op: "add" | "remove", fn: (obj: boolean) => void): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class AnimationTriggers extends Object {
        constructor()
        normalTrigger: string
        highlightedTrigger: string
        pressedTrigger: string
        selectedTrigger: string
        disabledTrigger: string
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    class Button extends Selectable implements IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler {
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        /*protected*/ constructor()
        onClick: Button.ButtonClickedEvent
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, AxisEventData, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { Array } from "System";
    import { Animator, Vector3 } from "UnityEngine";
    class Selectable extends UIBehaviour implements IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
        IsInteractable(): boolean
        FindSelectable(dir: Vector3): Selectable
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnMove(eventData: AxisEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnPointerEnter(eventData: PointerEventData): void
        OnPointerExit(eventData: PointerEventData): void
        OnSelect(eventData: BaseEventData): void
        OnDeselect(eventData: BaseEventData): void
        Select(): void
        static AllSelectablesNoAlloc(selectables: Array<Selectable>): number
        /*protected*/ constructor()
        static readonly allSelectablesArray: Array<Selectable>
        static readonly allSelectableCount: number
        navigation: Navigation
        transition: Selectable.Transition
        colors: ColorBlock
        spriteState: SpriteState
        animationTriggers: AnimationTriggers
        targetGraphic: Graphic
        interactable: boolean
        image: Image
        readonly animator: Animator
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { MonoBehaviour } from "UnityEngine";
    abstract class UIBehaviour extends MonoBehaviour {
        IsActive(): boolean
        IsDestroyed(): boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    enum CanvasUpdate {
        Prelayout = 0,
        Layout = 1,
        PostLayout = 2,
        PreRender = 3,
        LatePreRender = 4,
        MaxUpdateValue = 5,
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Transform } from "UnityEngine";
    interface ICanvasElement {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        IsDestroyed(): boolean
        readonly transform: Transform
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class CanvasUpdateRegistry extends Object {
        static RegisterCanvasElementForLayoutRebuild(element: ICanvasElement): void
        static TryRegisterCanvasElementForLayoutRebuild(element: ICanvasElement): boolean
        static RegisterCanvasElementForGraphicRebuild(element: ICanvasElement): void
        static TryRegisterCanvasElementForGraphicRebuild(element: ICanvasElement): boolean
        static UnRegisterCanvasElementForRebuild(element: ICanvasElement): void
        static DisableCanvasElementForRebuild(element: ICanvasElement): void
        static IsRebuildingLayout(): boolean
        static IsRebuildingGraphics(): boolean
        protected constructor()
        static readonly instance: CanvasUpdateRegistry
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { Color } from "UnityEngine";
    class ColorBlock extends ValueType {
        constructor()
        Equals(obj: Object): boolean
        Equals(other: ColorBlock): boolean
        GetHashCode(): number
        static op_Equality(point1: ColorBlock, point2: ColorBlock): boolean
        static op_Inequality(point1: ColorBlock, point2: ColorBlock): boolean
        // js_op_overloading: static ==(point1: ColorBlock, point2: ColorBlock): boolean
        normalColor: Color
        highlightedColor: Color
        pressedColor: Color
        selectedColor: Color
        disabledColor: Color
        colorMultiplier: number
        fadeDuration: number
        static defaultColorBlock: ColorBlock
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class ClipperRegistry extends Object {
        Cull(): void
        static Register(c: IClipper): void
        static Unregister(c: IClipper): void
        static Disable(c: IClipper): void
        protected constructor()
        static readonly instance: ClipperRegistry
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Rect } from "UnityEngine";
    abstract class Clipping extends Object {
        static FindCullAndClipWorldRect(rectMaskParents: any, validRect: jsb.Out<boolean>): Rect
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface IClipper {
        PerformClipping(): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { GameObject, RectTransform, Rect, Vector2 } from "UnityEngine";
    interface IClippable {
        RecalculateClipping(): void
        Cull(clipRect: Rect, validRect: boolean): void
        SetClipRect(value: Rect, validRect: boolean): void
        SetClipSoftness(clipSoftness: Vector2): void
        readonly gameObject: GameObject
        readonly rectTransform: RectTransform
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { GameObject } from "UnityEngine";
    abstract class DefaultControls extends Object {
        static CreatePanel(resources: DefaultControls.Resources): GameObject
        static CreateButton(resources: DefaultControls.Resources): GameObject
        static CreateText(resources: DefaultControls.Resources): GameObject
        static CreateImage(resources: DefaultControls.Resources): GameObject
        static CreateRawImage(resources: DefaultControls.Resources): GameObject
        static CreateSlider(resources: DefaultControls.Resources): GameObject
        static CreateScrollbar(resources: DefaultControls.Resources): GameObject
        static CreateToggle(resources: DefaultControls.Resources): GameObject
        static CreateInputField(resources: DefaultControls.Resources): GameObject
        static CreateDropdown(resources: DefaultControls.Resources): GameObject
        static CreateScrollView(resources: DefaultControls.Resources): GameObject
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { ICancelHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { RectTransform, Sprite } from "UnityEngine";
    import { Object } from "System";
    class Dropdown extends Selectable implements ICancelHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler {
        SetValueWithoutNotify(input: number): void
        RefreshShownValue(): void
        AddOptions(options: any): void
        AddOptions(options: any): void
        AddOptions(options: any): void
        ClearOptions(): void
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        OnCancel(eventData: BaseEventData): void
        Show(): void
        Hide(): void
        /*protected*/ constructor()
        template: RectTransform
        captionText: Text
        captionImage: Image
        itemText: Text
        itemImage: Image
        options: any
        onValueChanged: Dropdown.DropdownEvent
        alphaFadeSpeed: number
        value: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    import { Object as Object1, TextAnchor } from "UnityEngine";
    class FontData extends Object {
        constructor()
        static readonly defaultFontData: FontData
        font: any
        fontSize: number
        fontStyle: any
        bestFit: boolean
        minSize: number
        maxSize: number
        alignment: TextAnchor
        alignByGeometry: boolean
        richText: boolean
        horizontalOverflow: any
        verticalOverflow: any
        lineSpacing: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    abstract class FontUpdateTracker extends Object {
        static TrackText(t: Text): void
        static UntrackText(t: Text): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Material, Color, Vector4, RectTransform, Behaviour, Component, Texture, Vector2, Camera, Rect } from "UnityEngine";
    abstract class Graphic extends UIBehaviour implements ICanvasElement {
        SetAllDirty(): void
        SetLayoutDirty(): void
        SetVerticesDirty(): void
        SetMaterialDirty(): void
        SetRaycastDirty(): void
        OnCullingChanged(): void
        Rebuild(update: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        SetNativeSize(): void
        Raycast(sp: Vector2, eventCamera: Camera): boolean
        PixelAdjustPoint(point: Vector2): Vector2
        GetPixelAdjustedRect(): Rect
        CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean, useRGB: boolean): void
        CrossFadeColor(targetColor: Color, duration: number, ignoreTimeScale: boolean, useAlpha: boolean): void
        CrossFadeAlpha(alpha: number, duration: number, ignoreTimeScale: boolean): void
        RegisterDirtyLayoutCallback(action: () => void): void
        UnregisterDirtyLayoutCallback(action: () => void): void
        RegisterDirtyVerticesCallback(action: () => void): void
        UnregisterDirtyVerticesCallback(action: () => void): void
        RegisterDirtyMaterialCallback(action: () => void): void
        UnregisterDirtyMaterialCallback(action: () => void): void
        static readonly defaultGraphicMaterial: Material
        color: Color
        raycastTarget: boolean
        raycastPadding: Vector4
        readonly depth: number
        readonly rectTransform: RectTransform
        readonly canvas: any
        readonly canvasRenderer: any
        readonly defaultMaterial: Material
        material: Material
        readonly materialForRendering: Material
        readonly mainTexture: Texture
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { BaseRaycaster, PointerEventData, RaycastResult } from "UnityEngine.EventSystems";
    import { LayerMask, Camera } from "UnityEngine";
    import { Object } from "System";
    class GraphicRaycaster extends BaseRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
        readonly sortOrderPriority: number
        readonly renderOrderPriority: number
        ignoreReversedGraphics: boolean
        blockingObjects: GraphicRaycaster.BlockingObjects
        blockingMask: LayerMask
        readonly eventCamera: Camera
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Camera } from "UnityEngine";
    import { Object } from "System";
    abstract class BaseRaycaster extends UIBehaviour {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        toString(): string
        readonly eventCamera: Camera
        readonly sortOrderPriority: number
        readonly renderOrderPriority: number
        readonly rootRaycaster: BaseRaycaster
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Behaviour } from "UnityEngine";
    class GraphicRegistry extends Object {
        static RegisterGraphicForCanvas(c: any, graphic: Graphic): void
        static RegisterRaycastGraphicForCanvas(c: any, graphic: Graphic): void
        static UnregisterGraphicForCanvas(c: any, graphic: Graphic): void
        static UnregisterRaycastGraphicForCanvas(c: any, graphic: Graphic): void
        static DisableGraphicForCanvas(c: any, graphic: Graphic): void
        static DisableRaycastGraphicForCanvas(c: any, graphic: Graphic): void
        static GetGraphicsForCanvas(canvas: any): any
        static GetRaycastableGraphicsForCanvas(canvas: any): any
        protected constructor()
        static readonly instance: GraphicRegistry
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Sprite, Material, Texture, Vector2, Camera } from "UnityEngine";
    class Image extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, ILayoutElement, IClippable {
        DisableSpriteOptimizations(): void
        OnBeforeSerialize(): void
        OnAfterDeserialize(): void
        SetNativeSize(): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        IsRaycastLocationValid(screenPoint: Vector2, eventCamera: Camera): boolean
        /*protected*/ constructor()
        sprite: Sprite
        overrideSprite: Sprite
        type: Image.Type
        preserveAspect: boolean
        fillCenter: boolean
        fillMethod: Image.FillMethod
        fillAmount: number
        fillClockwise: boolean
        fillOrigin: number
        alphaHitTestMinimumThreshold: number
        useSpriteMesh: boolean
        static readonly defaultETC1GraphicMaterial: Material
        readonly mainTexture: Texture
        readonly hasBorder: boolean
        pixelsPerUnitMultiplier: number
        readonly pixelsPerUnit: number
        material: Material
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Material, Rect, Vector2 } from "UnityEngine";
    abstract class MaskableGraphic extends Graphic implements IMaterialModifier, IMaskable, ICanvasElement, IClippable {
        GetModifiedMaterial(baseMaterial: Material): Material
        Cull(clipRect: Rect, validRect: boolean): void
        SetClipRect(clipRect: Rect, validRect: boolean): void
        SetClipSoftness(clipSoftness: Vector2): void
        RecalculateClipping(): void
        RecalculateMasking(): void
        onCullStateChanged: MaskableGraphic.CullStateChangedEvent
        maskable: boolean
        isMaskingGraphic: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface IMaskable {
        RecalculateMasking(): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { IBeginDragHandler, IDragHandler, IEndDragHandler, IEventSystemHandler, IPointerEnterHandler, IUpdateSelectedHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    import { Color, Event } from "UnityEngine";
    import { Object, Enum } from "System";
    class InputField extends Selectable implements IBeginDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, IUpdateSelectedHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ILayoutElement, ISubmitHandler, IPointerClickHandler {
        SetTextWithoutNotify(input: string): void
        MoveTextEnd(shift: boolean): void
        MoveTextStart(shift: boolean): void
        OnBeginDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        ProcessEvent(e: Event): void
        OnUpdateSelected(eventData: BaseEventData): void
        ForceLabelUpdate(): void
        Rebuild(update: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        ActivateInputField(): void
        OnSelect(eventData: BaseEventData): void
        OnPointerClick(eventData: PointerEventData): void
        DeactivateInputField(): void
        OnDeselect(eventData: BaseEventData): void
        OnSubmit(eventData: BaseEventData): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        /*protected*/ constructor()
        shouldHideMobileInput: boolean
        shouldActivateOnSelect: boolean
        text: string
        readonly isFocused: boolean
        caretBlinkRate: number
        caretWidth: number
        textComponent: Text
        placeholder: Graphic
        caretColor: Color
        customCaretColor: boolean
        selectionColor: Color
        onEndEdit: InputField.EndEditEvent
        onSubmit: InputField.SubmitEvent
        onValueChanged: InputField.OnChangeEvent
        characterLimit: number
        contentType: InputField.ContentType
        lineType: InputField.LineType
        inputType: InputField.InputType
        readonly touchScreenKeyboard: any
        keyboardType: any
        characterValidation: InputField.CharacterValidation
        readOnly: boolean
        readonly multiLine: boolean
        asteriskChar: string
        readonly wasCanceled: boolean
        caretPosition: number
        selectionAnchorPosition: number
        selectionFocusPosition: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
        onValidateInput(op: "get"): (text: string, charIndex: number, addedChar: string) => string
        onValidateInput(op: "add" | "remove" | "set", fn?: (text: string, charIndex: number, addedChar: string) => string): void
        onValidateInput(op: "add" | "remove" | "set" | "get", fn?: (text: string, charIndex: number, addedChar: string) => string): (text: string, charIndex: number, addedChar: string) => string | void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class AspectRatioFitter extends UIBehaviour implements ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        IsComponentValidOnObject(): boolean
        IsAspectModeValid(): boolean
        /*protected*/ constructor()
        aspectMode: AspectRatioFitter.AspectMode
        aspectRatio: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Vector2 } from "UnityEngine";
    class CanvasScaler extends UIBehaviour {
        /*protected*/ constructor()
        uiScaleMode: CanvasScaler.ScaleMode
        referencePixelsPerUnit: number
        scaleFactor: number
        referenceResolution: Vector2
        screenMatchMode: CanvasScaler.ScreenMatchMode
        matchWidthOrHeight: number
        physicalUnit: CanvasScaler.Unit
        fallbackScreenDPI: number
        defaultSpriteDPI: number
        dynamicPixelsPerUnit: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class ContentSizeFitter extends UIBehaviour implements ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        horizontalFit: ContentSizeFitter.FitMode
        verticalFit: ContentSizeFitter.FitMode
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Vector2 } from "UnityEngine";
    class GridLayoutGroup extends LayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        startCorner: GridLayoutGroup.Corner
        startAxis: GridLayoutGroup.Axis
        cellSize: Vector2
        spacing: Vector2
        constraint: GridLayoutGroup.Constraint
        constraintCount: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Object } from "System";
    import { TextAnchor } from "UnityEngine";
    abstract class LayoutGroup extends UIBehaviour implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        padding: any
        childAlignment: TextAnchor
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    class HorizontalLayoutGroup extends HorizontalOrVerticalLayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    abstract class HorizontalOrVerticalLayoutGroup extends LayoutGroup implements ILayoutElement, ILayoutController {
        spacing: number
        childForceExpandWidth: boolean
        childForceExpandHeight: boolean
        childControlWidth: boolean
        childControlHeight: boolean
        childScaleWidth: boolean
        childScaleHeight: boolean
        reverseArrangement: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface ILayoutElement {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface ILayoutController {
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface ILayoutIgnorer {
        readonly ignoreLayout: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    class LayoutElement extends UIBehaviour implements ILayoutIgnorer, ILayoutElement {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        /*protected*/ constructor()
        ignoreLayout: boolean
        minWidth: number
        minHeight: number
        preferredWidth: number
        preferredHeight: number
        flexibleWidth: number
        flexibleHeight: number
        layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Transform, RectTransform } from "UnityEngine";
    class LayoutRebuilder extends Object implements ICanvasElement {
        constructor()
        IsDestroyed(): boolean
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        GetHashCode(): number
        Equals(obj: Object): boolean
        toString(): string
        static ForceRebuildLayoutImmediate(layoutRoot: RectTransform): void
        static MarkLayoutForRebuild(rect: RectTransform): void
        readonly transform: Transform
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { RectTransform } from "UnityEngine";
    abstract class LayoutUtility extends Object {
        static GetMinSize(rect: RectTransform, axis: number): number
        static GetPreferredSize(rect: RectTransform, axis: number): number
        static GetFlexibleSize(rect: RectTransform, axis: number): number
        static GetMinWidth(rect: RectTransform): number
        static GetPreferredWidth(rect: RectTransform): number
        static GetFlexibleWidth(rect: RectTransform): number
        static GetMinHeight(rect: RectTransform): number
        static GetPreferredHeight(rect: RectTransform): number
        static GetFlexibleHeight(rect: RectTransform): number
        static GetLayoutProperty(rect: RectTransform, property: (arg: ILayoutElement) => number, defaultValue: number, source: jsb.Out<ILayoutElement>): number
        static GetLayoutProperty(rect: RectTransform, property: (arg: ILayoutElement) => number, defaultValue: number): number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    class VerticalLayoutGroup extends HorizontalOrVerticalLayoutGroup implements ILayoutElement, ILayoutController {
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { RectTransform, Vector2, Camera, Material } from "UnityEngine";
    class Mask extends UIBehaviour implements IMaterialModifier {
        MaskEnabled(): boolean
        IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean
        GetModifiedMaterial(baseMaterial: Material): Material
        /*protected*/ constructor()
        readonly rectTransform: RectTransform
        showMaskGraphic: boolean
        readonly graphic: Graphic
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Component, Transform } from "UnityEngine";
    class MaskUtilities extends Object {
        constructor()
        static Notify2DMaskStateChanged(mask: Component): void
        static NotifyStencilStateChanged(mask: Component): void
        static FindRootSortOverrideCanvas(start: Transform): Transform
        static GetStencilDepth(transform: Transform, stopAfter: Transform): number
        static IsDescendantOrSelf(father: Transform, child: Transform): boolean
        static GetRectMaskForClippable(clippable: IClippable): RectMask2D
        static GetRectMasksForClip(clipper: RectMask2D, masks: any): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Material } from "UnityEngine";
    interface IMaterialModifier {
        GetModifiedMaterial(baseMaterial: Material): Material
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    class Navigation extends ValueType {
        constructor()
        Equals(other: Navigation): boolean
        Equals(obj: Object): boolean
        mode: Navigation.Mode
        wrapAround: boolean
        selectOnUp: Selectable
        selectOnDown: Selectable
        selectOnLeft: Selectable
        selectOnRight: Selectable
        static readonly defaultNavigation: Navigation
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Texture, Rect } from "UnityEngine";
    class RawImage extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, IClippable {
        SetNativeSize(): void
        /*protected*/ constructor()
        readonly mainTexture: Texture
        texture: Texture
        uvRect: Rect
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Vector4, Vector2Int, Rect, RectTransform, Vector2, Camera } from "UnityEngine";
    class RectMask2D extends UIBehaviour implements IClipper {
        IsRaycastLocationValid(sp: Vector2, eventCamera: Camera): boolean
        PerformClipping(): void
        UpdateClipSoftness(): void
        AddClippable(clippable: IClippable): void
        RemoveClippable(clippable: IClippable): void
        /*protected*/ constructor()
        padding: Vector4
        softness: Vector2Int
        readonly canvasRect: Rect
        readonly rectTransform: RectTransform
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, PointerEventData, AxisEventData } from "UnityEngine.EventSystems";
    import { RectTransform } from "UnityEngine";
    class Scrollbar extends Selectable implements IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
        SetValueWithoutNotify(input: number): void
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        OnBeginDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnInitializePotentialDrag(eventData: PointerEventData): void
        SetDirection(direction: Scrollbar.Direction, includeRectLayouts: boolean): void
        /*protected*/ constructor()
        handleRect: RectTransform
        direction: Scrollbar.Direction
        value: number
        size: number
        numberOfSteps: number
        onValueChanged: Scrollbar.ScrollEvent
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IEventSystemHandler, IScrollHandler, PointerEventData } from "UnityEngine.EventSystems";
    import { RectTransform, Vector2 } from "UnityEngine";
    class ScrollRect extends UIBehaviour implements IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, ICanvasElement, IEventSystemHandler, IScrollHandler, ILayoutElement, ILayoutController {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        IsActive(): boolean
        StopMovement(): void
        OnScroll(data: PointerEventData): void
        OnInitializePotentialDrag(eventData: PointerEventData): void
        OnBeginDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        SetLayoutHorizontal(): void
        SetLayoutVertical(): void
        /*protected*/ constructor()
        content: RectTransform
        horizontal: boolean
        vertical: boolean
        movementType: ScrollRect.MovementType
        elasticity: number
        inertia: boolean
        decelerationRate: number
        scrollSensitivity: number
        viewport: RectTransform
        horizontalScrollbar: Scrollbar
        verticalScrollbar: Scrollbar
        horizontalScrollbarVisibility: ScrollRect.ScrollbarVisibility
        verticalScrollbarVisibility: ScrollRect.ScrollbarVisibility
        horizontalScrollbarSpacing: number
        verticalScrollbarSpacing: number
        onValueChanged: ScrollRect.ScrollRectEvent
        velocity: Vector2
        normalizedPosition: Vector2
        horizontalNormalizedPosition: number
        verticalNormalizedPosition: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { IInitializePotentialDragHandler, IDragHandler, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, PointerEventData, AxisEventData } from "UnityEngine.EventSystems";
    import { RectTransform } from "UnityEngine";
    class Slider extends Selectable implements IInitializePotentialDragHandler, IDragHandler, ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler {
        SetValueWithoutNotify(input: number): void
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        OnPointerDown(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        FindSelectableOnLeft(): Selectable
        FindSelectableOnRight(): Selectable
        FindSelectableOnUp(): Selectable
        FindSelectableOnDown(): Selectable
        OnInitializePotentialDrag(eventData: PointerEventData): void
        SetDirection(direction: Slider.Direction, includeRectLayouts: boolean): void
        /*protected*/ constructor()
        fillRect: RectTransform
        handleRect: RectTransform
        direction: Slider.Direction
        minValue: number
        maxValue: number
        wholeNumbers: boolean
        value: number
        normalizedValue: number
        onValueChanged: Slider.SliderEvent
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { ValueType, Object } from "System";
    import { Sprite } from "UnityEngine";
    class SpriteState extends ValueType {
        constructor()
        Equals(other: SpriteState): boolean
        Equals(obj: Object): boolean
        highlightedSprite: Sprite
        pressedSprite: Sprite
        selectedSprite: Sprite
        disabledSprite: Sprite
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Enum } from "System";
    import { Material } from "UnityEngine";
    abstract class StencilMaterial extends Object {
        static Add(baseMat: Material, stencilID: number, operation: any, compareFunction: any, colorWriteMask: any, readMask: number, writeMask: number): Material
        static Add(baseMat: Material, stencilID: number, operation: any, compareFunction: any, colorWriteMask: any): Material
        static Remove(customMat: Material): void
        static ClearAll(): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, Enum, ValueType } from "System";
    import { Texture, Object as Object1, TextAnchor, Vector2 } from "UnityEngine";
    class Text extends MaskableGraphic implements IMaterialModifier, IMaskable, ICanvasElement, ILayoutElement, IClippable {
        FontTextureChanged(): void
        GetGenerationSettings(extents: Vector2): any
        CalculateLayoutInputHorizontal(): void
        CalculateLayoutInputVertical(): void
        static GetTextAnchorPivot(anchor: TextAnchor): Vector2
        /*protected*/ constructor()
        readonly cachedTextGenerator: any
        readonly cachedTextGeneratorForLayout: any
        readonly mainTexture: Texture
        font: any
        text: string
        supportRichText: boolean
        resizeTextForBestFit: boolean
        resizeTextMinSize: number
        resizeTextMaxSize: number
        alignment: TextAnchor
        alignByGeometry: boolean
        fontSize: number
        horizontalOverflow: any
        verticalOverflow: any
        lineSpacing: number
        fontStyle: any
        readonly pixelsPerUnit: number
        readonly minWidth: number
        readonly preferredWidth: number
        readonly flexibleWidth: number
        readonly minHeight: number
        readonly preferredHeight: number
        readonly flexibleHeight: number
        readonly layoutPriority: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler, PointerEventData, BaseEventData } from "UnityEngine.EventSystems";
    class Toggle extends Selectable implements ICanvasElement, IEventSystemHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IPointerUpHandler, IMoveHandler, ISubmitHandler, IPointerClickHandler {
        Rebuild(executing: CanvasUpdate): void
        LayoutComplete(): void
        GraphicUpdateComplete(): void
        SetIsOnWithoutNotify(value: boolean): void
        OnPointerClick(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        /*protected*/ constructor()
        group: ToggleGroup
        isOn: boolean
        toggleTransition: Toggle.ToggleTransition
        graphic: Graphic
        onValueChanged: Toggle.ToggleEvent
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { IEnumerable } from "System.Collections.Generic";
    class ToggleGroup extends UIBehaviour {
        NotifyToggleOn(toggle: Toggle, sendCallback: boolean): void
        UnregisterToggle(toggle: Toggle): void
        RegisterToggle(toggle: Toggle): void
        EnsureValidState(): void
        AnyTogglesOn(): boolean
        ActiveToggles(): any
        GetFirstActiveToggle(): Toggle
        SetAllTogglesOff(sendCallback: boolean): void
        /*protected*/ constructor()
        allowSwitchOff: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object, ValueType, Array } from "System";
    import { Object as Object1, Vector3, Color32, Vector4 } from "UnityEngine";
    class VertexHelper extends Object {
        constructor(m: any)
        constructor()
        Dispose(): void
        Clear(): void
        PopulateUIVertex(vertex: jsb.Ref<any>, i: number): void
        SetUIVertex(vertex: any, i: number): void
        FillMesh(mesh: any): void
        AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, uv2: Vector4, uv3: Vector4, normal: Vector3, tangent: Vector4): void
        AddVert(position: Vector3, color: Color32, uv0: Vector4, uv1: Vector4, normal: Vector3, tangent: Vector4): void
        AddVert(position: Vector3, color: Color32, uv0: Vector4): void
        AddVert(v: any): void
        AddTriangle(idx0: number, idx1: number, idx2: number): void
        AddUIVertexQuad(verts: Array<any>): void
        AddUIVertexStream(verts: any, indices: any): void
        AddUIVertexTriangleStream(verts: any): void
        GetUIVertexStream(stream: any): void
        readonly currentVertCount: number
        readonly currentIndexCount: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UIBehaviour } from "UnityEngine.EventSystems";
    import { Object } from "UnityEngine";
    abstract class BaseMeshEffect extends UIBehaviour implements IMeshModifier {
        ModifyMesh(mesh: any): void
        ModifyMesh(vh: VertexHelper): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    interface IMeshModifier {
        ModifyMesh(verts: VertexHelper): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    class Outline extends Shadow implements IMeshModifier {
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Color, Vector2 } from "UnityEngine";
    class Shadow extends BaseMeshEffect implements IMeshModifier {
        /*protected*/ constructor()
        effectColor: Color
        effectDistance: Vector2
        useGraphicAlpha: boolean
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    class PositionAsUV1 extends BaseMeshEffect implements IMeshModifier {
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.UIElements" {
    import * as jsb from "jsb";
    import { UIBehaviour, ICancelHandler, IEventSystemHandler, IScrollHandler, IPointerMoveHandler, IPointerEnterHandler, IPointerExitHandler, ISelectHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler, ISubmitHandler, BaseEventData, PointerEventData, AxisEventData } from "UnityEngine.EventSystems";
    class PanelEventHandler extends UIBehaviour implements ICancelHandler, IEventSystemHandler, IScrollHandler, IPointerMoveHandler, IPointerEnterHandler, IPointerExitHandler, ISelectHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler, ISubmitHandler {
        constructor()
        OnSelect(eventData: BaseEventData): void
        OnDeselect(eventData: BaseEventData): void
        OnPointerMove(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerExit(eventData: PointerEventData): void
        OnPointerEnter(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        OnCancel(eventData: BaseEventData): void
        OnMove(eventData: AxisEventData): void
        OnScroll(eventData: PointerEventData): void
        panel: any
    }
}
declare module "UnityEngine.UIElements" {
    import * as jsb from "jsb";
    import { BaseRaycaster, PointerEventData, RaycastResult } from "UnityEngine.EventSystems";
    import { Camera } from "UnityEngine";
    import { Object } from "System";
    class PanelRaycaster extends BaseRaycaster {
        constructor()
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        panel: any
        readonly sortOrderPriority: number
        readonly renderOrderPriority: number
        readonly eventCamera: Camera
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Vector2 } from "UnityEngine";
    class AxisEventData extends BaseEventData {
        constructor(eventSystem: EventSystem)
        moveVector: Vector2
        moveDir: MoveDirection
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    class BaseEventData extends AbstractEventData {
        constructor(eventSystem: EventSystem)
        readonly currentInputModule: BaseInputModule
        selectedObject: GameObject
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Object } from "System";
    abstract class AbstractEventData extends Object {
        Reset(): void
        Use(): void
        readonly used: boolean
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { GameObject, Vector2, Camera } from "UnityEngine";
    import { Object } from "System";
    class PointerEventData extends BaseEventData {
        constructor(eventSystem: EventSystem)
        IsPointerMoving(): boolean
        IsScrolling(): boolean
        toString(): string
        pointerEnter: GameObject
        readonly lastPress: GameObject
        rawPointerPress: GameObject
        pointerDrag: GameObject
        pointerClick: GameObject
        pointerCurrentRaycast: RaycastResult
        pointerPressRaycast: RaycastResult
        eligibleForClick: boolean
        pointerId: number
        position: Vector2
        delta: Vector2
        pressPosition: Vector2
        clickTime: number
        clickCount: number
        scrollDelta: Vector2
        useDragThreshold: boolean
        dragging: boolean
        button: PointerEventData.InputButton
        pressure: number
        tangentialPressure: number
        altitudeAngle: number
        azimuthAngle: number
        twist: number
        radius: Vector2
        radiusVariance: Vector2
        fullyExited: boolean
        reentered: boolean
        readonly enterEventCamera: Camera
        readonly pressEventCamera: Camera
        pointerPress: GameObject
        hovered: any
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    enum EventHandle {
        Unused = 0,
        Used = 1,
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IEventSystemHandler {
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerMoveHandler extends IEventSystemHandler {
        OnPointerMove(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerEnterHandler extends IEventSystemHandler {
        OnPointerEnter(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerExitHandler extends IEventSystemHandler {
        OnPointerExit(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerDownHandler extends IEventSystemHandler {
        OnPointerDown(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerUpHandler extends IEventSystemHandler {
        OnPointerUp(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IPointerClickHandler extends IEventSystemHandler {
        OnPointerClick(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IBeginDragHandler extends IEventSystemHandler {
        OnBeginDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IInitializePotentialDragHandler extends IEventSystemHandler {
        OnInitializePotentialDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IDragHandler extends IEventSystemHandler {
        OnDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IEndDragHandler extends IEventSystemHandler {
        OnEndDrag(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IDropHandler extends IEventSystemHandler {
        OnDrop(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IScrollHandler extends IEventSystemHandler {
        OnScroll(eventData: PointerEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IUpdateSelectedHandler extends IEventSystemHandler {
        OnUpdateSelected(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface ISelectHandler extends IEventSystemHandler {
        OnSelect(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IDeselectHandler extends IEventSystemHandler {
        OnDeselect(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface IMoveHandler extends IEventSystemHandler {
        OnMove(eventData: AxisEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface ISubmitHandler extends IEventSystemHandler {
        OnSubmit(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    interface ICancelHandler extends IEventSystemHandler {
        OnCancel(eventData: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    import { Object } from "System";
    class EventSystem extends UIBehaviour {
        UpdateModules(): void
        SetSelectedGameObject(selected: GameObject, pointer: BaseEventData): void
        SetSelectedGameObject(selected: GameObject): void
        RaycastAll(eventData: PointerEventData, raycastResults: any): void
        IsPointerOverGameObject(pointerId: number): boolean
        IsPointerOverGameObject(): boolean
        toString(): string
        static SetUITookitEventSystemOverride(activeEventSystem: EventSystem, sendEvents: boolean, createPanelGameObjectsOnStart: boolean): void
        /*protected*/ constructor()
        static current: EventSystem
        sendNavigationEvents: boolean
        pixelDragThreshold: number
        readonly currentInputModule: BaseInputModule
        firstSelectedGameObject: GameObject
        readonly currentSelectedGameObject: GameObject
        readonly isFocused: boolean
        readonly alreadySelecting: boolean
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { MonoBehaviour } from "UnityEngine";
    import { Object } from "System";
    class EventTrigger extends MonoBehaviour implements ICancelHandler, IBeginDragHandler, IInitializePotentialDragHandler, IDragHandler, IEndDragHandler, IDropHandler, IEventSystemHandler, IScrollHandler, IUpdateSelectedHandler, IPointerEnterHandler, ISelectHandler, IPointerExitHandler, IDeselectHandler, IPointerDownHandler, IMoveHandler, IPointerUpHandler, ISubmitHandler, IPointerClickHandler {
        OnPointerEnter(eventData: PointerEventData): void
        OnPointerExit(eventData: PointerEventData): void
        OnDrag(eventData: PointerEventData): void
        OnDrop(eventData: PointerEventData): void
        OnPointerDown(eventData: PointerEventData): void
        OnPointerUp(eventData: PointerEventData): void
        OnPointerClick(eventData: PointerEventData): void
        OnSelect(eventData: BaseEventData): void
        OnDeselect(eventData: BaseEventData): void
        OnScroll(eventData: PointerEventData): void
        OnMove(eventData: AxisEventData): void
        OnUpdateSelected(eventData: BaseEventData): void
        OnInitializePotentialDrag(eventData: PointerEventData): void
        OnBeginDrag(eventData: PointerEventData): void
        OnEndDrag(eventData: PointerEventData): void
        OnSubmit(eventData: BaseEventData): void
        OnCancel(eventData: BaseEventData): void
        /*protected*/ constructor()
        triggers: any
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    enum EventTriggerType {
        PointerEnter = 0,
        PointerExit = 1,
        PointerDown = 2,
        PointerUp = 3,
        PointerClick = 4,
        Drag = 5,
        Drop = 6,
        Scroll = 7,
        UpdateSelected = 8,
        Select = 9,
        Deselect = 10,
        Move = 11,
        InitializePotentialDrag = 12,
        BeginDrag = 13,
        EndDrag = 14,
        Submit = 15,
        Cancel = 16,
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Object } from "System";
    abstract class ExecuteEvents extends Object {
        static pointerMoveHandler(op: "get"): (handler: IPointerMoveHandler, eventData: BaseEventData) => void
        static pointerEnterHandler(op: "get"): (handler: IPointerEnterHandler, eventData: BaseEventData) => void
        static pointerExitHandler(op: "get"): (handler: IPointerExitHandler, eventData: BaseEventData) => void
        static pointerDownHandler(op: "get"): (handler: IPointerDownHandler, eventData: BaseEventData) => void
        static pointerUpHandler(op: "get"): (handler: IPointerUpHandler, eventData: BaseEventData) => void
        static pointerClickHandler(op: "get"): (handler: IPointerClickHandler, eventData: BaseEventData) => void
        static initializePotentialDrag(op: "get"): (handler: IInitializePotentialDragHandler, eventData: BaseEventData) => void
        static beginDragHandler(op: "get"): (handler: IBeginDragHandler, eventData: BaseEventData) => void
        static dragHandler(op: "get"): (handler: IDragHandler, eventData: BaseEventData) => void
        static endDragHandler(op: "get"): (handler: IEndDragHandler, eventData: BaseEventData) => void
        static dropHandler(op: "get"): (handler: IDropHandler, eventData: BaseEventData) => void
        static scrollHandler(op: "get"): (handler: IScrollHandler, eventData: BaseEventData) => void
        static updateSelectedHandler(op: "get"): (handler: IUpdateSelectedHandler, eventData: BaseEventData) => void
        static selectHandler(op: "get"): (handler: ISelectHandler, eventData: BaseEventData) => void
        static deselectHandler(op: "get"): (handler: IDeselectHandler, eventData: BaseEventData) => void
        static moveHandler(op: "get"): (handler: IMoveHandler, eventData: BaseEventData) => void
        static submitHandler(op: "get"): (handler: ISubmitHandler, eventData: BaseEventData) => void
        static cancelHandler(op: "get"): (handler: ICancelHandler, eventData: BaseEventData) => void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Enum, ValueType } from "System";
    import { Vector2 } from "UnityEngine";
    class BaseInput extends UIBehaviour {
        constructor()
        GetMouseButtonDown(button: number): boolean
        GetMouseButtonUp(button: number): boolean
        GetMouseButton(button: number): boolean
        GetTouch(index: number): any
        GetAxisRaw(axisName: string): number
        GetButtonDown(buttonName: string): boolean
        readonly compositionString: string
        imeCompositionMode: any
        compositionCursorPos: Vector2
        readonly mousePresent: boolean
        readonly mousePosition: Vector2
        readonly mouseScrollDelta: Vector2
        readonly touchSupported: boolean
        readonly touchCount: number
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    abstract class BaseInputModule extends UIBehaviour {
        Process(): void
        IsPointerOverGameObject(pointerId: number): boolean
        ShouldActivateModule(): boolean
        DeactivateModule(): void
        ActivateModule(): void
        UpdateModule(): void
        IsModuleSupported(): boolean
        ConvertUIToolkitPointerId(sourcePointerData: PointerEventData): number
        readonly input: BaseInput
        inputOverride: BaseInput
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    abstract class PointerInputModule extends BaseInputModule {
        IsPointerOverGameObject(pointerId: number): boolean
        toString(): string
        static readonly kMouseLeftId: number
        static readonly kMouseRightId: number
        static readonly kMouseMiddleId: number
        static readonly kFakeTouchesId: number
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    class StandaloneInputModule extends PointerInputModule {
        UpdateModule(): void
        ShouldActivateModule(): boolean
        ActivateModule(): void
        DeactivateModule(): void
        Process(): void
        /*protected*/ constructor()
        inputActionsPerSecond: number
        repeatDelay: number
        horizontalAxis: string
        verticalAxis: string
        submitButton: string
        cancelButton: string
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    enum MoveDirection {
        Left = 0,
        Up = 1,
        Right = 2,
        Down = 3,
        None = 4,
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Object } from "System";
    class Physics2DRaycaster extends PhysicsRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Camera, LayerMask } from "UnityEngine";
    import { Object } from "System";
    class PhysicsRaycaster extends BaseRaycaster {
        Raycast(eventData: PointerEventData, resultAppendList: any): void
        /*protected*/ constructor()
        readonly eventCamera: Camera
        readonly depth: number
        readonly finalEventMask: number
        eventMask: LayerMask
        maxRayIntersections: number
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Vector3, Vector2, GameObject } from "UnityEngine";
    class RaycastResult extends ValueType {
        constructor()
        Clear(): void
        toString(): string
        gameObject: GameObject
        readonly isValid: boolean
        module_: BaseRaycaster
        distance: number
        index: number
        depth: number
        sortingGroupID: number
        sortingGroupOrder: number
        sortingLayer: number
        sortingOrder: number
        worldPosition: Vector3
        worldNormal: Vector3
        screenPosition: Vector2
        displayIndex: number
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent } from "UnityEngine.Events";
    namespace Button {
        class ButtonClickedEvent extends UnityEvent {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    /** A zero argument persistent callback that can be saved with the Scene.
     */
    class UnityEvent extends UnityEventBase {
        constructor()
        /** Add a non persistent listener to the UnityEvent.
         * @param call Callback function.
         */
        AddListener(call: () => void): void
        /** Remove a non persistent listener from the UnityEvent. If you have added the same listener multiple times, this method will remove all occurrences of it.
         * @param call Callback function.
         */
        RemoveListener(call: () => void): void
        Invoke(): void
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    import { Object, Array, Enum } from "System";
    import { Object as Object1 } from "UnityEngine";
    /** Abstract base class for UnityEvents.
     */
    abstract class UnityEventBase extends Object {
        GetPersistentEventCount(): number
        /** Get the target component of the listener at index index.
         * @param index Index of the listener to query.
         */
        GetPersistentTarget(index: number): Object1
        /** Get the target method name of the listener at index index.
         * @param index Index of the listener to query.
         */
        GetPersistentMethodName(index: number): string
        /** Modify the execution state of a persistent listener.
         * @param index Index of the listener to query.
         * @param state State to set.
         */
        SetPersistentListenerState(index: number, state: any): void
        /** Returns the execution state of a persistent listener.
         * @param index Index of the listener to query.
         * @returns Execution state of the persistent listener. 
         */
        GetPersistentListenerState(index: number): any
        RemoveAllListeners(): void
        toString(): string
        /** Given an object, function name, and a list of argument types; find the method that matches.
         * @param obj Object to search for the method.
         * @param functionName Function name to search for.
         * @param argumentTypes Argument types for the function.
         */
        static GetValidMethodInfo(obj: Object, functionName: string, argumentTypes: Array<any>): any
        /** Given an object type, function name, and a list of argument types; find the method that matches.
         * @param objectType Object type to search for the method.
         * @param functionName Function name to search for.
         * @param argumentTypes Argument types for the function.
         */
        static GetValidMethodInfo(objectType: any, functionName: string, argumentTypes: Array<any>): any
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { GameObject } from "UnityEngine";
    import { Object } from "System";
    namespace DefaultControls {
        interface IFactoryControls {
            CreateGameObject(name: string, ...components: any[]): GameObject
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { ValueType } from "System";
    import { Sprite } from "UnityEngine";
    namespace DefaultControls {
        class Resources extends ValueType {
            constructor()
            standard: Sprite
            background: Sprite
            inputField: Sprite
            knob: Sprite
            checkmark: Sprite
            dropdown: Sprite
            mask: Sprite
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    import { Sprite } from "UnityEngine";
    namespace Dropdown {
        class OptionData extends Object {
            constructor(text: string, image: Sprite)
            constructor(text: string)
            constructor(image: Sprite)
            constructor()
            text: string
            image: Sprite
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace Dropdown {
        class OptionDataList extends Object {
            constructor()
            options: any
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace Dropdown {
        class DropdownEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    class UnityEvent_Int32 extends UnityEventBase {
        constructor()
        AddListener(call: (id: number) => void): void
        RemoveListener(call: (id: number) => void): void
        Invoke(arg0: number): void
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    class UnityEvent1<T0> extends UnityEventBase {
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace GraphicRaycaster {
        enum BlockingObjects {
            None = 0,
            TwoD = 1,
            ThreeD = 2,
            All = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum Type {
            Simple = 0,
            Sliced = 1,
            Tiled = 2,
            Filled = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum FillMethod {
            Horizontal = 0,
            Vertical = 1,
            Radial90 = 2,
            Radial180 = 3,
            Radial360 = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum OriginHorizontal {
            Left = 0,
            Right = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum OriginVertical {
            Bottom = 0,
            Top = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum Origin90 {
            BottomLeft = 0,
            TopLeft = 1,
            TopRight = 2,
            BottomRight = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum Origin180 {
            Bottom = 0,
            Left = 1,
            Top = 2,
            Right = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Image {
        enum Origin360 {
            Bottom = 0,
            Right = 1,
            Top = 2,
            Left = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace InputField {
        enum ContentType {
            Standard = 0,
            Autocorrected = 1,
            IntegerNumber = 2,
            DecimalNumber = 3,
            Alphanumeric = 4,
            Name = 5,
            EmailAddress = 6,
            Password = 7,
            Pin = 8,
            Custom = 9,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace InputField {
        enum InputType {
            Standard = 0,
            AutoCorrect = 1,
            Password = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace InputField {
        enum CharacterValidation {
            None = 0,
            Integer = 1,
            Decimal = 2,
            Alphanumeric = 3,
            Name = 4,
            EmailAddress = 5,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace InputField {
        enum LineType {
            SingleLine = 0,
            MultiLineSubmit = 1,
            MultiLineNewline = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace InputField {
        class SubmitEvent extends UnityEvent1<string> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    class UnityEvent_String extends UnityEventBase {
        constructor()
        AddListener(call: (obj: string) => void): void
        RemoveListener(call: (obj: string) => void): void
        Invoke(arg0: string): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace InputField {
        class EndEditEvent extends UnityEvent1<string> {
            constructor()
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace InputField {
        class OnChangeEvent extends UnityEvent1<string> {
            constructor()
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace AspectRatioFitter {
        enum AspectMode {
            None = 0,
            WidthControlsHeight = 1,
            HeightControlsWidth = 2,
            FitInParent = 3,
            EnvelopeParent = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace CanvasScaler {
        enum ScaleMode {
            ConstantPixelSize = 0,
            ScaleWithScreenSize = 1,
            ConstantPhysicalSize = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace CanvasScaler {
        enum ScreenMatchMode {
            MatchWidthOrHeight = 0,
            Expand = 1,
            Shrink = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace CanvasScaler {
        enum Unit {
            Centimeters = 0,
            Millimeters = 1,
            Inches = 2,
            Points = 3,
            Picas = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace ContentSizeFitter {
        enum FitMode {
            Unconstrained = 0,
            MinSize = 1,
            PreferredSize = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace GridLayoutGroup {
        enum Corner {
            UpperLeft = 0,
            UpperRight = 1,
            LowerLeft = 2,
            LowerRight = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace GridLayoutGroup {
        enum Axis {
            Horizontal = 0,
            Vertical = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace GridLayoutGroup {
        enum Constraint {
            Flexible = 0,
            FixedColumnCount = 1,
            FixedRowCount = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace MaskableGraphic {
        class CullStateChangedEvent extends UnityEvent1<boolean> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    class UnityEvent_Boolean extends UnityEventBase {
        constructor()
        AddListener(call: (obj: boolean) => void): void
        RemoveListener(call: (obj: boolean) => void): void
        Invoke(arg0: boolean): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Navigation {
        enum Mode {
            None = 0,
            Horizontal = 1,
            Vertical = 2,
            Automatic = 3,
            Explicit = 4,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Scrollbar {
        enum Direction {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace Scrollbar {
        class ScrollEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    class UnityEvent_Single extends UnityEventBase {
        constructor()
        AddListener(call: (arg0: number) => void): void
        RemoveListener(call: (arg0: number) => void): void
        Invoke(arg0: number): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace ScrollRect {
        enum MovementType {
            Unrestricted = 0,
            Elastic = 1,
            Clamped = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace ScrollRect {
        enum ScrollbarVisibility {
            Permanent = 0,
            AutoHide = 1,
            AutoHideAndExpandViewport = 2,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { Vector2 } from "UnityEngine";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace ScrollRect {
        class ScrollRectEvent extends UnityEvent1<Vector2> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    import { Vector2 } from "UnityEngine";
    class UnityEvent_Vector2 extends UnityEventBase {
        constructor()
        AddListener(call: (arg0: Vector2) => void): void
        RemoveListener(call: (arg0: Vector2) => void): void
        Invoke(arg0: Vector2): void
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Selectable {
        enum Transition {
            None = 0,
            ColorTint = 1,
            SpriteSwap = 2,
            Animation = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Slider {
        enum Direction {
            LeftToRight = 0,
            RightToLeft = 1,
            BottomToTop = 2,
            TopToBottom = 3,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace Slider {
        class SliderEvent extends UnityEvent1<number> {
            constructor()
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    namespace Toggle {
        enum ToggleTransition {
            None = 0,
            Fade = 1,
        }
    }
}
declare module "UnityEngine.UI" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace Toggle {
        class ToggleEvent extends UnityEvent1<boolean> {
            constructor()
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    namespace PointerEventData {
        enum InputButton {
            Left = 0,
            Right = 1,
            Middle = 2,
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    namespace PointerEventData {
        enum FramePressState {
            Pressed = 0,
            Released = 1,
            PressedAndReleased = 2,
            NotChanged = 3,
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { UnityEvent1 } from "UnityEngine.Events";
    namespace EventTrigger {
        class TriggerEvent extends UnityEvent1<BaseEventData> {
            constructor()
        }
    }
}
declare module "UnityEngine.Events" {
    import * as jsb from "jsb";
    import { BaseEventData } from "UnityEngine.EventSystems";
    class UnityEvent_BaseEventData extends UnityEventBase {
        constructor()
        AddListener(call: (arg0: BaseEventData) => void): void
        RemoveListener(call: (arg0: BaseEventData) => void): void
        Invoke(arg0: BaseEventData): void
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace EventTrigger {
        class Entry extends Object {
            constructor()
            eventID: EventTriggerType
            callback: EventTrigger.TriggerEvent
        }
    }
}
declare module "UnityEngine.EventSystems" {
    import * as jsb from "jsb";
    import { Object } from "System";
    namespace PointerInputModule {
        class MouseButtonEventData extends Object {
            constructor()
            PressedThisFrame(): boolean
            ReleasedThisFrame(): boolean
            buttonState: PointerEventData.FramePressState
            buttonData: PointerEventData
        }
    }
}
